<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝·闻·道</title>
  <subtitle>SnoWalker&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuwenliang.net/"/>
  <updated>2022-03-20T10:33:05.650Z</updated>
  <id>http://wuwenliang.net/</id>
  
  <author>
    <name>SnoWalker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>还在卷八股文？来和我卷MIT6.824吧</title>
    <link href="http://wuwenliang.net/2022/03/20/%E8%BF%98%E5%9C%A8%E5%8D%B7%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%9F%E6%9D%A5%E5%92%8C%E6%88%91%E5%8D%B7MIT6-824%E5%90%A7/"/>
    <id>http://wuwenliang.net/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/</id>
    <published>2022-03-20T09:40:14.000Z</published>
    <updated>2022-03-20T10:33:05.650Z</updated>
    
    <content type="html"><![CDATA[<p>有没有想过，有这么一门课程。他不是简单的念PPT，他的老师是计算机史上五大黑客之一的罗伯特·塔潘-莫里斯(RobertTappanMorris)；</p>
<p>有没有想过，有这么一门课程，他会带你阅读GFS、Map Reduce、RAFT、Big Table论文；</p>
<p>来看看他的四个实验作业题：</p>
<ul>
<li>基于论文思路，实现一个简单的 MapReduce 框架。这个作业的实现前提是你得了解 Unix Domain socket，知道goalng plugin（也就是<a href="https://www.zhihu.com/search?q=动态链接&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1524420907}" target="_blank" rel="external">动态链接</a>）。</li>
<li>实现一个完整的Raft协议。这部分拆成了三个部分，它会分别让你实现 Leader Election、AppendEntry RPC 和 Raft persist。<ul>
<li>在这一部分里，我们将使用提供的类库 labrpc 来完成完整的Raft。其中， labrpc 是一个模拟网络环境的 rpc 框架，它是基于 UDP实现的（注意这一点）。</li>
</ul>
</li>
<li>根据自己实现的Raft，写一个KV数据库。同时实现 Raft 协议的 Snapshot RPC。</li>
<li>在之前的作业基础上，为KV数据库实现Sharding分片功能，同时实现 multi Raft功能。</li>
</ul>
<blockquote>
<p>笔者在看到这部分的时候，惊为天人。这课程，硬核！</p>
</blockquote>
<h2 id="这门课就是MIT6-824，由罗伯特·塔潘-莫里斯教授教学。"><a href="#这门课就是MIT6-824，由罗伯特·塔潘-莫里斯教授教学。" class="headerlink" title="这门课就是MIT6.824，由罗伯特·塔潘-莫里斯教授教学。"></a>这门课就是MIT6.824，由罗伯特·塔潘-莫里斯教授教学。</h2><blockquote>
<p>MIT 6.824 是一门讲解分布式系统的课程。</p>
<p>课程内容包括Golang的学习、分布式系统研究动机、<a href="https://www.zhihu.com/search?q=一致性协议算法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1524420907}" target="_blank" rel="external">一致性协议算法</a>、著名分布式系统软件论文讲解和<a href="https://www.zhihu.com/search?q=一致性算法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1524420907}" target="_blank" rel="external">一致性算法</a> （Raft算法）的实现机制及实验。</p>
<p>是一门不可多得的实践性质比较强的课程。</p>
</blockquote>
<p>虽说这门课程受众主要是MIT研究生，但是笔者认为该课程对有一定工作经验的工程师有着更多的指导意义和参考价值。</p>
<p>他可以帮助工程师对自己的知识体系有一个系统性的整理，如果你恰巧是一个动手能力、自学能力强的人，那么这门课程一定适合你。</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>课程是纯英文的，因此对于大多数人而言可能是比较陡峭的门槛，幸运的是，已经有无私的翻译者提供了人工翻译的版本。</p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/1.png" alt="人工翻译版本"></p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/gif.gif" alt=""></p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1x7411M7Sf?p=5" target="_blank" rel="external">B站地址：MIT 6.824 Distributed Systems Spring 2020 分布式系统 中文翻译版合集</a></p>
</blockquote>
<p>除此之外，官方课件的地址在着这里，包括了上文提到的四个实验：</p>
<blockquote>
<p><a href="https://pdos.csail.mit.edu/6.824/schedule.html" target="_blank" rel="external">6.824 Schedule:Spring 2022</a></p>
</blockquote>
<p>Raft作业难度高？不要怕，这里已经网友贡献的学生作业指南：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/200903182" target="_blank" rel="external">Raft学生指南：一</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/203279804" target="_blank" rel="external">Raft学生指南：二</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/205315037" target="_blank" rel="external">Raft学生指南：三</a></p>
</blockquote>
<p>Raft算法不好理解，不够直观？我想这两个可视化呈现Raft算法的网站是你想要的：</p>
<blockquote>
<p><a href="https://raft.github.io/" target="_blank" rel="external">https://raft.github.io/</a>  在该页面的Raft Visualization部分，提供了一个可交互的Raft集群，你可以与该Raft集群进行交互以理解算法。</p>
<p><a href="http://thesecretlivesofdata.com/raft/#intro" target="_blank" rel="external">动画呈现Raft算法的主要细节与设计思想</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="external">Raft论文中文版：寻找一种易于理解的一致性算法</a></p>
</blockquote>
<p>除了课程本身外，如果你还觉得卷地不够爽，那么推荐一本书，可以搭配这门课程一起看，那就是经典的：《DDIA》，全名是《Design Data-Intensive Application》，中文翻译版本名为：<strong>《数据密集型应用系统设计》</strong>。</p>
<p>笔者曾经在工作早期看过几页，奈何功力不够，且内容硬核，遂放弃。现在笔者准备捡起来，努力往后看。</p>
<p>如果确实没有很多时间看视频，也没有关系，已经有大佬把视频内容用文字+图片方式整理出来，以gitbook方式分享了出来。</p>
<blockquote>
<p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/" target="_blank" rel="external">MIT 6.824 文字+图片整理版本</a></p>
</blockquote>
<p>作者将每一节课拆分成若干小节翻译并整理出来，在翻译的同时还加入了自己的理解，可以说是相当诚意的作品了。</p>
<p>上几张图简单感受一下：</p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/2.png" alt=""></p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/3.png" alt=""></p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/4.png" alt=""></p>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><p>简单说一下学习建议。</p>
<p>论文是一定得读的！论文是一定得读的！论文是一定得读的！</p>
<p>重要的话说三遍，因为课堂上，莫里斯教授是以思路讲解和答疑为主的，这都是建立在提前阅读了相关论文资料的前提上开展的，如果压根没有读过相关的论文，那么我相信基本上就是在听天书了。</p>
<p>论文的英文版PDF都能够在课程官网下载到，相关的中译版本也都能通过搜索找到，这里笔者就不提供了，相信有能力的读者都能够自己解决。</p>
<p>课程的schedule页面在   <a href="https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.824/schedule.html" target="_blank" rel="external">https://pdos.csail.mit.edu/6.824/schedule.html</a>，该页面上提供了所有必须的课程资料链接、论文pdf，以及lab作业的资料，甚至是课程视频，都有链接，读者可以按需求下载。</p>
<h2 id="关于LAB作业"><a href="#关于LAB作业" class="headerlink" title="关于LAB作业"></a>关于LAB作业</h2><p>关于如何完成作业，及视频中提到的LAB，笔者简单提供几点建议。</p>
<p>笔者看的版本为2020版本，它的开发语言为<code>Golang</code>，需要学习者提前学习一些go的语法和必须的概念知识。因此开发环境一定需要安装go。莫里斯教授在课堂上也对go语言的设计思想进行了讲解，可以作为参考。</p>
<p>快速学习上手go语言，可以使用以下线上学习指南，你可以在页面上直接写代码并看到直观的运行效果。</p>
<blockquote>
<p><a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="external">https://tour.go-zh.org/welcome/1</a>\</p>
</blockquote>
<p>操作系统建议使用类<code>Unix</code>环境（linux、mac均可），使用<code>Windows</code>需要你做额外的工作以去除环境相关的依赖，既繁琐又不一定保证成功。</p>
<p>建议使用<code>Goland</code>作为<code>IDE</code>开发环境，笔者是坚定的JetBrains粉。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>题目本身是一种调侃，卷八股文也没什么坏处，尤其是对于换工作的同学而言。</p>
<p>但是从长期看，我们还是需要整理一下自己的知识体系，通过学习一些优秀的论文、课程，做一些有代表性的练习来夯实基础。我想，这应当是破除程序员中年诅咒的方式之一吧。</p>
<p>废话不多说，让我们以梦为马，不负韶华。</p>
<p>学就对了！</p>
<p>(后续笔者也会不定时的发表MIT6.824相关的学习笔记和心得，同时欢迎公众号读者积极投稿，共同交流成长。)</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有没有想过，有这么一门课程。他不是简单的念PPT，他的老师是计算机史上五大黑客之一的罗伯特·塔潘-莫里斯(RobertTappanMorris)；&lt;/p&gt;
&lt;p&gt;有没有想过，有这么一门课程，他会带你阅读GFS、Map Reduce、RAFT、Big Table论文；&lt;/p&gt;
    
    </summary>
    
      <category term="MIT" scheme="http://wuwenliang.net/categories/MIT/"/>
    
    
      <category term="MIT" scheme="http://wuwenliang.net/tags/MIT/"/>
    
  </entry>
  
  <entry>
    <title>gRPC从入门到放弃之好家伙，双向流!</title>
    <link href="http://wuwenliang.net/2022/03/17/gRPC%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E4%B9%8B%E5%A5%BD%E5%AE%B6%E4%BC%99%EF%BC%8C%E5%8F%8C%E5%90%91%E6%B5%81/"/>
    <id>http://wuwenliang.net/2022/03/17/gRPC从入门到放弃之好家伙，双向流/</id>
    <published>2022-03-17T14:47:37.000Z</published>
    <updated>2022-03-17T15:55:59.139Z</updated>
    
    <content type="html"><![CDATA[<p>今天来实战一下gRPC的特性，双向流。</p>
<p>首先认识一下，什么是双向流？</p>
<blockquote>
<p>所谓双向流式 RPC ，是由客户端调用方法来初始化，而服务端接收到客户端的元数据，方法名和截止时间。</p>
<p>并且服务端可以选择发送回它的初始元数据或等待客户端发送请求的一种通信方式。</p>
<p>双向流，特点在于双向，也就是请求响应如何起作用是完全取决于应用怎么处理，因为客户端和服务端能在任意顺序上读写 ，也就是说这些流的操作是完全独立的。</p>
<p>例如服务端可以一直等待，直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像”乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。</p>
</blockquote>
<p>通俗地说，客户端发送了 N 个请求，服务端返回 N 个或者 M 个响应，该特性能够充分利用 HTTP/2.0 的多路复用功能。</p>
<p>某个时刻，HTTP/2.0 链路上可以既有请求也有响应，实现了全双工通信（对比单行道和双向车道），双向流式RPC通信用一个简单的图表示如下：</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之好家伙，双向流/grpc双向流.png" alt="grpc双向流.png"></p>
<a id="more"></a>
<h2 id="如何定义双向流呢？"><a href="#如何定义双向流呢？" class="headerlink" title="如何定义双向流呢？"></a>如何定义双向流呢？</h2><blockquote>
<p>一个 <em>双向流式 RPC</em> 是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器 可以以任意喜欢的顺序读写：</p>
<p>比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替 的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。开发者可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</p>
</blockquote>
<p>我们可以在服务的IDL定义文件proto中按照如下方式声明双向流式RPC接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Accepts a stream of RouteNotes sent while a route is being traversed,</div><div class="line">// while receiving other RouteNotes (e.g. from other users).</div><div class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</div></pre></td></tr></table></figure>
<p>声明方式为在请求和响应之前都添加关键字 <code>stream</code>。</p>
<h2 id="实操一把"><a href="#实操一把" class="headerlink" title="实操一把"></a>实操一把</h2><p>有了基本的概念，我们还是直接上手实操一下。</p>
<h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h3><blockquote>
<p>本案例为一个简单的应答接口，客户端向服务端发送问候语，服务端接受问候并返回服务端的问候。</p>
<p>由于是双向流，所以我们可以在一次接口调用中，发送多次问候。</p>
<p>运行的效果就是客户端与服务端的日志是交替打印的，也就是说服务端在客户端调用接口的过程中就可以逐步发送响应结果给客户端，而不是像阻塞式请求一样，等待客户端请求发送完毕，再统一一次性返回接口。</p>
</blockquote>
<p>这种双向流的接口处理模式的好处是显而易见的：</p>
<ul>
<li>如果传输的数据包过大，客户端可以将请求包拆分为多个小包发送至服务端。服务端依次处理小包，发送过程与处理过程互不干扰，互不依赖。</li>
<li>服务端不需要等待客户端包全部发送，才能处理以及响应。</li>
</ul>
<h3 id="服务IDL定义"><a href="#服务IDL定义" class="headerlink" title="服务IDL定义"></a>服务IDL定义</h3><blockquote>
<p>首先还是需要编写定义proto接口定义</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">syntax = &quot;proto3&quot;;</div><div class="line"></div><div class="line">option java_multiple_files = true;</div><div class="line">option java_package = &quot;com.snowalker.grpc.sdk.stream&quot;;</div><div class="line">option java_outer_classname = &quot;DoubleStreamProto&quot;;</div><div class="line"></div><div class="line">// 服务IDL定义</div><div class="line">service DoubleStreamService &#123;</div><div class="line">  rpc chat (stream ChatRequest) returns (stream ChatResponse) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 请求</div><div class="line">message ChatRequest &#123;</div><div class="line">  int32 userId = 1;</div><div class="line">  string msg = 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 响应</div><div class="line">message ChatResponse &#123;</div><div class="line">  int32 userId = 1;</div><div class="line">  string msg = 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点关注chat接口定义，同时声明请求与响应为stream类型，标记这是一个双向流RPC。</p>
<p>对该proto文件进行编译，所在工程grpc-demo-sdk根路径下执行：</p>
<blockquote>
<p>mvn clean compile -DskipTests</p>
</blockquote>
<h3 id="编写服务端–实现服务逻辑"><a href="#编写服务端–实现服务逻辑" class="headerlink" title="编写服务端–实现服务逻辑"></a>编写服务端–实现服务逻辑</h3><p>服务端编写与普通的RPC接口相同，也是需要继承gRPC生成的XXXXGrpc.XXXXXImplBase，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class DoubleStreamServiceImpl extends DoubleStreamServiceGrpc.DoubleStreamServiceImplBase &#123;</div></pre></td></tr></table></figure>
<p>重写chat方法，实现服务端逻辑，可以看到，业务逻辑同阻塞式接口不同，这里将业务逻辑写在了onNext回调方法中，因此我们可以知道这是一种异步回调机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * @param responseObserver</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public StreamObserver&lt;ChatRequest&gt; chat(StreamObserver&lt;ChatResponse&gt; responseObserver) &#123;</div><div class="line">	return new StreamObserver&lt;ChatRequest&gt;() &#123;</div><div class="line">		@Override</div><div class="line">		public void onNext(ChatRequest chatRequest) &#123;</div><div class="line"></div><div class="line">			int userId = chatRequest.getUserId();</div><div class="line">			String msg = chatRequest.getMsg();</div><div class="line"></div><div class="line">			logger.info(&quot;[DoubleStreamServiceImpl] 服务端处理开始....&quot;);</div><div class="line">			logger.info(&quot;[DoubleStreamServiceImpl] 客户端说: [&quot; + msg + &quot;]&quot;);</div><div class="line"></div><div class="line">			responseObserver.onNext(ChatResponse.newBuilder()</div><div class="line">					.setUserId(chatRequest.getUserId())</div><div class="line">					.setMsg(&quot;这是一条来自[服务端]的消息: 你好，收到了-&quot; + userId + &quot; 的消息. &quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ssSSS&quot;).format(new Date()) + &quot;\n&quot;)</div><div class="line">					.build());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void onError(Throwable throwable) &#123;</div><div class="line">			logger.warning(&quot;[DoubleStreamServiceImpl] gRPC dealing error&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void onCompleted() &#123;</div><div class="line">			responseObserver.onCompleted();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造 Streaming 响应对象 StreamObserver并实现 onNext 等接口，由于服务端也是 Streaming模式，因此响应是多个的，也就是说 onNext 会被调用多次。</p>
<p>在onNext方法中编写服务端业务逻辑，这里主要做的就是取出请求体ChatRequest中的userId，以及msg，打印输出，构造响应对象ChatResponse，并return。</p>
<p>实现 onCompleted 方法，调用 <strong>responseObserver.onCompleted()</strong> 将请求返回客户端。</p>
<h3 id="编写服务端–绑定服务实现类"><a href="#编写服务端–绑定服务实现类" class="headerlink" title="编写服务端–绑定服务实现类"></a>编写服务端–绑定服务实现类</h3><p>同一般的阻塞式RPC接口相同，想要使双向流式RPC生效，还需要注册服务实现类到服务端ServerBuilder中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@SneakyThrows</div><div class="line">private void startServer() &#123;</div><div class="line">	int serverPort = 10881;</div><div class="line">	server = ServerBuilder.forPort(serverPort)</div><div class="line">			// 上文中的报价服务实现类</div><div class="line">			.addService(new OrderServiceImpl())</div><div class="line">			// 添加双向流式RPC实现</div><div class="line">			.addService(new DoubleStreamServiceImpl())</div><div class="line">			.build();</div><div class="line">	server.start();</div><div class="line"></div><div class="line">	logger.info(&quot;OrderServerBoot started, listening on:&quot; + serverPort);</div><div class="line"></div><div class="line">	// 优雅停机</div><div class="line">	addGracefulShowdownHook();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="编写客户端–实现客户端逻辑"><a href="#编写客户端–实现客户端逻辑" class="headerlink" title="编写客户端–实现客户端逻辑"></a>编写客户端–实现客户端逻辑</h3><blockquote>
<p>接着编写客户端逻辑。</p>
</blockquote>
<p>双向流式RPC的客户端实现方式与传统阻塞式客户端也是不同的。</p>
<blockquote>
<p>首先定义接口ExtendResponseObserver，继承StreamObserver，用于返回文本格式的响应体，方便观察。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ExtendResponseObserver&lt;T&gt; extends StreamObserver&lt;T&gt; &#123;</div><div class="line">    String getExtra();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>接着编写客户端逻辑。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * @author snowalker</div><div class="line"> * @version 1.0</div><div class="line"> * @date 2022/3/16 23:49</div><div class="line"> * @className</div><div class="line"> * @desc</div><div class="line"> */</div><div class="line">public class DoubleStreamClient &#123;</div><div class="line"></div><div class="line">	private static final Logger logger = Logger.getLogger(DoubleStreamClient.class.getName());</div><div class="line"></div><div class="line">	private final DoubleStreamServiceGrpc.DoubleStreamServiceStub doubleStreamServiceStub;</div><div class="line"></div><div class="line">	public DoubleStreamClient(ManagedChannel channel) &#123;</div><div class="line">		doubleStreamServiceStub = DoubleStreamServiceGrpc.newStub(channel);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String chat(String msg, int user, int count) &#123;</div><div class="line">		ExtendResponseObserver&lt;ChatResponse&gt; chatResponseStreamObserver = new ExtendResponseObserver&lt;ChatResponse&gt;() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public String getExtra() &#123;</div><div class="line">				return stringBuilder.toString();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			// 用stringBuilder保存所有来自服务端的响应</div><div class="line">			private StringBuilder stringBuilder = new StringBuilder();</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void onNext(ChatResponse chatResponse) &#123;</div><div class="line">				logger.info(&quot;[DoubleStreamClient] onNext.....&quot;);</div><div class="line">				// 放入匿名类的成员变量中</div><div class="line">				System.out.println(chatResponse.getMsg());</div><div class="line">				stringBuilder.append(String.format(&quot;服务端响应:%s&lt;br&gt;, 用户:%d&quot; , chatResponse.getMsg(), chatResponse.getUserId()));</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void onError(Throwable throwable) &#123;</div><div class="line">				logger.warning(&quot;[DoubleStreamClient] gRPC request error&quot;);</div><div class="line">				stringBuilder.append(&quot;[DoubleStreamClient]chat gRPC error, &quot; + throwable.getMessage());</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void onCompleted() &#123;</div><div class="line">				logger.info(&quot;[DoubleStreamClient] onCompleted&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		// 重点！！！！ RPC调用发起</div><div class="line">		StreamObserver&lt;ChatRequest&gt; chatRequestStreamObserver = doubleStreamServiceStub.chat(chatResponseStreamObserver);</div><div class="line"></div><div class="line">		for(int i = 0; i &lt; count; i++) &#123;</div><div class="line">			// 每次执行onNext都会发送一笔数据到服务端，</div><div class="line">			// 服务端的onNext方法都会被执行一次</div><div class="line">			ChatRequest chatRequest = ChatRequest.newBuilder()</div><div class="line">					.setUserId(user)</div><div class="line">					.setMsg(&quot;这是一条来自客户端的消息: 你好，&quot; + user + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ssSSS&quot;).format(new Date()))</div><div class="line">					.buildPartial();</div><div class="line">			LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(100));</div><div class="line">			chatRequestStreamObserver.onNext(chatRequest);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 客户端告诉服务端：数据已经发完了</div><div class="line">		chatRequestStreamObserver.onCompleted();</div><div class="line"></div><div class="line">		logger.info(&quot;service finish&quot;);</div><div class="line"></div><div class="line">		return chatResponseStreamObserver.getExtra();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释下代码：</p>
<ul>
<li><p>客户端首先定义ExtendResponseObserver实例，并实现onNext、onError、onCompleted、getExtra等回调方法，用于处理服务端响应、异常情况、请求完成、返回字符形式的响应；</p>
</li>
<li><p>客户端通过在循环中调用 requestObserver 的 onNext 方法，发送请求消息到服务端；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 重点！！！！ RPC调用发起</div><div class="line">StreamObserver&lt;ChatRequest&gt; chatRequestStreamObserver = doubleStreamServiceStub.chat(chatResponseStreamObserver);</div></pre></td></tr></table></figure>
</li>
<li><p>当RPC请求发送完成之后，通过调用 <strong>onCompleted()</strong> 通知服务端数据已经发送完成；</p>
</li>
<li><p><strong>需要特别注意</strong>，客户端发送请求的stub为流式stub为<strong>DoubleStreamServiceGrpc.newStub(channel);</strong> 而非newBlockingStub。</p>
</li>
</ul>
<h3 id="案例运行"><a href="#案例运行" class="headerlink" title="案例运行"></a>案例运行</h3><p>案例运行完毕，我们运行看看效果。</p>
<p>本文开始，运行案例相关展示尝试通过gif动态展示：</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之好家伙，双向流/run.gif" alt="run.gif"></p>
<ul>
<li>先后启动了服务端与客户端，</li>
<li>客户端在一次调用中循环发送chat请求到服务端</li>
<li>服务端边处理请求边响应给客户端</li>
<li>可以看到服务端请求日志在一次调用中是边处理边打印的，客户端日志也是逐步输出的</li>
<li>表明双向流式RPC是异步的、高效的、非阻塞的。</li>
</ul>
<h3 id="客户端流式RPC机理"><a href="#客户端流式RPC机理" class="headerlink" title="客户端流式RPC机理"></a>客户端流式RPC机理</h3><p>稍微翻看源码，可以发现，实际上客户端底层 onNext 方法调用了 ClientCall 的消息发送方法，代码如下（CallToStreamObserverAdapter 类）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private static class CallToStreamObserverAdapter&lt;T&gt; extends ClientCallStreamObserver&lt;T&gt; &#123;</div><div class="line">	 private boolean frozen;</div><div class="line"> 	 private final ClientCall&lt;T, ?&gt; call;</div><div class="line"> 	 private Runnable onReadyHandler;</div><div class="line"> 	 private boolean autoFlowControlEnabled = true;</div><div class="line"> </div><div class="line"> 	 public CallToStreamObserverAdapter(ClientCall&lt;T, ?&gt; call) &#123;</div><div class="line"> 		this.call = call;</div><div class="line"> 	 &#125;</div><div class="line"> </div><div class="line"> 	 private void freeze() &#123;</div><div class="line"> 	 	this.frozen = true;</div><div class="line"> 	 &#125;</div><div class="line"> </div><div class="line"> 	 @Override</div><div class="line">  	 public void onNext(T value) &#123;</div><div class="line"> 		call.sendMessage(value);</div><div class="line"> 	 &#125;</div></pre></td></tr></table></figure>
<p>特别注意的是，对于双向 Streaming 模式，只支持异步调用方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们主要了解了gRPC的双向流式调用，对于这种流模式调用，可以充分利用 HTTP/2.0 协议的多路复用功能，实现在在一条 HTTP 链路上并行双向传输数据（全双工），它可以有效解决 HTTP/1.X 的数据单向传输问题，在大幅减少 HTTP 连接的情况下充分利用单条链路的性能，其性能可以媲美传统的 RPC 私有长连接协议：即通过更少的链路，实现更高的性能。</p>
<p>下篇文章，我们将为我们的grpc通信加入基于Nacos的服务注册发现能力，不见不散。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来实战一下gRPC的特性，双向流。&lt;/p&gt;
&lt;p&gt;首先认识一下，什么是双向流？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓双向流式 RPC ，是由客户端调用方法来初始化，而服务端接收到客户端的元数据，方法名和截止时间。&lt;/p&gt;
&lt;p&gt;并且服务端可以选择发送回它的初始元数据或等待客户端发送请求的一种通信方式。&lt;/p&gt;
&lt;p&gt;双向流，特点在于双向，也就是请求响应如何起作用是完全取决于应用怎么处理，因为客户端和服务端能在任意顺序上读写 ，也就是说这些流的操作是完全独立的。&lt;/p&gt;
&lt;p&gt;例如服务端可以一直等待，直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像”乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗地说，客户端发送了 N 个请求，服务端返回 N 个或者 M 个响应，该特性能够充分利用 HTTP/2.0 的多路复用功能。&lt;/p&gt;
&lt;p&gt;某个时刻，HTTP/2.0 链路上可以既有请求也有响应，实现了全双工通信（对比单行道和双向车道），双向流式RPC通信用一个简单的图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/17/gRPC从入门到放弃之好家伙，双向流/grpc双向流.png&quot; alt=&quot;grpc双向流.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://wuwenliang.net/categories/gRPC/"/>
    
    
      <category term="gRPC" scheme="http://wuwenliang.net/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC从入门到放弃之为gRPC添加服务发现</title>
    <link href="http://wuwenliang.net/2022/03/17/gRPC%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E4%B9%8B%E4%B8%BAgRPC%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>http://wuwenliang.net/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/</id>
    <published>2022-03-17T14:47:22.000Z</published>
    <updated>2022-03-17T14:47:22.244Z</updated>
    
    <content type="html"><![CDATA[<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;hr&gt;&lt;br&gt;版权声明：&lt;br&gt;&lt;br&gt;原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。&lt;br&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学点儿gRPC-从入门到放弃</title>
    <link href="http://wuwenliang.net/2022/03/12/%E5%AD%A6%E7%82%B9%E5%84%BFgRPC-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>http://wuwenliang.net/2022/03/12/学点儿gRPC-从入门到放弃/</id>
    <published>2022-03-12T13:31:45.000Z</published>
    <updated>2022-03-13T04:35:29.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微服务如火如荼的当下，各种服务框架层出不穷。Dubbo、SpringCloud在国内Java后端微服务领域目前占据大部分份额。</p>
<p>但是随着云原生愈发普及，具备跨语言、高性能特性的RPC通信框架横空出世，其中gRPC与Thrift是其中的佼佼者。</p>
</blockquote>
<p>本文我们将视角集中在gRPC这RPC框架。</p>
<blockquote>
<p>gRPC 是Google开源的高性能、通用的RPC框架。客户端与服务端约定接口调用， 可以在各种环境中运行，具有跨语言特性， 适合构建分布式、微服务应用。</p>
</blockquote>
<p>个人认为，gRPC最为杀手锏的特性就是“跨语言”，其次才是高性能。</p>
<p>它的跨语言特性体现在，通过定义IDL（接口定义语言），隔离了不同编程语言之间的差异，对IDL进行编译后，生成对应编程语言的nativeCode，让开发者能够集中注意在实现业务需求上，而不需要花费额外的精力在语言层面上。</p>
<blockquote>
<p>官网的一张图能够很好的体现这个特点</p>
</blockquote>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpc_server.png" alt="gRPC多语言"></p>
<a id="more"></a>
<h2 id="gRPC特性介绍"><a href="#gRPC特性介绍" class="headerlink" title="gRPC特性介绍"></a>gRPC特性介绍</h2><blockquote>
<p>gRPC具备以下特性</p>
</blockquote>
<ul>
<li><p>性能优异：</p>
<ol>
<li><p>它采用Proto Buffer作序列化传输媒介， 对比JSON与XML有数倍提升。</p>
</li>
<li><p>采用HTTP2协议， 对头部信息（header）压缩， 对连接进行复用，能够减少TCP连接次数。</p>
</li>
<li><p>针对Java语言，gRPC底层采用Netty作为NIO处理框架， 性能强劲。</p>
</li>
</ol>
</li>
<li>多语言支持，多客户端接入， 支持C++/GO/Ruby等语言。</li>
<li>支持负载均衡、跟踪、健康检查和认证。</li>
</ul>
<h2 id="gRPC的线程模型是怎样的？"><a href="#gRPC的线程模型是怎样的？" class="headerlink" title="gRPC的线程模型是怎样的？"></a>gRPC的线程模型是怎样的？</h2><blockquote>
<p>笔者主力语言为Java，因此我们讲解也集中在Java的实现上。</p>
</blockquote>
<p>gRPC的Java实现，服务端底层采用了Netty作为核心处理框架，因此其线程模型核心也是遵循了 Netty 的线程分工原则。</p>
<p>协议层消息的接收和编解码由 Netty 的 I/O(NioEventLoop) 线程负责, 应用层的处理由应用线程负责，防止由于应用处理耗时而阻塞 Netty 的 I/O 线程。</p>
<blockquote>
<p>Netty线程模型是基于NIO的Reactor模式。</p>
</blockquote>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpc-03-04.png" alt="gRPC-Java线程模型"></p>
<blockquote>
<p>Netty是基于NIO构建的通信框架。</p>
</blockquote>
<p>在 Java NIO 中最重要的概念就是多路复用器 Selector，它是 Java NIO 编程的基础。Selector提供了选择已经就绪的任务的能力。</p>
<blockquote>
<p>简单来讲，Selector 会不断地轮询注册在其上的 Channel，如果某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I/O 操作。</p>
</blockquote>
<p>一般来说，一个 I/O 线程会聚合一个 Selector，一个 Selector 可以同时注册 N 个 Channel, 这样单个</p>
<p>I/O 线程就可以同时并发处理多个客户端连接。</p>
<p>又由于 I/O 操作是非阻塞的，因此也不会受限于网络速度和对方端点的处理时延，可靠性和效率都得到了很大提升。</p>
<h2 id="gRPC客户端如何请求服务端"><a href="#gRPC客户端如何请求服务端" class="headerlink" title="gRPC客户端如何请求服务端?"></a>gRPC客户端如何请求服务端?</h2><blockquote>
<p>作为RPC框架，至少有客户端和服务端两个角色，对于gRPC而言，客户端请求服务端的调用过程如图所示。</p>
</blockquote>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpc_client_flow.png" alt="客户端请求服务端"></p>
<p>具体过程：</p>
<ul>
<li>【Stub生成】客户端生成Stub ，通过Stub发起 RPC远程服务调用 ；</li>
<li>【负载均衡】客户端获取服务端的地址信息（列表），使用默认的 LoadBalancer 策略，选择一个具体的 gRPC 服务端进行调用；</li>
<li>【建立链接】如果客户端与服务端之间没有可用的连接，则创建 NettyClientTransport 和 NettyClientHandler，建立 HTTP/2 连接；</li>
<li>【客户端请求序列化】对请求使用 PB（Protobuf）序列化，并通过 HTTP/2 Stream 发送给 gRPC 服务端；</li>
<li>【服务端反序列化】服务端接收到响应之后，使用 PB（Protobuf）做反序列化。</li>
<li>【请求响应】回调 GrpcFuture 的 set(Response) 方法，唤醒阻塞的客户端调用线程，获取 RPC 响应数据。</li>
</ul>
<h2 id="gRPC性能到底有多强？"><a href="#gRPC性能到底有多强？" class="headerlink" title="gRPC性能到底有多强？"></a>gRPC性能到底有多强？</h2><blockquote>
<p>没有对比就没有发言权。</p>
</blockquote>
<p>在不同的操作系统，不同请求数量下，对gRPC与Rest请求进行对比的结论如下：</p>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpcvsrest.png" alt=""></p>
<blockquote>
<p>官网也给出了权威性的比对，具体比对gRPC+ProtoBuf与Http+JSON方式请求的差异。</p>
</blockquote>
<p><a href="https://github.com/plutov/benchmark-grpc-protobuf-vs-http-json" target="_blank" rel="external">官方性能比对结果</a></p>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/image-20200207140210335.png" alt=""></p>
<p><strong>实测结果显示GRpc的通讯方案, 性能有32%的提升, 资源占用降低30%左右。</strong></p>
<h2 id="gRPC-Java-服务调用实战"><a href="#gRPC-Java-服务调用实战" class="headerlink" title="gRPC-Java 服务调用实战"></a>gRPC-Java 服务调用实战</h2><blockquote>
<p>按照惯例，我们提供一个简单的订单案例展示gRPC在实际开发中如何使用。</p>
<p>该案例在实际中的意义为：提供一个报价服务，客户端发送下单请求到服务端进行报价，服务端对用户报价单进行汇总计算，并提供查询接口供客户端查询。</p>
<p>主要提供批量下单及查询用户订单能力。</p>
</blockquote>
<p>流程图大致如下：</p>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/demo.png" alt="流程图"></p>
<p>工程结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|==&gt; grpc-demo			   父级工程， 管理依赖相关</div><div class="line">     |==&gt;grpc-demo-sdk     通用jar依赖，生成protobuf对象与gRPC Service，供提供方与调用方使用</div><div class="line">     |==&gt;grpc-server-demo  服务端，提供下单及订单查询服务</div><div class="line">     |==&gt;grpc-client-demo  客户端，负责调用gRPC服务</div></pre></td></tr></table></figure>
<h2 id="grpc-demo父工程"><a href="#grpc-demo父工程" class="headerlink" title="grpc-demo父工程"></a>grpc-demo父工程</h2><blockquote>
<p>父工程相对比较简单，管理了子工程及依赖版本。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>grpc-server-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>grpc-client-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">grpc-version</span>&gt;</span>1.44.1<span class="tag">&lt;/<span class="name">grpc-version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="grpc-demo-sdk"><a href="#grpc-demo-sdk" class="headerlink" title="grpc-demo-sdk"></a>grpc-demo-sdk</h2><blockquote>
<p>grpc-demo-sdk是较为关键的公共依赖，主要基于proto对服务进行定义，生成java代码并打包供服务提供方与消费方使用。</p>
</blockquote>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><blockquote>
<p>sdk的pom文件如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/proto<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>proto<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.19.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.43.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>重点关注一下plugin，我们使用protobuf-maven-plugin作为protobuf的编译工具，有了该插件，我们在执行mvn clean compile命令时便可以实现将proto编译为java代码的目的。</p>
<p>同样，执行mvn clean package命令可以实现将proto编译为java代码并打包为jar包的目的。</p>
<p>可以说是极为方便了。</p>
</blockquote>
<h3 id="编写proto文件，定义服务接口"><a href="#编写proto文件，定义服务接口" class="headerlink" title="编写proto文件，定义服务接口"></a>编写proto文件，定义服务接口</h3><blockquote>
<p>编写OrderService.proto，定义服务接口，主要定义了查询用户订单，批量下单接口，及对应的各种实体和枚举。</p>
</blockquote>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">syntax = <span class="string">"proto3"</span>;</div><div class="line"></div><div class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</div><div class="line"><span class="keyword">option</span> java_package = <span class="string">"com.snowalker.grpc.sdk"</span>;</div><div class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"OrderServiceProto"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 订单服务IDL定义</span></div><div class="line"><span class="class"><span class="keyword">service</span> <span class="title">OrderService</span> </span>&#123;</div><div class="line">  <span class="comment">// 查询用户订单列表</span></div><div class="line">  <span class="function"><span class="keyword">rpc</span> queryUserOrders (QueryUserOrderRequest) <span class="keyword">returns</span> (QueryUserOrderResponse) &#123;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 下单</div><div class="line">  <span class="keyword">rpc</span> placeOrder(PlaceOrderRequest) <span class="keyword">returns</span> (PlaceOrderRequestResponse) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 查询订单请求</div><div class="line">message QueryUserOrderRequest &#123;</div><div class="line">  int32 userId = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 查询订单响应</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">QueryUserOrderResponse</span> </span>&#123;</div><div class="line">  <span class="built_in">int32</span> userId = <span class="number">1</span>;</div><div class="line">  <span class="built_in">string</span> totalPrice = <span class="number">2</span>;</div><div class="line">  <span class="keyword">repeated</span> UserOrder userOrder = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 批量下单请求</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">PlaceOrderRequest</span> </span>&#123;</div><div class="line">  <span class="built_in">int32</span> userId = <span class="number">1</span>;</div><div class="line">  <span class="keyword">repeated</span> PlaceUserOrderParam placeUserOrderParam = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 批量下单响应</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">PlaceOrderRequestResponse</span> </span>&#123;</div><div class="line">  <span class="built_in">int32</span> userId = <span class="number">1</span>;</div><div class="line">  ResultCode resultCode = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 订单查询详情</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserOrder</span> </span>&#123;</div><div class="line">  <span class="built_in">int64</span> orderId = <span class="number">1</span>;</div><div class="line">  <span class="built_in">string</span> orderPrice = <span class="number">2</span>;</div><div class="line">  <span class="built_in">string</span> orderAmount = <span class="number">3</span>;</div><div class="line">  <span class="built_in">int32</span> productId = <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 下单请求详情</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">PlaceUserOrderParam</span> </span>&#123;</div><div class="line">  <span class="built_in">string</span> orderPrice = <span class="number">1</span>;    <span class="comment">// 单价</span></div><div class="line">  <span class="built_in">string</span> orderAmount = <span class="number">2</span>;   <span class="comment">// 数量</span></div><div class="line">  <span class="built_in">int32</span> productId = <span class="number">3</span>;      <span class="comment">// 商品id</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果枚举：成功/失败</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ResultCode</span> </span>&#123;</div><div class="line">  SUCCESS = <span class="number">0</span>;</div><div class="line">  FAILURE = <span class="number">1</span>;</div><div class="line">  UNKNOWN = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如下为protobuf与java、c++对应关系，</p>
<p>更多protobuf的使用，请参考官网文档：<a href="https://developers.google.com/protocol-buffers/docs/javatutorial" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/javatutorial</a></p>
</blockquote>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p><strong>protobuf</strong><strong>属性</strong></p> </td><td style="vertical-align:top;"> <p><strong>C++</strong><strong>属性</strong></p> </td><td style="vertical-align:top;"> <p><strong>java</strong><strong>属性</strong></p> </td><td style="vertical-align:top;"> <p><strong>备注</strong></p> </td></tr><tr><td style="vertical-align:top;"> <p>double</p> </td><td style="vertical-align:top;"> <p>double</p> </td><td style="vertical-align:top;"> <p>double</p> </td><td style="vertical-align:top;"> <p>固定8个字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>float</p> </td><td style="vertical-align:top;"> <p>float</p> </td><td style="vertical-align:top;"> <p>float</p> </td><td style="vertical-align:top;"> <p>固定4个字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>使用变长编码，对于负数编码效率较低，如果经常使用负数，建议使用sint32</p> </td></tr><tr><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>使用变长编码，对于负数编码效率较低，如果经常使用负数，建议使用sint64</p> </td></tr><tr><td style="vertical-align:top;"> <p>uint32</p> </td><td style="vertical-align:top;"> <p>uint32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>使用变长编码</p> </td></tr><tr><td style="vertical-align:top;"> <p>uint64</p> </td><td style="vertical-align:top;"> <p>uint64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>使用变长编码</p> </td></tr><tr><td style="vertical-align:top;"> <p>sint32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>采用zigzag压缩，对负数编码效率比int32高</p> </td></tr><tr><td style="vertical-align:top;"> <p>sint64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>采用zigzag压缩，对负数编码效率比int64高</p> </td></tr><tr><td style="vertical-align:top;"> <p>fixed32</p> </td><td style="vertical-align:top;"> <p>uint32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>总是4字节，如果数据&gt;2^28，编码效率高于unit32</p> </td></tr><tr><td style="vertical-align:top;"> <p>fixed64</p> </td><td style="vertical-align:top;"> <p>uint64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>总是8字节，如果数据&gt;2^56，编码效率高于unit32</p> </td></tr><tr><td style="vertical-align:top;"> <p>sfixed32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>总是4字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>sfixed64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>总是8字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>bool</p> </td><td style="vertical-align:top;"> <p>bool</p> </td><td style="vertical-align:top;"> <p>boolean</p> </td><td style="vertical-align:top;"> <p>&nbsp;</p> </td></tr><tr><td style="vertical-align:top;"> <p>string</p> </td><td style="vertical-align:top;"> <p>string</p> </td><td style="vertical-align:top;"> <p>String</p> </td><td style="vertical-align:top;"> <p>一个字符串必须是utf-8编码或者7-bit的ascii编码的文本</p> </td></tr><tr><td style="vertical-align:top;"> <p>bytes</p> </td><td style="vertical-align:top;"> <p>string</p> </td><td style="vertical-align:top;"> <p>ByteString</p> </td><td style="vertical-align:top;"> <p>可能包含任意顺序的字节数据</p> </td></tr></tbody></table>

<h3 id="编译打包grpc-demo-sdk工程"><a href="#编译打包grpc-demo-sdk工程" class="headerlink" title="编译打包grpc-demo-sdk工程"></a>编译打包grpc-demo-sdk工程</h3><blockquote>
<p>编写完proto文件后，对grpc-demo-sdk工程执行打包编译</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -DskipTests</div></pre></td></tr></table></figure>
<h2 id="编写服务端grpc-server-demo"><a href="#编写服务端grpc-server-demo" class="headerlink" title="编写服务端grpc-server-demo"></a>编写服务端grpc-server-demo</h2><blockquote>
<p>接着编写服务端</p>
</blockquote>
<h3 id="pom-xml-1"><a href="#pom-xml-1" class="headerlink" title="pom.xml"></a>pom.xml</h3><blockquote>
<p>服务端pom内容如下</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-server-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>除了lombok外，其余的依赖由grpc-demo-sdk间接引入。</p>
<h3 id="编写OrderServiceImpl实现核心业务逻辑"><a href="#编写OrderServiceImpl实现核心业务逻辑" class="headerlink" title="编写OrderServiceImpl实现核心业务逻辑"></a>编写OrderServiceImpl实现核心业务逻辑</h3><blockquote>
<p>首先编写OrderServiceImpl，实现核心的下单与查订单业务逻辑。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> snowalker</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span> 2022/3/12 23:47</div><div class="line"> * <span class="doctag">@className</span></div><div class="line"> * <span class="doctag">@desc</span></div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">extends</span> <span class="title">OrderServiceGrpc</span>.<span class="title">OrderServiceImplBase</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderServiceImpl.class.getName());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, LinkedList&lt;UserOrder&gt;&gt; USER_MEMORY_ORDER_BOOK = Maps.newConcurrentMap();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * &lt;pre&gt;</div><div class="line">	 * 查询用户订单列表</div><div class="line">	 * &lt;/pre&gt;</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 * <span class="doctag">@param</span> responseObserver</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryUserOrders</span><span class="params">(QueryUserOrderRequest request, StreamObserver&lt;QueryUserOrderResponse&gt; responseObserver)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> userId = request.getUserId();</div><div class="line">		<span class="comment">// 查询订单</span></div><div class="line">		List&lt;UserOrder&gt; orders = USER_MEMORY_ORDER_BOOK.getOrDefault(userId, Lists.newLinkedList());</div><div class="line"></div><div class="line">		<span class="comment">// 计算总价</span></div><div class="line">		String totalPrice = calculateTotalPrice(orders);</div><div class="line"></div><div class="line">		<span class="comment">// 组装response</span></div><div class="line">		QueryUserOrderResponse queryUserOrderResponse = QueryUserOrderResponse.newBuilder()</div><div class="line">				.setUserId(userId)</div><div class="line">				.addAllUserOrder(orders)</div><div class="line">				.setTotalPrice(totalPrice)</div><div class="line">				.build();</div><div class="line"></div><div class="line">		logger.info(<span class="string">"[Server] queryUserOrders, request:"</span> + request.toString() + <span class="string">"\n"</span> + <span class="string">"response:"</span> + queryUserOrderResponse.toString());</div><div class="line"></div><div class="line">		<span class="comment">// 响应</span></div><div class="line">		responseObserver.onNext(queryUserOrderResponse);</div><div class="line">		responseObserver.onCompleted();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">calculateTotalPrice</span><span class="params">(List&lt;UserOrder&gt; orders)</span> </span>&#123;</div><div class="line">		Optional&lt;BigDecimal&gt; count = orders.stream()</div><div class="line">				.map(order -&gt; <span class="keyword">new</span> BigDecimal(order.getOrderAmount()).multiply(<span class="keyword">new</span> BigDecimal(order.getOrderPrice())))</div><div class="line">				.reduce(BigDecimal::add);</div><div class="line">		<span class="keyword">return</span> count.orElseGet(() -&gt; BigDecimal.ZERO).toPlainString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * &lt;pre&gt;</div><div class="line">	 * 下单</div><div class="line">	 * &lt;/pre&gt;</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 * <span class="doctag">@param</span> responseObserver</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(PlaceOrderRequest request, StreamObserver&lt;PlaceOrderRequestResponse&gt; responseObserver)</span> </span>&#123;</div><div class="line"></div><div class="line">		ThreadLocalRandom orderIdGenerator = ThreadLocalRandom.current();</div><div class="line"></div><div class="line">		PlaceOrderRequestResponse.Builder placeOrderRequestResponse = PlaceOrderRequestResponse.newBuilder();</div><div class="line"></div><div class="line">		<span class="keyword">int</span> userId = request.getUserId();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (request.getPlaceUserOrderParamCount() &lt;= <span class="number">0</span>) &#123;</div><div class="line">			placeOrderRequestResponse.setUserId(userId).setResultCode(ResultCode.FAILURE).build();</div><div class="line">			responseObserver.onNext(placeOrderRequestResponse.build());</div><div class="line">			responseObserver.onCompleted();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 获取用户订单列表</span></div><div class="line">		LinkedList&lt;UserOrder&gt; userOrderList = USER_MEMORY_ORDER_BOOK.getOrDefault(userId, Lists.newLinkedList());</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (userOrderList.size() == <span class="number">0</span>) &#123;</div><div class="line">			USER_MEMORY_ORDER_BOOK.put(userId, Lists.newLinkedList());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> orderId = getOrderId(orderIdGenerator);</div><div class="line"></div><div class="line">		<span class="comment">// 本次订单</span></div><div class="line">		List&lt;UserOrder&gt; userOrders = request.getPlaceUserOrderParamList().stream().map(</div><div class="line">				param -&gt; UserOrder.newBuilder()</div><div class="line">						.setOrderId(orderId)</div><div class="line">						.setOrderAmount(param.getOrderAmount())</div><div class="line">						.setOrderPrice(param.getOrderPrice())</div><div class="line">						.setProductId(param.getProductId())</div><div class="line">						.build()).collect(Collectors.toList());</div><div class="line"></div><div class="line">		<span class="comment">// 追加订单列表</span></div><div class="line">		userOrderList.addAll(userOrders);</div><div class="line"></div><div class="line">		USER_MEMORY_ORDER_BOOK.put(userId, userOrderList);</div><div class="line"></div><div class="line">		<span class="comment">// 响应</span></div><div class="line">		responseObserver.onNext(placeOrderRequestResponse.setUserId(userId).setResultCode(ResultCode.SUCCESS).build());</div><div class="line">		responseObserver.onCompleted();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getOrderId</span><span class="params">(ThreadLocalRandom orderIdGenerator)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> orderId = orderIdGenerator.nextInt();</div><div class="line">		<span class="keyword">if</span> (orderId &lt; <span class="number">0</span>) &#123;</div><div class="line">			orderId *= -<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> orderId;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的代码是完整的代码，读者可以自行复制并直接使用，简单解释下代码：</p>
<ol>
<li>placeOrder为下单服务，核心逻辑就是解析用户下单请求PlaceOrderRequest，将用户订单增量添加到内存订单簿USER_MEMORY_ORDER_BOOK中。<ol>
<li>核心的数据结构为：<em>Map<integer, linkedlist<userorder="">&gt;</integer,></em>，在实战中，通用会持久化订单到redis、MySQL、RocksDB等存储设施中；</li>
</ol>
</li>
<li>queryUserOrders为查询订单服务，核心逻辑为解析用户查询订单请求QueryUserOrderRequest，取出用户id（userId），并在订单簿中匹配当前用户的订单列表。</li>
</ol>
<h3 id="服务端启动类OrderServerBoot"><a href="#服务端启动类OrderServerBoot" class="headerlink" title="服务端启动类OrderServerBoot"></a>服务端启动类OrderServerBoot</h3><blockquote>
<p>有了服务端业务代码之后，重点关注一下服务端启动类的编写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> snowalker</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span> 2022/3/12 23:46</div><div class="line"> * <span class="doctag">@desc</span> 服务端启动类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServerBoot</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderServerBoot.class.getName());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Server server;</div><div class="line"></div><div class="line">	<span class="meta">@SneakyThrows</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> serverPort = <span class="number">10880</span>;</div><div class="line">		server = ServerBuilder.forPort(serverPort)</div><div class="line">				.addService(<span class="keyword">new</span> OrderServiceImpl())</div><div class="line">				.build();</div><div class="line">		server.start();</div><div class="line"></div><div class="line">		logger.info(<span class="string">"OrderServerBoot started, listening on:"</span> + serverPort);</div><div class="line"></div><div class="line">		<span class="comment">// 优雅停机</span></div><div class="line">		addGracefulShowdownHook();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addGracefulShowdownHook</span><span class="params">()</span> </span>&#123;</div><div class="line">		Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">			<span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></div><div class="line">			System.err.println(<span class="string">"*** shutting down gRPC server since JVM is shutting down"</span>);</div><div class="line">			OrderServerBoot.<span class="keyword">this</span>.stop();</div><div class="line">			System.err.println(<span class="string">"*** server shut down"</span>);</div><div class="line">		&#125;));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 服务关闭</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</div><div class="line">			server.shutdown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 由于 grpc 库使用守护线程，因此在主线程上等待终止。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</div><div class="line">			server.awaitTermination();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@SneakyThrows</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		OrderServerBoot boot = <span class="keyword">new</span> OrderServerBoot();</div><div class="line">		<span class="comment">// 启动服务</span></div><div class="line">		boot.startServer();</div><div class="line">		<span class="comment">// 主线程等待终止</span></div><div class="line">		boot.blockUntilShutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释下代码：</p>
<ul>
<li>核心逻辑为main方法，首先定义OrderServerBoot，通过startServer()启动服务，并通过blockUntilShutdown()让主线程等待终止。</li>
<li><strong>startServer()</strong> 方法核心逻辑，启动一个服务端进程并绑定到对应的端口，这里使用10880，并添加优雅停机钩子；</li>
<li><strong>stop()</strong> 逻辑为服务关闭逻辑；</li>
<li><strong>blockUntilShutdown()</strong> ：由于grpc使用守护线程，因此需要在主线程上等待终止。</li>
</ul>
<h2 id="编写客户端grpc-client-demo"><a href="#编写客户端grpc-client-demo" class="headerlink" title="编写客户端grpc-client-demo"></a>编写客户端grpc-client-demo</h2><blockquote>
<p>有了服务端，我们接着看下客户端工程的编写。</p>
</blockquote>
<h3 id="pom-xml-2"><a href="#pom-xml-2" class="headerlink" title="pom.xml"></a>pom.xml</h3><blockquote>
<p>客户端pom如下</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-client-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>与服务端相同，除了lombok外，其余的依赖由grpc-demo-sdk间接引入。</p>
<h3 id="编写客户端服务调用代理OrderClientAgent"><a href="#编写客户端服务调用代理OrderClientAgent" class="headerlink" title="编写客户端服务调用代理OrderClientAgent"></a>编写客户端服务调用代理OrderClientAgent</h3><blockquote>
<p>客户端调用远程服务，需要借助proto生成的stub桩，作为客户端而言，常常会对该stub进行包装，这里我们通过一个OrderClientAgent作为stub的包装类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClientAgent</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderClientAgent.class.getName());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ManagedChannel channel;</div><div class="line"></div><div class="line">	<span class="comment">// 客户端请求服务端的桩</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> OrderServiceGrpc.OrderServiceBlockingStub orderServiceBlockingStub;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderClientAgent</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>(ManagedChannelBuilder.forAddress(host, port)</div><div class="line">				<span class="comment">//使用非安全机制传输,默认情况下，通道是安全的（通过SSLTLS）</span></div><div class="line">				.usePlaintext()</div><div class="line">				.build());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	OrderClientAgent(ManagedChannel channel) &#123;</div><div class="line">		<span class="keyword">this</span>.channel = channel;</div><div class="line">		orderServiceBlockingStub = OrderServiceGrpc.newBlockingStub(channel);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		channel.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 下单</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> PlaceOrderRequestResponse <span class="title">placeOrder</span><span class="params">(PlaceOrderRequest request)</span> </span>&#123;</div><div class="line">		logger.info(<span class="string">"client placeOrder start. request:"</span> + request.toString());</div><div class="line">		PlaceOrderRequestResponse placeOrderRequestResponse;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			placeOrderRequestResponse = orderServiceBlockingStub.placeOrder(request);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> placeOrderRequestResponse;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 订单查询</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> QueryUserOrderResponse <span class="title">queryOrders</span><span class="params">(QueryUserOrderRequest request)</span> </span>&#123;</div><div class="line">		logger.info(<span class="string">"client queryOrders start. request:"</span> + request.toString());</div><div class="line">		QueryUserOrderResponse queryUserOrderResponse;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			queryUserOrderResponse = orderServiceBlockingStub.queryUserOrders(request);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> queryUserOrderResponse;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单解释下代码：</p>
<ul>
<li>通过构造方法传入主机名，服务端端口，构造客户端与服务端间的链接通过ManagedChannel</li>
<li>通过OrderServiceGrpc.newBlockingStub(channel)生成客户端访问的stub实例，这里使用的是阻塞型Stub，即同步等待服务端返回所有结果；</li>
<li>placeOrder方法通过stub访问服务端的下单服务；</li>
<li>queryOrders方法通过stub访问服务端的查询订单服务。</li>
</ul>
<h3 id="编写客户端启动类"><a href="#编写客户端启动类" class="headerlink" title="编写客户端启动类"></a>编写客户端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> snowalker</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span> 2022/3/12 23:56</div><div class="line"> * <span class="doctag">@desc</span> 客户端启动类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClientBoot</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderClientBoot.class.getName());</div><div class="line"></div><div class="line">   <span class="meta">@SneakyThrows</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> port = <span class="number">10880</span>;</div><div class="line">      OrderClientAgent orderClientAgent = <span class="keyword">new</span> OrderClientAgent(<span class="string">"127.0.0.1"</span>, port);</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">int</span> userId = <span class="number">10086</span>;</div><div class="line"></div><div class="line">         <span class="comment">// 下单</span></div><div class="line">         doPlaceOrder(orderClientAgent, userId);</div><div class="line"></div><div class="line">         <span class="comment">// 查订单</span></div><div class="line">         doQueryOrder(orderClientAgent, userId);</div><div class="line"></div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         orderClientAgent.shutdown();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doQueryOrder</span><span class="params">(OrderClientAgent orderClientAgent, <span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">      QueryUserOrderRequest queryUserOrderRequest = QueryUserOrderRequest.newBuilder()</div><div class="line">            .setUserId(userId)</div><div class="line">            .buildPartial();</div><div class="line">      QueryUserOrderResponse queryUserOrderResponse = orderClientAgent.queryOrders(queryUserOrderRequest);</div><div class="line">      logger.info(<span class="string">"client queryOrders end. response:"</span> + queryUserOrderResponse.toString());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPlaceOrder</span><span class="params">(OrderClientAgent orderClientAgent, <span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line"></div><div class="line">      PlaceUserOrderParam orderParam0 = PlaceUserOrderParam.newBuilder()</div><div class="line">            .setProductId(<span class="number">1</span>)</div><div class="line">            .setOrderAmount(<span class="string">"15.00"</span>)</div><div class="line">            .setOrderPrice(<span class="string">"12.50"</span>)</div><div class="line">            .build();</div><div class="line"></div><div class="line">      PlaceUserOrderParam orderParam1 = PlaceUserOrderParam.newBuilder()</div><div class="line">            .setProductId(<span class="number">2</span>)</div><div class="line">            .setOrderAmount(<span class="string">"2.00"</span>)</div><div class="line">            .setOrderPrice(<span class="string">"10.00"</span>)</div><div class="line">            .build();</div><div class="line"></div><div class="line">      PlaceOrderRequest placeOrderRequest = PlaceOrderRequest.newBuilder()</div><div class="line">            .setUserId(userId)</div><div class="line">            .addAllPlaceUserOrderParam(Lists.newArrayList(orderParam0, orderParam1))</div><div class="line">            .buildPartial();</div><div class="line"></div><div class="line">      PlaceOrderRequestResponse placeOrderRequestResponse = orderClientAgent.placeOrder(placeOrderRequest);</div><div class="line">      logger.info(<span class="string">"client placeOrder end. response:"</span> + placeOrderRequestResponse.toString() + <span class="string">",resultCode:"</span> + placeOrderRequestResponse.getResultCode());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点关注main方法：</p>
<ul>
<li>声明服务端端口，这里注意务必与服务端暴露服务端口保持一致；</li>
<li>通过构造方法创建客户端访问服务端的agent实例，即上面提到的OrderClientAgent；</li>
<li>通过实例化的OrderClientAgent执行下单、查询订单操作</li>
<li>调用完成后，关闭OrderClientAgent，关闭客户端与服务端之间的链接。</li>
<li><strong>实际生产中，客户端往往会与服务端保持链接开启，而不会频繁创建、关闭服务。</strong></li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>sdk、客户端、服务端均编写完毕，我们启动服务进行测试。</p>
</blockquote>
<h3 id="首先编译打包sdk"><a href="#首先编译打包sdk" class="headerlink" title="首先编译打包sdk"></a>首先编译打包sdk</h3><p>在grpc-demo-sdk根目录下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -DskipTests</div></pre></td></tr></table></figure>
<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>运行OrderServerBoot的main方法，日志打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 10:50:29 上午 OrderServerBoot startServer</div><div class="line">信息: OrderServerBoot started, listening on:10880</div></pre></td></tr></table></figure>
<h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3><p>运行OrderClientBoot的main方法，启动客户端并发起服务调用</p>
<blockquote>
<p>首先进行下单：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 10:54:57 上午 agent.OrderClientAgent placeOrder</div><div class="line">信息: client placeOrder start. request:userId: 10086</div><div class="line">placeUserOrderParam &#123;</div><div class="line">  orderPrice: &quot;12.50&quot;</div><div class="line">  orderAmount: &quot;15.00&quot;</div><div class="line">  productId: 1</div><div class="line">&#125;</div><div class="line">placeUserOrderParam &#123;</div><div class="line">  orderPrice: &quot;10.00&quot;</div><div class="line">  orderAmount: &quot;2.00&quot;</div><div class="line">  productId: 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">三月 13, 2022 10:54:58 上午 OrderClientBoot doPlaceOrder</div><div class="line">信息: client placeOrder end. response:userId: 10086</div><div class="line">,resultCode:SUCCESS</div></pre></td></tr></table></figure>
<p>下单成功，接着发起查询订单操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 12:20:55 下午 agent.OrderClientAgent queryOrders</div><div class="line">信息: client queryOrders start. request:userId: 10086</div><div class="line"></div><div class="line">三月 13, 2022 12:20:55 下午 OrderClientBoot doQueryOrder</div><div class="line">信息: client queryOrders end. response:userId: 10086</div><div class="line">totalPrice: &quot;207.5000&quot;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;12.50&quot;</div><div class="line">  orderAmount: &quot;15.00&quot;</div><div class="line">  productId: 1</div><div class="line">&#125;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;10.00&quot;</div><div class="line">  orderAmount: &quot;2.00&quot;</div><div class="line">  productId: 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，下单成功，且通过查询订单调用，将用户10086下的两个订单获取到了。</p>
<h3 id="观察服务端日志"><a href="#观察服务端日志" class="headerlink" title="观察服务端日志"></a>观察服务端日志</h3><blockquote>
<p>服务端日志打印如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 12:20:55 下午 service.OrderServiceImpl queryUserOrders</div><div class="line">信息: [Server] queryUserOrders, request:userId: 10086</div><div class="line"></div><div class="line">response:userId: 10086</div><div class="line">totalPrice: &quot;207.5000&quot;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;12.50&quot;</div><div class="line">  orderAmount: &quot;15.00&quot;</div><div class="line">  productId: 1</div><div class="line">&#125;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;10.00&quot;</div><div class="line">  orderAmount: &quot;2.00&quot;</div><div class="line">  productId: 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务端完成下单之后，对用户订单总价值进行计算</p>
<blockquote>
<p>totalPrice = 12.5<em>15 + 10 </em>2 = 207.5</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对gRPC进行了如下介绍：</p>
<ul>
<li>gRPC特性介绍</li>
<li>gRPC-java线程模型</li>
<li>gRPC客户端请求服务端方式</li>
<li>gRPC与REST性能比对</li>
</ul>
<p>并通过一个完整的demo展示了基于gRPC实现的报价服务，全景展示了gRPC在实战中如何进行使用。</p>
<p>到此我们对gRPC应当有了大致的了解和认知，后续我们将继续从入门到放弃的学习之路。</p>
<p>预告：接下来将对gRPC的底层机制进行讲解，并会为我们的报价服务添加服务发现能力，整合Nacos提供服务注册与发现，降低客户端与服务端之间的耦合，敬请期待。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微服务如火如荼的当下，各种服务框架层出不穷。Dubbo、SpringCloud在国内Java后端微服务领域目前占据大部分份额。&lt;/p&gt;
&lt;p&gt;但是随着云原生愈发普及，具备跨语言、高性能特性的RPC通信框架横空出世，其中gRPC与Thrift是其中的佼佼者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文我们将视角集中在gRPC这RPC框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gRPC 是Google开源的高性能、通用的RPC框架。客户端与服务端约定接口调用， 可以在各种环境中运行，具有跨语言特性， 适合构建分布式、微服务应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人认为，gRPC最为杀手锏的特性就是“跨语言”，其次才是高性能。&lt;/p&gt;
&lt;p&gt;它的跨语言特性体现在，通过定义IDL（接口定义语言），隔离了不同编程语言之间的差异，对IDL进行编译后，生成对应编程语言的nativeCode，让开发者能够集中注意在实现业务需求上，而不需要花费额外的精力在语言层面上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网的一张图能够很好的体现这个特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/12/学点儿gRPC-从入门到放弃/grpc_server.png&quot; alt=&quot;gRPC多语言&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://wuwenliang.net/categories/gRPC/"/>
    
    
      <category term="gRPC" scheme="http://wuwenliang.net/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>学点儿金融知识-撮合交易那些事儿</title>
    <link href="http://wuwenliang.net/2022/03/10/%E5%AD%A6%E7%82%B9%E5%84%BF%E9%87%91%E8%9E%8D%E7%9F%A5%E8%AF%86-%E6%92%AE%E5%90%88%E4%BA%A4%E6%98%93%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://wuwenliang.net/2022/03/10/学点儿金融知识-撮合交易那些事儿/</id>
    <published>2022-03-10T14:07:30.000Z</published>
    <updated>2022-03-10T14:38:29.178Z</updated>
    
    <content type="html"><![CDATA[<p>今天的文章，继续学点儿金融知识。重点来了解下金融领域的撮合交易机制。</p>
<blockquote>
<p>本文主要介绍撮合交易的概念，委托单相关的知识，以及撮合交易集合竞价与连续竞价相关的要点。</p>
<p>最后讲解撤单相关的知识及止盈止损相关的知识点。</p>
</blockquote>
<h3 id="什么是撮合交易？"><a href="#什么是撮合交易？" class="headerlink" title="什么是撮合交易？"></a>什么是撮合交易？</h3><blockquote>
<p>撮合交易指的是 <strong>买方</strong> 在交易所下委托买单买入标的，如一手股票，<strong>卖方</strong> 在交易所下委托卖单卖出标的，如一手股票。</p>
<p>交易所按照价格优先、时间优先原则确定双方成交价格，对符合交易规则的订单进行撮合成交，按交易定单指定的标的物进行交割的交易方式。</p>
</blockquote>
<h3 id="撮合是如何成交的？"><a href="#撮合是如何成交的？" class="headerlink" title="撮合是如何成交的？"></a>撮合是如何成交的？</h3><p>一般来说，买入和卖出价格是确定的，这种订单叫做限价单，即下单时就指定确定的价格。</p>
<p>买入限价，指的是至多（小于等于）通过该价格成交，买入一定数量的股票。如限价$10, 则可以买入&lt;=$10的股票。</p>
<p>卖出限价，指的至少（大于等于）要通过该价格成交，卖出一定数量的股票，如限价$10，则对手方至少要付出$10买入股票。</p>
<a id="more"></a>
<p><strong>针对卖出限价打个比方：</strong></p>
<blockquote>
<p>我们去市场买菜，老板吆喝，一斤白菜2块5。</p>
<p>我：2块3卖不卖？</p>
<p>老板：不卖。</p>
<p>我：行，那来两斤</p>
<p>于是我花了2.5 * 2买入了2斤白菜。老板卖出限价就是2.5元。</p>
</blockquote>
<p>针对买入限价打个比方：</p>
<blockquote>
<p>我们去市场采购蔬菜，老板吆喝，蔬菜打折卖了！</p>
<p>我：2块3卖不卖？</p>
<p>老板：2块4就卖。</p>
<p>我：就2块3，多了不买。</p>
<p>天色已晚，老板想了想，一跺脚，好，卖了！ </p>
<p>于是我花了2.3买入了白菜。我的买入限价就是2.3元。</p>
</blockquote>
<h4 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h4><p>股票市场中可以有多个买价和卖价， 其中买方价格由高到低排列， 而卖方价格由低到高排列， 这就是我们通常看到多个挡位行情， 也就是盘口信息，或者叫作深度。</p>
<p>一般盘口会显示五个挡位，对于更高级的行情源， 可以显示十个或更多挡位。</p>
<p>当一个挡位的数量不足以交易时， 由下一个挡位进行匹配成交， 就形成了深度成交。</p>
<p>通俗的说法，通过匹配深度成交，叫做吃了深度，或者专业的说法叫做 ： <strong>吃单（Taker）</strong>。</p>
<p>而深度中的单子，则被吃掉了，专业的说法叫做：<strong>挂单（Maker）</strong>。</p>
<h3 id="什么是股票委托？"><a href="#什么是股票委托？" class="headerlink" title="什么是股票委托？"></a>什么是股票委托？</h3><blockquote>
<p>股票委托是指依据买卖双方各自提出的条件（股票代码， 价格和成交量等），代其买卖股票的交易活动。</p>
<p>代理买卖的经纪人充当股票买卖双方的中介者， 比如券商。 </p>
</blockquote>
<p>一般来说，股票委托形式有两种：市价委托和限价委托。</p>
<h4 id="市价委托和限价委托"><a href="#市价委托和限价委托" class="headerlink" title="市价委托和限价委托"></a>市价委托和限价委托</h4><ul>
<li><p>市价委托：就是按市场价格买进或卖出股票。</p>
</li>
<li><p>限价委托：就是按委托人提出的价格条件买进或卖出股票。</p>
</li>
</ul>
<p>对于限价委托而言，输入的委托价格不得高于该股票当日涨停价或低于当日的跌停价。</p>
<p><img src="/2022/03/10/学点儿金融知识-撮合交易那些事儿/image.png" alt=""></p>
<p>假设买方选择限价委托方式进行申报， 委托价格为25.06， 申报手数为10手， 那么该笔申报的成交情况为暂时无成交， 若投资者不撤单， 则剩余委托仍在撮合成交系统内， 等待其他投资者主动卖出， 撮合成交， 成交价为25.06； 实际成交数量，根据交易系统撮合的数量确定。</p>
<p>如果当日交易结束仍有部分委托未成交, 则系统自动撤单, 下一交易日需重新申报委托。</p>
<blockquote>
<p>在股票市场规定中， 交易分为两类， 集合竞价与连续竞价交易。 </p>
</blockquote>
<p>下面， 我们以实例讲解推演。</p>
<h3 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h3><p>沪深开放式集合竞价时间为9点15分至9点25分，14点57分至15点00分， 除此之外的交易时间为连续竞价交易时段。</p>
<blockquote>
<p>假设某只股票在开盘前分别有5笔买入和6笔卖出委托， 根据价格优先原则， 按买入价格由高至低和卖出价格由低至高的顺序将其分别排列如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3.80</td>
<td>2</td>
<td>1</td>
<td>3.52</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>按不高于申买价和不低于申卖价的原则，首先可成交第一笔，即3．80元买入委托和3．52元的卖出委托， 这对委托成交后其它的委托排序如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>3.52</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>序号1的买入委托2手全部成交， 序号1的卖出委托还剩余3手。</p>
<p>第二笔成交情况：序号2的买入委托价格为3．76元，数量为6手。 在卖出委托中，序号1—3的委托卖出价格符合条件, 且数量正好为6手，进行撮合成交， 其成交价格在3．60元—3．76元的范围内，成交数量为6手。 第二笔成交后剩下的委托情况为：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第三笔成交情况：序号3的买入委托其价格要求不超过3．65元，而卖出委托序号4的委托价格符合要求，这样序号3的买入委托与序号4的卖出委托就正好配对成交，其价格为3．65元，因卖出委托数量大于买入委托，故序号4的卖出委托仅只成交了4手。第三笔成交后的委托情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td>3.65</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>完成以上三笔委托后，因最高买入价为3．60元，而最低卖出价为3．65，买入价与卖出价之间再没有相交部分，所以这一次的集合竟价就已完成，最后一笔的成交价就为集合竟价的平均价格。剩下的其他委托将自动进入开盘后的 <strong>连续竟价</strong> 。</p>
<h3 id="连续竞价"><a href="#连续竞价" class="headerlink" title="连续竞价"></a>连续竞价</h3><blockquote>
<p>连续竟价的成交方式与集合竟价有很大的区别，它是在买入的最高价与卖出的最低价的委托中一对一对地成交， 其成交价为申买与申卖的平均价。</p>
</blockquote>
<p>仍以某只股票为例， 委托报价的排列情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3.80</td>
<td>2</td>
<td>1</td>
<td>3.52</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>委托买入的最高价为序号1的3．80元，卖出最低价为序号1的3．52元，这一对优先成交，其价格为两者的平均价, 与成交数量无关, 计算公式为: (3．80＋3．52）/2，故产生的价格为3．66元。交易所发布的即时行情为：成交价3．66元，数量2手。剩余的委托报价排序情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>3.52</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第二笔，序号1的卖出价为3．52元，序号2的买入价为3．76元，这一对可以成交，成交价格为两者的平均值，价格为3．64元，数量为3手。该次成交后的委托情况为： </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3.76</td>
<td><strong>3</strong></td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第三笔，序号2的卖出委托与序号2的买入委托可以成交，成交均价为3．67元，成交量1手。成交后剩下的委托情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3.76</td>
<td><strong>2</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第四笔，序号2的买入委托3.76与序号3的卖出委托3.60成交2手， 序号2的买入委托与序号3的卖出委托消失；</p>
<p>第五笔， 序号4的卖出委托3.65与序号3的买入委托3.65撮合成交4手， 接下来没有匹配的价格无法进行撮合交易。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>以上就是撮合交易机制的处理流程。</p>
<h3 id="撤单是个啥流程？"><a href="#撤单是个啥流程？" class="headerlink" title="撤单是个啥流程？"></a>撤单是个啥流程？</h3><p>简单的说，有挂单，就有撤单。</p>
<blockquote>
<p>撤单就是投资者通过股票委托进行买卖操作，按照投资者的要求撤回操作的过程。</p>
</blockquote>
<p>如果投资者在当天要动用被锁定的资金(在委托买入时，想改变买入价格或不想买入)或股票(在委托卖出时，想改变卖出价格或不想卖出)，就必须通过撤单撤消该委托。</p>
<blockquote>
<p>简单的说，如果投资者委托下单后，订单没有成交，进入了深度，投资者此时持有该挂单。</p>
<p>挂单本身会冻结响应的资金，如果投资者觉得价格不合适或者改变主意不想买卖了，就可以通过撤单来讲该委托挂单取消。</p>
</blockquote>
<p>国内A股撤单有效时间规定：</p>
<ul>
<li><p>9：15-9：20，可撤单;9：15前的撤单请求也从9：15开始受理。</p>
</li>
<li><p>9：20-9：25，不接受撤单申报。</p>
</li>
<li><p>9：30-11：30，可撤单。</p>
</li>
<li><p>11：30-13：00，可申报撤单，但证交所尚不受理，处于“已报待撤”状态，13：00后开始受理，按时间顺序先受理买卖委托，如已成交，再受理撤单请求时，则不会撤单成功。</p>
</li>
<li><p>13：00-15：00可撤单，两市最后3分钟14：57-15：00为集合竞价，不能撤单。</p>
</li>
<li><p>15：00 收盘以后，没有成交的委托自动作废，无需撤单。但必须要等待清算结束后，资金才会解冻回到账户上来。</p>
</li>
</ul>
<h3 id="止盈止损又是啥？"><a href="#止盈止损又是啥？" class="headerlink" title="止盈止损又是啥？"></a>止盈止损又是啥？</h3><blockquote>
<p>事实上，止盈止损是三件事情的统称，止盈，止损，止盈And止损。</p>
</blockquote>
<h4 id="啥是止盈？"><a href="#啥是止盈？" class="headerlink" title="啥是止盈？"></a>啥是止盈？</h4><blockquote>
<p>止盈（Stop-Profit/Stop Profit），也称停利、止赚 。 当股票到达一定的价格，而且出现利润，打算离场平仓了，在目标价位挂单卖出就是止盈。</p>
</blockquote>
<p>止盈的设置方式主要有两种:</p>
<p>第一，设比例。假设10元买的股票，而后它上涨到12元，可以设定股票在回调10%位置时出仓。即，假如股票从12元回调到10.8元，就出来。如果没有回调到位，就一直拿着，然后，稳步修正止盈点(一定要严格遵守)，使自身利润接近最大化。</p>
<p>第二，设价位。比如，10元买的股票，而后它上涨到12元，设定如果跌破11元就出仓，如果它没有跌到此价位而是继续上涨到了13元，那么，就设定如果跌破12元就出仓……这样逐级抬高标准，锁住自己的利润，也不至于因提前出仓后悔。</p>
<h4 id="啥是止损？"><a href="#啥是止损？" class="headerlink" title="啥是止损？"></a>啥是止损？</h4><blockquote>
<p>止损俗称“割肉”，是指当某一投资出现的亏损达到预定数额时，及时斩仓出局，以避免形成更大的亏损。目的就在于投资失误时把损失限定在较小的范围内。</p>
</blockquote>
<p>止损方法与止盈类似， 主要存在两种， 根据比例和价位， 采用定额方式进行止损。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>撮合交易是金融场景最为核心的逻辑，是学习了解金融市场运作极为关键的因素；</li>
<li>撮合交易核心在于集合竞价与连续竞价的交易机制；</li>
<li>委托下单、 撤单、止盈止损等概念是撮合交易中不可或缺的环节，需要我们了解并掌握其概念及场景。</li>
</ul>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的文章，继续学点儿金融知识。重点来了解下金融领域的撮合交易机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要介绍撮合交易的概念，委托单相关的知识，以及撮合交易集合竞价与连续竞价相关的要点。&lt;/p&gt;
&lt;p&gt;最后讲解撤单相关的知识及止盈止损相关的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是撮合交易？&quot;&gt;&lt;a href=&quot;#什么是撮合交易？&quot; class=&quot;headerlink&quot; title=&quot;什么是撮合交易？&quot;&gt;&lt;/a&gt;什么是撮合交易？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;撮合交易指的是 &lt;strong&gt;买方&lt;/strong&gt; 在交易所下委托买单买入标的，如一手股票，&lt;strong&gt;卖方&lt;/strong&gt; 在交易所下委托卖单卖出标的，如一手股票。&lt;/p&gt;
&lt;p&gt;交易所按照价格优先、时间优先原则确定双方成交价格，对符合交易规则的订单进行撮合成交，按交易定单指定的标的物进行交割的交易方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;撮合是如何成交的？&quot;&gt;&lt;a href=&quot;#撮合是如何成交的？&quot; class=&quot;headerlink&quot; title=&quot;撮合是如何成交的？&quot;&gt;&lt;/a&gt;撮合是如何成交的？&lt;/h3&gt;&lt;p&gt;一般来说，买入和卖出价格是确定的，这种订单叫做限价单，即下单时就指定确定的价格。&lt;/p&gt;
&lt;p&gt;买入限价，指的是至多（小于等于）通过该价格成交，买入一定数量的股票。如限价$10, 则可以买入&amp;lt;=$10的股票。&lt;/p&gt;
&lt;p&gt;卖出限价，指的至少（大于等于）要通过该价格成交，卖出一定数量的股票，如限价$10，则对手方至少要付出$10买入股票。&lt;/p&gt;
    
    </summary>
    
      <category term="金融系统" scheme="http://wuwenliang.net/categories/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="金融系统" scheme="http://wuwenliang.net/tags/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor学习资料汇总</title>
    <link href="http://wuwenliang.net/2022/03/03/Disruptor%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://wuwenliang.net/2022/03/03/Disruptor学习资料汇总/</id>
    <published>2022-03-02T17:07:47.000Z</published>
    <updated>2022-03-02T17:13:14.569Z</updated>
    
    <content type="html"><![CDATA[<p>到此，Disruptor高性能之道系列就先告一段落，关于Disruptor的实战使用将会在后续的撮合实战案例中讲解。</p>
<blockquote>
<p>本文推荐一些学习Disruptor的资料，感兴趣的读者可以根据这些资料进一步学习。</p>
</blockquote>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p>官网是第一手资料，<strong>建议通读</strong></p>
<blockquote>
<p><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html#_using_the_disruptor" target="_blank" rel="external">https://lmax-exchange.github.io/disruptor/user-guide/index.html#_using_the_disruptor</a></p>
</blockquote>
<h2 id="并发编程网：disruptor译文"><a href="#并发编程网：disruptor译文" class="headerlink" title="并发编程网：disruptor译文"></a>并发编程网：disruptor译文</h2><p>虽然有些过时，但是思想是值得参考的。<strong>建议通读</strong></p>
<blockquote>
<p><a href="http://ifeve.com/disruptor/" target="_blank" rel="external">http://ifeve.com/disruptor/</a></p>
</blockquote>
<p><img src="/2022/03/03/Disruptor学习资料汇总/ifeve.PNG" alt="ifeve.PNG"></p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到此，Disruptor高性能之道系列就先告一段落，关于Disruptor的实战使用将会在后续的撮合实战案例中讲解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文推荐一些学习Disruptor的资料，感兴趣的读者可以根据这些资料进一步学习。&lt;/p&gt;
&lt;/blockquote
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor实战-多生产者多消费者</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E5%AE%9E%E6%88%98-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor实战-多生产者多消费者/</id>
    <published>2022-02-28T10:15:59.000Z</published>
    <updated>2022-02-28T10:15:59.190Z</updated>
    
    <content type="html"><![CDATA[<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;hr&gt;&lt;br&gt;版权声明：&lt;br&gt;&lt;br&gt;原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。&lt;br&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Disruptor实战-单生产者多消费者</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E5%AE%9E%E6%88%98-%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor实战-单生产者多消费者/</id>
    <published>2022-02-28T10:15:52.000Z</published>
    <updated>2022-02-28T10:15:52.230Z</updated>
    
    <content type="html"><![CDATA[<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;hr&gt;&lt;br&gt;版权声明：&lt;br&gt;&lt;br&gt;原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。&lt;br&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Disruptor实战-单生产者单消费者</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E5%AE%9E%E6%88%98-%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor实战-单生产者单消费者/</id>
    <published>2022-02-28T10:15:45.000Z</published>
    <updated>2022-02-28T10:15:45.726Z</updated>
    
    <content type="html"><![CDATA[<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;hr&gt;&lt;br&gt;版权声明：&lt;br&gt;&lt;br&gt;原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。&lt;br&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-等待策略</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-等待策略/</id>
    <published>2022-02-28T10:10:34.000Z</published>
    <updated>2022-03-02T17:01:40.166Z</updated>
    
    <content type="html"><![CDATA[<p>我们接着介绍Disruptor高性能实现之道–等待策略。</p>
<blockquote>
<p>等待策略waitStrategy是一种决定一个消费者如何等待生产者将event对象放入Disruptor的方式/策略。</p>
<p>等待策略waitStrategy是一个接口，它的所有实现都是针对消费者生效的。</p>
</blockquote>
<a id="more"></a>
<h2 id="Disruptor中主要的等待策略有哪些？"><a href="#Disruptor中主要的等待策略有哪些？" class="headerlink" title="Disruptor中主要的等待策略有哪些？"></a>Disruptor中主要的等待策略有哪些？</h2><p>Disruptor中，等待策略waitStrategy有四个实现，分别是：</p>
<ul>
<li><p>BlockingWaitStrategy：使用锁和条件变量实现的阻塞策略。如果不是将吞吐量和低延迟放在首位，则可以使用该策略。一般来说，这个策略的表现是中规中矩比较稳定的，它不会使CPU的负载飙高。</p>
<blockquote>
<p>虽然客观上说， BlockingWaitStrategy是最低效的策略，但其也是CPU使用率最低和最稳定的策略。</p>
<p>在BlockingWaitStrategy内部维护了一个重入锁ReentrantLock和Condition；</p>
</blockquote>
</li>
<li><p>SleepingWaitStrategy：性能表现和com.lmax.disruptor.BlockingWaitStrategy差不多，对CPU的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景；</p>
<blockquote>
<p>SleepingWaitStrategy是一种无锁的方式，它的CPU使用率也比较低。具体的实现原理为：循环等待并且在循环中间调用LockSupport.parkNanos(1)来睡眠，（在Linux系统上面睡眠时间60µs）.</p>
<p>SleepingWaitStrategy优点在于生产线程只需要计数，而不执行任何指令。并且没有条件变量的消耗。但是，事件对象从生产者到消费者传递的延迟变大了。SleepingWaitStrategy最好用在不需要低延迟，而且事件发布对于生产者的影响比较小的情况下。比如异步日志功能。</p>
</blockquote>
</li>
<li><p>YieldingWaitStrategy：性能最好，适合用于低延迟的系统，在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中推荐使用此策略，例如CPU开启超线程的特性；</p>
<blockquote>
<p>虽然YieldingWaitStrategy性能最好，但是它的实现机制是让出cpu使用权，保证cpu不会空闲，从而使得cpu始终处于工作态，因此该策略会使用100%的CPU，因此建议慎用。</p>
</blockquote>
</li>
<li>BusySpinWaitStrategy：该策略原则上来说应当是性能最高的，它将线程绑定在特定的CPU内核，但是同时该策略也是部署过程中最为苛刻的策略。<blockquote>
<p>BusySpinWaitStrategy发挥高性能的前提是事件处理线程比物理内核数目还要小的场景。例如：在禁用超线程技术的时候。</p>
</blockquote>
</li>
</ul>
<h2 id="BlockingWaitStrategy"><a href="#BlockingWaitStrategy" class="headerlink" title="BlockingWaitStrategy"></a>BlockingWaitStrategy</h2><blockquote>
<p>BlockingWaitStrategy是Disruptor中唯一使用到锁的地方。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public final class BlockingWaitStrategy implements WaitStrategy</div><div class="line">&#123;</div><div class="line"></div><div class="line">    // 可重入锁</div><div class="line">    private final Lock lock = new ReentrantLock();</div><div class="line"></div><div class="line">    // 条件变量</div><div class="line">    private final Condition processorNotifyCondition = lock.newCondition();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSequence, SequenceBarrier barrier)</div><div class="line">        throws AlertException, InterruptedException</div><div class="line">    &#123;</div><div class="line">        long availableSequence;</div><div class="line">        if (cursorSequence.get() &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            lock.lock();</div><div class="line">            try</div><div class="line">            &#123;</div><div class="line">                while (cursorSequence.get() &lt; sequence)</div><div class="line">                &#123;</div><div class="line">                    barrier.checkAlert();</div><div class="line">                    processorNotifyCondition.await();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            finally</div><div class="line">            &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 如果生产者新发布了事件，但是依赖的其他消费者还没处理完，则等待所依赖的消费者先处理</div><div class="line">        while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            barrier.checkAlert();</div><div class="line">            ThreadHints.onSpinWait();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return availableSequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void signalAllWhenBlocking()</div><div class="line">    &#123;</div><div class="line">        lock.lock();</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            processorNotifyCondition.signalAll();</div><div class="line">        &#125;</div><div class="line">        finally</div><div class="line">        &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>BlockingWaitStrategy的类长度不到100行，使用了Lock+Condition 实现了线程等待和唤醒操作。从而实现了生产者与消费者之间的同步。</p>
<p>消费者通过waitFor等待RingBuffer指定位置是否有可用数据，当存在可用数据，则消费者被唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @see Sequencer#publish(long)</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void publish(long sequence)</div><div class="line">&#123;</div><div class="line">    cursor.set(sequence);</div><div class="line">    waitStrategy.signalAllWhenBlocking();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果生产者新发布了事件，但是依赖的其他消费者还没处理完，则等待所依赖的消费者先处理</li>
<li>生产者新发布时间，会唤醒等待中的消费者。</li>
</ul>
<h2 id="SleepingWaitStrategy"><a href="#SleepingWaitStrategy" class="headerlink" title="SleepingWaitStrategy"></a>SleepingWaitStrategy</h2><p>SleepingWaitStrategy没有用到锁，这表明它无需调用signalAllWhenBlocking方法做唤醒处理。</p>
<blockquote>
<p>SleepingWaitStrategy核心是通过<strong>Thread.yield</strong> + <strong>LockSupport.parkNanos</strong>，实现生产者和消费者之间的同步。</p>
</blockquote>
<p>也就是说省去了生产线程的通知操作，官方源码注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* This strategy is a good compromise between performance and CPU resource.</div><div class="line">* Latency spikes can occur after quiet periods.  It will also reduce the impact</div><div class="line">* on the producing thread as it will not need signal any conditional variables</div><div class="line">* to wake up the event handling thread.</div></pre></td></tr></table></figure>
<p>大意是说，SleepingWaitStrategy策略在性能和CPU资源消耗之间取得了平衡，接下来去看看关键代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final int DEFAULT_RETRIES = 200;</div><div class="line">private static final long DEFAULT_SLEEP = 100;</div><div class="line"></div><div class="line">private final int retries;</div><div class="line">private final long sleepTimeNs;</div><div class="line"></div><div class="line">@Override</div><div class="line">public long waitFor(</div><div class="line">    final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)</div><div class="line">    throws AlertException</div><div class="line">&#123;</div><div class="line">    long availableSequence;</div><div class="line">    int counter = retries;    // 默认值为DEFAULT_RETRIES = 200;</div><div class="line"></div><div class="line">    while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">    &#123;</div><div class="line">        counter = applyWaitMethod(barrier, counter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return availableSequence;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void signalAllWhenBlocking()</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>waitFor 方法核心是while循环，我们可以看到，while循环没有任何的break操作，他就是个死循环。</p>
<p>counter默认值为200，自旋重试一定次数，如果在重试过程中，出现了可用sequence，也就是生产者往RingBuffer中生产了数据，则直接返回可用的序列号。</p>
<p>只要消费者没有等到可用的数据，就会一直循环，执行applyWaitMethod。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private int applyWaitMethod(final SequenceBarrier barrier, int counter)</div><div class="line">    throws AlertException</div><div class="line">&#123;</div><div class="line">    barrier.checkAlert();</div><div class="line"></div><div class="line">    if (counter &gt; 100)</div><div class="line">    &#123;</div><div class="line">        --counter;</div><div class="line">    &#125;</div><div class="line">    else if (counter &gt; 0)</div><div class="line">    &#123;</div><div class="line">        --counter;</div><div class="line">        Thread.yield();</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        LockSupport.parkNanos(sleepTimeNs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的核心就是counter计数器，完全是无锁的。</p>
<p>当计数器高于100时就执行减一的操作（最快响应），当计数器在100到0之间时每次都交出CPU执行时间（最省资源），其他时候就睡眠固定时间：</p>
<p>如果重试指定次数以后，还是没有可用序列号，则继续自旋重试：</p>
<ul>
<li>0-100：每重试一次，便调用Thread.yield方法，让渡CPU的使用权，让其它线程可以使用CPU。当该线程再次获取CPU使用权时，继续重试，如果还没有可用的序列号，则继续放弃CPU使用权等待。此循环最多100次。</li>
<li>加入在等待过程中还是没有可用的序列号，则调用LockSupport.parkNanos方法阻塞消费线程，阻塞时长通过SleepingWaitStrategy构造方法设置，一直阻塞到出现了可用的sequence（一直阻塞到生产者生产了数据）。</li>
<li>当LockSupport.parkNanos方法由于超时返回后，还没有可用的sequence序列号，则该线程获取CPU使用权以后，可能继续调用LockSupport.parkNanos方法阻塞线程。</li>
</ul>
<p>跟其它几种等待策略相比，它既没有直接使用锁，也没有直接自旋。属于一种在性能和CPU资源之间折中的方案。</p>
<h2 id="BusySpinWaitStrategy"><a href="#BusySpinWaitStrategy" class="headerlink" title="BusySpinWaitStrategy"></a>BusySpinWaitStrategy</h2><blockquote>
<p>BusySpinWaitStrategy的实现代码行数只有几十行，从它的注释可以看出: 该策略将线程绑定到了特定的CPU内核。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Busy Spin strategy that uses a busy spin loop for &#123;@link EventProcessor&#125;s waiting on a barrier.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This strategy will use CPU resource to avoid syscalls which can introduce latency jitter.  It is best</div><div class="line"> * used when threads can be bound to specific CPU cores.</div><div class="line"> */</div><div class="line">public final class BusySpinWaitStrategy implements WaitStrategy</div><div class="line">&#123;</div><div class="line">    @Override</div><div class="line">    public long waitFor(</div><div class="line">        final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)</div><div class="line">        throws AlertException, InterruptedException</div><div class="line">    &#123;</div><div class="line">        long availableSequence;</div><div class="line"></div><div class="line">        while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            barrier.checkAlert();</div><div class="line">            ThreadHints.onSpinWait();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return availableSequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void signalAllWhenBlocking()</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当没有可用sequence时，消费者会一直执行while循环，具体的逻辑为 <strong>ThreadHints.onSpinWait();</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final MethodHandle ON_SPIN_WAIT_METHOD_HANDLE;</div><div class="line"></div><div class="line">public static void onSpinWait()</div><div class="line">&#123;</div><div class="line">    // Call java.lang.Thread.onSpinWait() on Java SE versions that support it. Do nothing otherwise.</div><div class="line">    // This should optimize away to either nothing or to an inlining of java.lang.Thread.onSpinWait()</div><div class="line">    if (null != ON_SPIN_WAIT_METHOD_HANDLE)</div><div class="line">    &#123;</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            ON_SPIN_WAIT_METHOD_HANDLE.invokeExact();</div><div class="line">        &#125;</div><div class="line">        catch (final Throwable ignore)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当ON_SPIN_WAIT_METHOD_HANDLE 不为空，则执行 ON_SPIN_WAIT_METHOD_HANDLE.invokeExact(); 底层是一个native方法。</p>
<p>那么我们可以猜想，如果ON_SPIN_WAIT_METHOD_HANDLE为空，那么这个外层的while循环就是一个纯粹的自旋操作，也就是说这个操作非常消耗CPU。</p>
<p>ON_SPIN_WAIT_METHOD_HANDLE为空是一个比较严重的场景，它的初始化逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># com.lmax.disruptor.util.ThreadHints</div><div class="line">static</div><div class="line">&#123;</div><div class="line">    final MethodHandles.Lookup lookup = MethodHandles.lookup();</div><div class="line"></div><div class="line">    MethodHandle methodHandle = null;</div><div class="line">    try</div><div class="line">    &#123;</div><div class="line">        methodHandle = lookup.findStatic(Thread.class, &quot;onSpinWait&quot;, methodType(void.class));</div><div class="line">    &#125;</div><div class="line">    catch (final Exception ignore)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ON_SPIN_WAIT_METHOD_HANDLE = methodHandle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里的methodHandle其实就是Thread类中的onSpinWait方法，</p>
<p>如果Thread类没有onSpinWait方法那么使用BusySpinWaitStrategy作为等待策略就在RingBuffer中没有数据时，消费线程就会执行自旋空转，这个操作很耗费CPU。</p>
<blockquote>
<p>那么问题就变成了，Thread类中是否存在<strong>onSpinWait</strong> 方法的问题了。</p>
</blockquote>
<p>有趣的是，onSpinWait方法在JDK1.9之后才添加到了Thread类中，也就是说，对于JDK1.8（包括1.8）之前的用户而言，使用BusySpinWaitStrategy就意味着，找不到Thread类的onSpinWait方法，而最终导致消费者阻塞在waitFor方法上，执行无意义的自旋操作，把CPU负载打满（就是一个while(true)死循环）。</p>
<blockquote>
<p>在jdk1.9及以上版本中，Thread.onSpinWait是有意义的。它会通知CPU当前线程处于循环查询的状态，CPU得知该状态后就会调度更多CPU资源给其他线程，从而缓解死循环对当前cpu核的压力。</p>
</blockquote>
<p>回过头来，BusySpinWaitStrategy的注释告诉我们：如果使用该策略，尽量绑定线程到固定的CPU核心。但是同样的，该策略与YieldingWaitStrategy策略相比，会出现当没有可用序列号时长期占用CPU而让出CPU使用权（死循环），导致其它线程无法获取CPU使用权。</p>
<h3 id="如何实现利用线程亲和性绑定线程到具体的CPU？"><a href="#如何实现利用线程亲和性绑定线程到具体的CPU？" class="headerlink" title="如何实现利用线程亲和性绑定线程到具体的CPU？"></a>如何实现利用线程亲和性绑定线程到具体的CPU？</h3><p>那么这个操作又该如何实现呢？</p>
<blockquote>
<p>通过使用net.openhft.affinity包，就可以实现线程亲和性，它会强制你的应用线程运行在特定的一个或多个cpu上。</p>
</blockquote>
<p>maven依赖为：</p>
<dependency><br>    <groupid>net.openhft</groupid><br>    <artifactid>affinity</artifactid><br>    <version>3.0.6</version><br></dependency>

<p>在初始化Disruptor实例时，ThreadFactory参数传入affinity线程亲和工厂。</p>
<blockquote>
<p>以Spring项目中实例化Disruptor为例：</p>
</blockquote>
<p><img src="/2022/02/28/Disruptor高性能之道-等待策略/disruptor-init.png" alt="disruptor-init.png"></p>
<hr>
<p><img src="/2022/02/28/Disruptor高性能之道-等待策略/openhft-affinity.png" alt="openhft-affinity.png"></p>
<h2 id="YieldingWaitStrategy"><a href="#YieldingWaitStrategy" class="headerlink" title="YieldingWaitStrategy"></a>YieldingWaitStrategy</h2><blockquote>
<p>YieldingWaitStrategy相比于SleepingWaitStrategy，实现机制就很激进，它完全基于Thread.yield出让cpu使用权，让CPU利用率保持在100%。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public final class YieldingWaitStrategy implements WaitStrategy</div><div class="line">&#123;</div><div class="line">    private static final int SPIN_TRIES = 100;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public long waitFor(</div><div class="line">        final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)</div><div class="line">        throws AlertException, InterruptedException</div><div class="line">    &#123;</div><div class="line">        long availableSequence;</div><div class="line">        int counter = SPIN_TRIES;</div><div class="line"></div><div class="line">        while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            counter = applyWaitMethod(barrier, counter);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return availableSequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void signalAllWhenBlocking()</div><div class="line">    &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当消费者没有获取到可用的sequence，则循环执行applyWaitMethod。直到存在可用的sequence，就返回该sequence。</p>
<p>返回sequence之后就可以根据该sequence从RingBuffer中get出这个sequence对应的event，执行业务操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    private int applyWaitMethod(final SequenceBarrier barrier, int counter)</div><div class="line">        throws AlertException</div><div class="line">    &#123;</div><div class="line">        barrier.checkAlert();</div><div class="line"></div><div class="line">        // counter默认为100，在减小到0之前不会进入if分支</div><div class="line">        if (0 == counter)</div><div class="line">        &#123;</div><div class="line">            Thread.yield();</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            --counter;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return counter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先，counter默认为100，在减小到0之前不会进入if分支，直接进入else，执行减1操作。<blockquote>
<p>也就是说，首先会自旋重试100次（此值可设置，默认100次），如果在重试过程中，存在可用的序列号，则直接返回可用的序列号。</p>
</blockquote>
</li>
<li>如果自旋了100次，counter减到0了，还是没有得到可用的sequence序列号，那么就会调用Thread.yield方法，让渡CPU的使用权，让其它线程可以争抢到CPU使用权。当该线程再次获取CPU使用权时，继续该过程：如果没有可用的序列号，则继续放弃CPU使用权等待。</li>
</ul>
<blockquote>
<p>从分析我们可以看出，YieldingWaitStrategy基本上是在等待sequence期间，不断的通过Thread.yield出让CPU的使用权，因此这个策略会让CPU使用率保持在100%的满负荷，生产中强烈推荐 <strong>不要使用</strong> ！</p>
</blockquote>
<h2 id="盘点等待策略"><a href="#盘点等待策略" class="headerlink" title="盘点等待策略"></a>盘点等待策略</h2><ul>
<li>BlockingWaitStrategy：基于ReentrantLock的等待&amp;&amp;唤醒机制实现等待逻辑，该策略是Disruptor的默认策略，比较节省CPU，生产环境推荐使用；</li>
<li>BusySpinWaitStrategy：持续自旋，不推荐使用，会造成CPU负载100%；</li>
<li>DummyWaitStrategy：返回的Sequence值为0，正常情况下不使用</li>
<li>LiteBlockingWaitStrategy：基于BlockingWaitStrategy的轻量级等待策略，在没有锁竞争的时候会省去唤醒操作，但是作者说测试不充分，因此不建议使用</li>
<li>TimeoutBlockingWaitStrategy：带超时的等待策略，超时后会执行业务指定的处理逻辑</li>
<li>LiteTimeoutBlockingWaitStrategy：基于TimeoutBlockingWaitStrategy的策略，当没有锁竞争的时候会省去唤醒操作</li>
<li>SleepingWaitStrategy：三段式策略，第一阶段自旋，第二阶段执行Thread.yield让出CPU，第三阶段睡眠执行时间，反复的睡眠</li>
<li>YieldingWaitStrategy：二段式策略，第一阶段自旋，第二阶段执行Thread.yield交出CPU</li>
<li>PhasedBackoffWaitStrategy：四段式策略，第一阶段自旋指定次数，第二阶段自旋指定时间，第三阶段执行Thread.yield交出CPU，第四阶段调用成员变量的waitFor方法，该成员变量可以被设置为BlockingWaitStrategy、LiteBlockingWaitStrategy、SleepingWaitStrategy三个中的一个</li>
</ul>
<h2 id="扩展：单一写原则"><a href="#扩展：单一写原则" class="headerlink" title="扩展：单一写原则"></a>扩展：单一写原则</h2><p>在并发系统中提高性能最好的方式之一就是单一写原则，Disruptor中生产者就体现了这一原则。</p>
<p>如果在你的代码中仅仅有一个事件生产者，那么可以设置为单一生产者模式来提高系统的性能。</p>
<p>单一写的好处在于：完全不需要考虑同步多个写线程，写入操作没有上下文切换，并且是线程安全的（写入串行化）。</p>
<p>关于单一写原则，可以阅读： <a href="https://mechanical-sympathy.blogspot.com/2011/09/single-writer-principle.html" target="_blank" rel="external">https://mechanical-sympathy.blogspot.com/2011/09/single-writer-principle.html</a></p>
<p>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们接着介绍Disruptor高性能实现之道–等待策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;等待策略waitStrategy是一种决定一个消费者如何等待生产者将event对象放入Disruptor的方式/策略。&lt;/p&gt;
&lt;p&gt;等待策略waitStrategy是一个接口，它的所有实现都是针对消费者生效的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-环形数组RingBuffer</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84RingBuffer/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-环形数组RingBuffer/</id>
    <published>2022-02-28T10:10:16.000Z</published>
    <updated>2022-02-28T14:29:23.389Z</updated>
    
    <content type="html"><![CDATA[<p>Ringbuffer（环形缓冲区/环形数组）是Disruptor的核心底层数据结构。</p>
<p>它不同于传统的阻塞队列（如：ArrayBlockingQueue）是从某一端入队，另外一端出队，而是一种收尾相连的环形结构。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-环形数组RingBuffer/ringbuffer.png" alt="ringbuffer.png"></p>
<p>之所以叫它 buffer，我想大概是因为这个环形队列是作为不同线程（or上下文）之间传递数据媒介，类似于一个缓冲区。</p>
<p>RingBuffer拥有一个序号，指向数组中下一个可用的元素，需要注意的是Disruptor中的RingBuffer没有头尾指针，而只通过序号（sequence）就实现了生产者与消费者之间的进度协调。</p>
<h2 id="RingBuffer可以一直填充吗？"><a href="#RingBuffer可以一直填充吗？" class="headerlink" title="RingBuffer可以一直填充吗？"></a>RingBuffer可以一直填充吗？</h2><p>假如不断地填充RingBuffer，那么必然会发生sequence一直增加，直到绕过环，覆盖原有的内容。</p>
<p>Disruptor是通过barrier实现了是否要覆盖原有内容的判断，这部分内容后面会说到。</p>
<h2 id="如何定位RingBuffer中的元素呢？"><a href="#如何定位RingBuffer中的元素呢？" class="headerlink" title="如何定位RingBuffer中的元素呢？"></a>如何定位RingBuffer中的元素呢？</h2><p>正如我们在前面所说，RingBuffer本质上是个数组，那么必然可以通过数组的偏移量offset或者说index，定位到具体的元素。</p>
<p>在实际的开发中，我们常通过取模运算来获取元素在数组中的偏移量。也就是  <strong>序号 % 长度 == 索引</strong></p>
<p>假设有8个元素，那么元素序号为13的元素就位于：</p>
<blockquote>
<p>13 % 8 = 5</p>
</blockquote>
<p>对于Disruptor而言，它强制要求数组的size初始化为 2的N次方，如 1024 * 1024。</p>
<blockquote>
<p>设置为2的N次方有这样的好处：可以通过位运算更快速定位到元素位置。公式为：</p>
<p>seq &amp; (ringBufferSize - 1) == index</p>
</blockquote>
<p>在Disruptor中， ringBufferSize-1 成为mask，即掩码。</p>
<h2 id="RingBuffer中的数据是如何预热的？"><a href="#RingBuffer中的数据是如何预热的？" class="headerlink" title="RingBuffer中的数据是如何预热的？"></a>RingBuffer中的数据是如何预热的？</h2><p>RingBuffer通过预分配对象机制来降低GC的影响。在实际运行过程中，业务从RingBuffer中获取对应sequence位置的对象引用，对该引用指向的对象属性赋值，通过覆盖写方式而不是直接覆盖整个对象的方式，保证了对象引用在整个disruptor存活的周期内都存在，保证GCRoot始终存在，因此能够大幅降低GC的影响。</p>
<p>这也是Disruptor高性能保证的策略之一，由于Disruptor主要使用场景之一就是低延迟环境，因此必须减少运行时内存分配，从而减少垃圾回收导致的系统停顿（STW）。</p>
<blockquote>
<p>这种预加载机制在其他的中间件也有使用，如RocketMQ的commitLog也是在broker启动时就创建固定1G的文件，便于启动完成便可进行写入而不需要进行运行期创建。</p>
</blockquote>
<p>Disruptor的RingBuffer数据预热具体的实现，查看Disruptor源码：</p>
<p>Disruptor初始化过程中会初始化RingBuffer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RingBuffer( EventFactory&lt;E&gt; eventFactory,Sequencer sequencer)&#123;</div><div class="line">    super(eventFactory, sequencer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RingBuffer是RingBufferFields子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final class RingBuffer&lt;E&gt; extends RingBufferFields&lt;E&gt; implements Cursored, EventSequencer&lt;E&gt;, EventSink&lt;E&gt;</div></pre></td></tr></table></figure>
<p>初始化RingBuffer时会先调用父类构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">RingBufferFields(EventFactory&lt;E&gt; eventFactory, Sequencer sequencer) &#123;</div><div class="line">    this.sequencer = sequencer;</div><div class="line">    this.bufferSize = sequencer.getBufferSize();</div><div class="line"></div><div class="line">    if (bufferSize &lt; 1)</div><div class="line">    &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;bufferSize must not be less than 1&quot;);</div><div class="line">    &#125;</div><div class="line">    if (Integer.bitCount(bufferSize) != 1)</div><div class="line">    &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;bufferSize must be a power of 2&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 用于计算index的掩码，公式：seq &amp; (ringBufferSize - 1) == index</div><div class="line"></div><div class="line">    this.indexMask = bufferSize - 1;</div><div class="line"></div><div class="line">    // 初始化RingBuffer数组</div><div class="line"></div><div class="line">    this.entries = new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];</div><div class="line"></div><div class="line">    // 预填充RingBuffer数组</div><div class="line">    fill(eventFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用fill方法预填充数组，实现逻辑就是为数组的每个index填充一个对象实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void fill(EventFactory&lt;E&gt; eventFactory)&#123;</div><div class="line">    for (int i = 0; i &lt; bufferSize; i++)&#123;</div><div class="line">        entries[BUFFER_PAD + i] = eventFactory.newInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>填充操作通过用户定义的eventFactory实现，该工厂一般写法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class OrderEventFactory implements EventFactory&lt;OrderEvent&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public OrderEvent newInstance() &#123;</div><div class="line">        // new 一个空的orderEvent对象即可</div><div class="line">        // 就是为了返回空的event对象</div><div class="line">        return new OrderEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ringbuffer（环形缓冲区/环形数组）是Disruptor的核心底层数据结构。&lt;/p&gt;
&lt;p&gt;它不同于传统的阻塞队列（如：ArrayBlockingQueue）是从某一端入队，另外一端出队，而是一种收尾相连的环形结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/0
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-缓存行填充</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A1%AB%E5%85%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-缓存行填充/</id>
    <published>2022-02-28T10:09:11.000Z</published>
    <updated>2022-02-28T15:52:06.696Z</updated>
    
    <content type="html"><![CDATA[<p>Disruptor高性能的另一个实现机制为 “缓存行填充”，它解决了CPU访问内存变量的“伪共享”问题。</p>
<h2 id="什么是伪共享？"><a href="#什么是伪共享？" class="headerlink" title="什么是伪共享？"></a>什么是伪共享？</h2><blockquote>
<p>在解释什么是伪共享之前，先了解下数据在缓存中是如何存储的。</p>
</blockquote>
<p>我们都知道，计算机为了解决CPU与主存之间速度差的问题，引入了多级缓存机制。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/cache-1.png" alt="cache-1.png"></p>
<p>事实上，数据在CPU缓存(多级cache)中并非是单独存储的，而是按行存储的。其中每一行成为一个缓存行。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/cache-2.png" alt="cache-2.png"></p>
<p>缓存行是CPU的Cache与主内存进行数据交换的基本单位，每个缓存行的大小一般为2的N次方字节。（<strong>在32位计算机中为32字节，64位计算机中为64字节。</strong>）可以想到，如果计算机为128位，则缓存行大小就是128字节。</p>
<p>在Java中，一个long型变量为8字节，也就是说在64位计算机中，每行可存放8个long型变量。</p>
<blockquote>
<p>当CPU访问某个变量的时，如果CPU Cache中存在该变量，则直接获取。若不存在则去主内存获取该变量。由于缓存行机制的存在，因此会将该变量所在内存区域为一个缓存行大小的内存复制到CPU Cache中。</p>
</blockquote>
<p>此时有可能会在一行缓存行中加载多个变量，如图中不同的颜色对应不同的long型变量。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/cache-3.png" alt="cache-3.png"></p>
<blockquote>
<p>试想，如果多个内核的线程都操作了同一缓存行的数据，如图所示。CPU1读取并修改了缓存行中的变量D，了解volatile的同学都知道，当CPU Cache中的变量发生变更，会通过缓存一致性协议通知其他CPU失效当前缓存行，重新从主内存中加载当前行的值。</p>
</blockquote>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/expire.png" alt="expire.png"></p>
<p>图中，CPU1修改了缓存行中的变量D，CPU2也在读取该缓存行的值。根据缓存一致性协议，CPU2中的缓存行会失效，因为它操作的缓存行中的变量D的值已经不是最新值了。</p>
<p>这是因为CPU是以缓存行为单位进行数据的读写操作的。</p>
<p>这就是伪共享。</p>
<p>为什么是“伪”共享呢？ </p>
<blockquote>
<p>看起来CPU1 与 CPU2 共享了同一个缓存行，但是由于CPU以缓存行为单位进行读写操作，无论CPU1 与 CPU2中的任何一位修改了缓存行中的值，都需要通知其他CPU对失效该缓存行。也就是说当线程对缓存进行了写操作，则当前线程所在内核就需要失效其他内核的缓存行，并重新加载主内存。</p>
</blockquote>
<p>这是一种缓存未命中的情况，当发生这样的情况，缓存本身的意义就被削弱了，因为CPU始终需要从主内存加载数据，而根本命中不了CPU Cache中的缓存。</p>
<blockquote>
<p>所谓的“伪”共享，就可以理解成是一种 “错误”的共享，这种共享如果不发生，则多核CPU操作缓存行互不影响，每个核心都只关心自己操作的变量，而不会因为读写自己关心的变量而影响到其他CPU对变量的读写。</p>
</blockquote>
<h2 id="Disruptor是如何进行缓存行填充的？"><a href="#Disruptor是如何进行缓存行填充的？" class="headerlink" title="Disruptor是如何进行缓存行填充的？"></a>Disruptor是如何进行缓存行填充的？</h2><blockquote>
<p>Disruptor解决伪共享的方式为：使用缓存行填充。</p>
</blockquote>
<p>上文我们提到，由于多核CPU同时读写统一缓存行中的数据，导致了CPU Cache命中失败的伪共享问题。</p>
<p>那么只需要避免多核CPU同时操作统一缓存行，不就可以解决这个问题了么？</p>
<p>事实上，Disruptor正是这么做的。</p>
<blockquote>
<p>Disruptor为Sequence中的value（volatile修饰）进行了缓存行填充，保证每个sequence只在一个缓存行中存在，避免了其他的变量对sequence的干扰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">class LhsPadding</div><div class="line">&#123;</div><div class="line">    protected long p1, p2, p3, p4, p5, p6, p7;  // 缓存行填充</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Value extends LhsPadding</div><div class="line">&#123;</div><div class="line">    protected volatile long value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RhsPadding extends Value</div><div class="line">&#123;</div><div class="line">    protected long p9, p10, p11, p12, p13, p14, p15; // 缓存行填充</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * &lt;p&gt;Concurrent sequence class used for tracking the progress of</div><div class="line"> * the ring buffer and event processors.  Support a number</div><div class="line"> * of concurrent operations including CAS and order writes.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Also attempts to be more efficient with regards to false</div><div class="line"> * sharing by adding padding around the volatile field.</div><div class="line"> */</div><div class="line">public class Sequence extends RhsPadding</div><div class="line">&#123;</div><div class="line">    static final long INITIAL_VALUE = -1L;</div><div class="line">    private static final Unsafe UNSAFE;</div><div class="line">    private static final long VALUE_OFFSET;</div><div class="line"></div><div class="line">    static</div><div class="line">    &#123;</div><div class="line">        UNSAFE = Util.getUnsafe();</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            VALUE_OFFSET = UNSAFE.objectFieldOffset(Value.class.getDeclaredField(&quot;value&quot;));</div><div class="line">        &#125;</div><div class="line">        catch (final Exception e)</div><div class="line">        &#123;</div><div class="line">            throw new RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="其他的缓存行填充机制"><a href="#其他的缓存行填充机制" class="headerlink" title="其他的缓存行填充机制"></a>其他的缓存行填充机制</h2><p>JDK1.8 提供了注解 <strong>@Contended</strong> 用于解决伪共享问题，需要注意的是，如果业务代码需要使用该注解，要添加JVM参数</p>
<blockquote>
<p>-XX:-RestrictContended。</p>
</blockquote>
<p>默认填充宽度为128，若需要自定义填充宽度，则设置 </p>
<blockquote>
<p>-XX:ContendedPaddingWidth</p>
</blockquote>
<p>具体的使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@sun.misc.Contended</div><div class="line">public final static class Value &#123;</div><div class="line">  public volatile long value = 0L;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Java并发编程之美》</li>
<li>并发编程网：剖析Disruptor:为什么会这么快？（二）神奇的缓存行填充</li>
</ul>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Disruptor高性能的另一个实现机制为 “缓存行填充”，它解决了CPU访问内存变量的“伪共享”问题。&lt;/p&gt;
&lt;h2 id=&quot;什么是伪共享？&quot;&gt;&lt;a href=&quot;#什么是伪共享？&quot; class=&quot;headerlink&quot; title=&quot;什么是伪共享？&quot;&gt;&lt;/a&gt;什么是伪共
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-无锁</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E6%97%A0%E9%94%81/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-无锁/</id>
    <published>2022-02-28T10:08:59.000Z</published>
    <updated>2022-03-01T16:35:45.282Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，我们讨论了Disruptor高性能实现机制中的：</p>
<ul>
<li>RingBuffer环形队列及内存预加载</li>
<li>缓存行填充避免伪共享</li>
</ul>
<p>本文开始之前先对之前没有讲到的细节进行补充。</p>
<h2 id="对于数组元素预加载的补充解释"><a href="#对于数组元素预加载的补充解释" class="headerlink" title="对于数组元素预加载的补充解释"></a>对于数组元素预加载的补充解释</h2><pre><code>private void fill(EventFactory&lt;E&gt; eventFactory)
{
    for (int i = 0; i &lt; bufferSize; i++)
    {
        entries[BUFFER_PAD + i] = eventFactory.newInstance();
    }
}
</code></pre><p>一次性填充慢整个数组，这样做是一个比较有技巧的做法，Disruptor通过填充慢数组，在运行时改变对象的值来达到防止Java垃圾回收（GC）产生的系统开销。</p>
<p>换句话说就是它不需要垃圾回收。<br><a id="more"></a></p>
<h2 id="Disruptor是如何通过位运算提升取模效率的？"><a href="#Disruptor是如何通过位运算提升取模效率的？" class="headerlink" title="Disruptor是如何通过位运算提升取模效率的？"></a>Disruptor是如何通过位运算提升取模效率的？</h2><p>我们已经知道，RingBufferSize为2的N次方时，可以通过位于运算提升取模效率，公式为：</p>
<blockquote>
<p>seq &amp; (ringBufferSize - 1) == index</p>
</blockquote>
<p>即：当前event的sequence与RingBufferSize-1的差进行位于运算，就等价于sequence Mod RingBufferSize，但是效率更高。</p>
<p>在Disruptor的源码中具体是如何利用该机制的？</p>
<pre><code>@Override
public E get(long sequence)
{
    return elementAt(sequence);
}
</code></pre><blockquote>
<p>Disruptor通过get(sequence)从RingBuffer中取出下一个可用的sequence位于RingBuffer中的下标，具体实现在elementAt方法中。</p>
</blockquote>
<pre><code>// com.lmax.disruptor.RingBufferFields#elementAt
protected final E elementAt(long sequence)
{
    return (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));
}
</code></pre><blockquote>
<p>可以看到elementAt是通过UNSAFE直接调用底层方法getObject，通过递增序列号获取与序列号对应的数组元素。</p>
</blockquote>
<h2 id="缓存行填充与局部性原理"><a href="#缓存行填充与局部性原理" class="headerlink" title="缓存行填充与局部性原理"></a>缓存行填充与局部性原理</h2><p>我们知道Disruptor是通过缓存行填充避免了伪共享问题。</p>
<p>实际上这与 “局部性原理” 息息相关。</p>
<blockquote>
<p>解释下什么叫做：局部性原理。</p>
<p>程序的局部性原理指的是在一段时间内程序的执行会限定在一个局部范围内。<br>这里的“局部性”可以从两个方面来理解，一个是时间局部性，另一个是空间局部性。</p>
<p>时间局部性指的是程序中的某条指令一旦被执行，不久之后这条指令很可能再次被执行；如果某条数据被访问，不久之后这条数据很可能再次被访问。</p>
<p>而空间局部性是指某块内存一旦被访问，不久之后这块内存附近的内存也很可能被访问。</p>
</blockquote>
<p>CPU缓存读写就利用了局部性原理。</p>
<p>当CPU从主内存加载数据A时，它会将数据A缓存至CPU的高速缓存cache中。除了A会被缓存，A附近的数据也会被缓存。</p>
<p>根据局部性原理分析，由于A会被访问，那么A周围的其他数据也很有可能会被访问，如果一并加载则会提升程序的性能。</p>
<p>但是由于多核CPU同时修改同一缓存行，导致缓存行失效后重新加载主内存，因此出现了伪共享的问题。</p>
<h2 id="再次分析Disruptor对变量的缓存行填充原理"><a href="#再次分析Disruptor对变量的缓存行填充原理" class="headerlink" title="再次分析Disruptor对变量的缓存行填充原理"></a>再次分析Disruptor对变量的缓存行填充原理</h2><p>首先看一下Disruptor中对 INITIAL_CURSOR_VALUE 的特殊处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final class RingBuffer&lt;E&gt; extends RingBufferFields&lt;E&gt; implements Cursored, EventSequencer&lt;E&gt;, EventSink&lt;E&gt;</div><div class="line">&#123;</div><div class="line">    public static final long INITIAL_CURSOR_VALUE = Sequence.INITIAL_VALUE;</div><div class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</div></pre></td></tr></table></figure>
<p>RingBuffer继承于RingBufferField</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">abstract class RingBufferFields&lt;E&gt; extends RingBufferPad</div></pre></td></tr></table></figure>
<p>RingBufferFields继承于RingBufferPad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">abstract class RingBufferPad</div><div class="line">&#123;</div><div class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我们就知道，在INITIAL_CURSOR_VALUE前后各填充了7个long型变量。</p>
<p>前面的 7 个来自继承的 RingBufferPad 类，后面的 7 个则是直接定义在 RingBuffer 类里<br>面。</p>
<p><strong>这14个变量没有任何实际的用途。既不会去读也不会去写他们。</strong></p>
<p><img src="/2022/02/28/Disruptor高性能之道-无锁/padding.png" alt="padding.png"></p>
<p>可以看到，常量INITIAL_CURSOR_VALUE前后各填充了7个long型变量，无论CPU高速缓存如何加载缓存行（一个缓存行8个long型长度），整个缓存行都没有会发生变更的数据，这个8个long类型的缓存行无论如何加载上面的内存行，都能够读到常量，且不会加载除了常量的其他变量。</p>
<blockquote>
<p>而INITIAL_CURSOR_VALUE是一个常量，也不会进行修改。所以一旦它被加载到CPU Cache 之后，只要被频繁地读取访问，就不会再被换出 Cache 了。这也就意味着对于这个值的读取速度，会是<strong>一直是 CPU Cache 的访问速度，而不是内存的访问速度</strong>。</p>
</blockquote>
<p>这有效的解决了伪共享的问题。</p>
<h2 id="无锁的Disruptor"><a href="#无锁的Disruptor" class="headerlink" title="无锁的Disruptor"></a>无锁的Disruptor</h2><p>JUC中的队列BlockingQueue是通过加锁实现对生产者和消费者的协调。</p>
<p>加锁就意味着需要牺牲高性能，换来线程安全。</p>
<p>有没有办法既能高性能，还能线程安全？</p>
<p>Disruptor给出的答案是，“无锁”。</p>
<blockquote>
<p>无锁，并不是完全消除锁，而是指没有OS层面的锁。</p>
<p>Disruptor通过CAS（Compare And Swap）指令实现了无锁化。具体的指令是cmpxchg，本文会做简单讲解。感兴趣的读者可以自行搜索资料了解详细内容。</p>
</blockquote>
<p>简单解释下CAS具体干了什么事情。</p>
<blockquote>
<p>CAS, 比较并交换，Compare And Swap。顾名思义，就是通过比较值是否发生变化，决定是否要重新赋值。<br>如果在操作期间，值没有被其他线程操作，那么就将期望的值赋值给它，否则发现期望的值与旧值不等，说明值已经变更，则不执行操作，返回操作失败。</p>
</blockquote>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>比如说，旧值oldValue为1，期望的值expectValue为1，新值newValue为2。如果没有其他线程修改旧值，那么</p>
<ul>
<li>expectValue == oldValue</li>
<li>将newValue写入，当前值为2</li>
</ul>
<p>如果在操作过程中，oldValue被其他线程操作修改为2，那么当前线程的expectValue（1）与oldValue（2）比较就不等，写入失败。</p>
<h3 id="Disruptor如何进行CAS"><a href="#Disruptor如何进行CAS" class="headerlink" title="Disruptor如何进行CAS"></a>Disruptor如何进行CAS</h3><p>我们知道Disruptor核心数据结构为RingBuffer，Disruptor为RingBuffer分配了一个Sequence对象，用于标识RingBuffer的头和尾，这个标识不是通过指针实现的，而是通过序号。</p>
<blockquote>
<p>这个序号也就是Sequence。</p>
</blockquote>
<p>虽然逻辑上RingBuffer是一个环形数组，但是在内存中是以一个普通的数组形式存在的。</p>
<p>RingBuffer中通过对比序号的方式对生产者和消费者间的资源进行协调。</p>
<p>每当生产者要往队列中加入新数据，生产者都会将当前sequence + 准备加入队列的数据量，与消费者所在位置进行比较，以判断是否存在足够的空间放这些数据，而不至于覆盖掉消费者没有消费的数据。</p>
<p>用体育术语就叫“套圈”。</p>
<p>如图所示：ringBufferSize=16，生产者当前sequence指向20，消费者sequence指向27。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-无锁/cas.png" alt="cas.png"></p>
<p>我们简单计算一下这个场景下，生产者能否继续写入4个元素。</p>
<ul>
<li>对于消费者而言，27 MOD 16 = 11</li>
<li>对于生产者而言，20 + 4 = 24（预计写入的最大序号），24 MOD 16 = 8</li>
<li>生产者若成功写入4个元素，则sequence指向数组的第8个位置，8 &lt; 11, 表明生产者没有覆盖消费者的进度。</li>
<li>生产者不需要等待消费者，直接生产数据即可。而且并不会覆盖消费者未处理完的数据。</li>
</ul>
<p><img src="/2022/02/28/Disruptor高性能之道-无锁/cas1.png" alt="cas1.png"></p>
<p>实际上，Disruptor的代码实现就是通过compareAndSet方法实现了CAS无锁化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Atomically add the supplied value.</div><div class="line"> *</div><div class="line"> * @param increment The value to add to the sequence.</div><div class="line"> * @return The value after the increment.</div><div class="line"> */</div><div class="line">public long addAndGet(final long increment)</div><div class="line">&#123;</div><div class="line">    long currentValue;</div><div class="line">    long newValue;</div><div class="line"></div><div class="line">    do</div><div class="line">    &#123;</div><div class="line">        currentValue = get();</div><div class="line">        newValue = currentValue + increment;</div><div class="line">    &#125;</div><div class="line">    while (!compareAndSet(currentValue, newValue));</div><div class="line"></div><div class="line">    return newValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，这里通过while循环不断尝试CAS操作，如果CAS操作不成功就会自旋重试，这个操作并没有使用OS层面的锁，因此效率要大幅高于OS层面的锁机制（管程）。</p>
<p>addAndGet调用了compareAndSet方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Perform a compare and set operation on the sequence.</div><div class="line"> *</div><div class="line"> * @param expectedValue The expected current value.</div><div class="line"> * @param newValue The value to update to.</div><div class="line"> * @return true if the operation succeeds, false otherwise.</div><div class="line"> */</div><div class="line">public boolean compareAndSet(final long expectedValue, final long newValue)</div><div class="line">&#123;</div><div class="line">    return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expectedValue, newValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到最终是调用了UNSAFE的compareAndSwapLong方法，该方法为native方法，在JVM层面调用了CAS指令。</p>
<h3 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h3><p>上文我们提到，Disruptor的CAS最终调用的是CPU层面的机器指令<strong>cmpxchg</strong>。</p>
<p>该指令的详细描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compxchg [ax] (隐式参数，EAX 累加器), </div><div class="line">         [bx] (源操作数地址), </div><div class="line">         [cx] (目标操作数地址)</div></pre></td></tr></table></figure>
<p>简单解释下：</p>
<ul>
<li>cmpxchg指令有三个操作数，操作数ax不在指令里面出现，是一个隐式的操作数，准确地说它是EAX累加寄存器里面的值。</li>
<li>操作数bx是源操作数，指令会对比这个操作数和上面的累加寄存器里面的值是否相等，如果相等<br>CPU 会把 ZF（也就是条件码寄存器里面零标志位的值）设置为 1，然后再把操作数cx（也就是目标操作数）设置到源操作数的地址上。</li>
<li>如果不相等的话，就把源操作数里面的值设置到累加器寄存器里面</li>
</ul>
<p>由于cmpxchg是cpu级别的指令，因此直接调用就可以保证cas操作的原子性。</p>
<p>由于去除了OS层面的锁，即便CAS存在比较操作与自旋操作，其本质也是无锁化操作，这种无锁化机制消除了上下文切换，对于CPU极为友好，因此运行效率很快。</p>
<p>事实上，在JUC包中，也提供了大量的CAS相关工作类方便我们操作，这些类一般以atomic开头，如果去研究其实现，我们同样会发现最终是通过UNSAFE调用了底层的CAS实现，实现无锁化操作，减少上下文切换，提升代码运行速率。</p>
<blockquote>
<p>加锁导致的上下文切换之所以会显著影响代码运行速度，主要原因在于获取锁的过程中，CPU需要等待OS层面的锁竞争结果，对于没有获取锁的线程需要进行挂起，此时就需要进行上下文切换。</p>
<p>上下文切换会把挂起线程的寄存器中的数据放到线程栈，该操作会导致加载到高速缓存中的数据也失效，进而导致程序运行速率比无锁更慢。</p>
</blockquote>
<h3 id="CAS就没有什么问题么？"><a href="#CAS就没有什么问题么？" class="headerlink" title="CAS就没有什么问题么？"></a>CAS就没有什么问题么？</h3><p>当然CAS操作同样也会存在缺点，那就是由于CAS操作本身需要进行对比，如果不相等则会一直自旋（busy-wait），这样的操作会使得cpu的负载升高，全功率满负荷运行。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，我们讨论了Disruptor高性能实现机制中的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RingBuffer环形队列及内存预加载&lt;/li&gt;
&lt;li&gt;缓存行填充避免伪共享&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文开始之前先对之前没有讲到的细节进行补充。&lt;/p&gt;
&lt;h2 id=&quot;对于数组元素预加载的补充解释&quot;&gt;&lt;a href=&quot;#对于数组元素预加载的补充解释&quot; class=&quot;headerlink&quot; title=&quot;对于数组元素预加载的补充解释&quot;&gt;&lt;/a&gt;对于数组元素预加载的补充解释&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;private void fill(EventFactory&amp;lt;E&amp;gt; eventFactory)
{
    for (int i = 0; i &amp;lt; bufferSize; i++)
    {
        entries[BUFFER_PAD + i] = eventFactory.newInstance();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一次性填充慢整个数组，这样做是一个比较有技巧的做法，Disruptor通过填充慢数组，在运行时改变对象的值来达到防止Java垃圾回收（GC）产生的系统开销。&lt;/p&gt;
&lt;p&gt;换句话说就是它不需要垃圾回收。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>认识高性能并发框架Disruptor</title>
    <link href="http://wuwenliang.net/2022/02/28/%E8%AE%A4%E8%AF%86%E9%AB%98%E6%80%A7%E8%83%BD%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6Disruptor/"/>
    <id>http://wuwenliang.net/2022/02/28/认识高性能并发框架Disruptor/</id>
    <published>2022-02-28T10:07:11.000Z</published>
    <updated>2022-02-28T11:05:15.322Z</updated>
    
    <content type="html"><![CDATA[<p>Disruptor，一款超高性能、超低延迟的并发编程框架。这里用了两个“超”来突出它在性能上的优越性。</p>
<p>它的性能远远超过了传统并发编程基于锁同步，阻塞队列的实现方案，在高性能后端编程中，disruptor是一个不错的选择。</p>
<h2 id="Disruptor从何而来？"><a href="#Disruptor从何而来？" class="headerlink" title="Disruptor从何而来？"></a>Disruptor从何而来？</h2><p>Disruptor的爆火起源于软件开发大师 martin fowler（马丁富勒）在自己网站上一篇文章，<a href="https://martinfowler.com/articles/lmax.html" target="_blank" rel="external">原文链接</a> 文章介绍了外汇交易平台LMAX使用并开源的一种架构方案。</p>
<p>LMAX使用该方案实现了难以置信的 “单线程每秒处理600w订单” 的惊人能力。业务处理逻辑基于 完全运行内存运行 + 事件溯源 方式驱动。</p>
<p>Disruptor目前已经被LMAX开源，github地址 <a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="external">https://github.com/LMAX-Exchange/disruptor</a>。</p>
<h2 id="Disruptor有何特点？"><a href="#Disruptor有何特点？" class="headerlink" title="Disruptor有何特点？"></a>Disruptor有何特点？</h2><blockquote>
<p>Disruptor性能优越，必然有其设计上的独到之处，一般来说，我们认为Disruptor有以下特点：</p>
</blockquote>
<ul>
<li>Disruptor是面向并发编程的高性能框架，它在开发上简化了并发程序编码难度，性能上也是JUC并发包的数倍乃至十几倍；</li>
<li>Disruptor是CPU友好的、无锁的，基于单线程方式对任务进行调度，减少了上下文切换对系统资源的开销；</li>
<li>Disruptor底层数据结构基于数组，通过预加载方式提前加载对象到内存；Disruptor不会清理缓存中的数据，而是通过覆盖对象属性方式实现数据的读写，这降低了GC频率，使得系统资源的使用趋于平稳；</li>
<li>Disruptor能够避免“伪共享”，通过缓存行填充机制，Disruptor避免了伪共享对并发读写变量的消耗，消除了不必要缓存未命中。</li>
</ul>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Disruptor，一款超高性能、超低延迟的并发编程框架。这里用了两个“超”来突出它在性能上的优越性。&lt;/p&gt;
&lt;p&gt;它的性能远远超过了传统并发编程基于锁同步，阻塞队列的实现方案，在高性能后端编程中，disruptor是一个不错的选择。&lt;/p&gt;
&lt;h2 id=&quot;Disrup
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>金融系统101-股市交易那些事儿</title>
    <link href="http://wuwenliang.net/2022/02/23/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F101-%E8%82%A1%E5%B8%82%E4%BA%A4%E6%98%93%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://wuwenliang.net/2022/02/23/金融系统101-股市交易那些事儿/</id>
    <published>2022-02-23T15:20:38.000Z</published>
    <updated>2022-02-23T15:56:15.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>金融是这个世界运转不可或缺的部分，学习一点儿金融交易知识也是我们了解世界运行规律的一种方式。本系列“金融交易101”主要目的为普及一些金融交易相关的基础概念，不作为任何的投资建议与参考。希望我们在了解了这些金融证券交易的知识之后，能够明辨风险，谨慎理财。</p>
</blockquote>
<p>股市，顾名思义，股票市场。核心在于股票，市场的运转围绕着股票这一核心概念展开。</p>
<a id="more"></a>
<h2 id="中国股市的发展"><a href="#中国股市的发展" class="headerlink" title="中国股市的发展"></a>中国股市的发展</h2><blockquote>
<p>接触一个概念，要从其发展历史梳理脉络。</p>
</blockquote>
<p>我国股市在1989年开始试点，实行T+1交割、T+1交收机制。</p>
<p>主要交易所，如上海证券交易所（上交所）、深圳证券交易所（深交所）在A股市场均实行T+1交收。</p>
<p>交易双方在交易次日完成与交易有关证券、款项的收付，买卖双方的行为为：<strong>买方收到证券、卖方收到款项</strong>。</p>
<p>随着商品经济的发展，公司的规模越来越大，需要大量的长期资本。而如果单靠公司自身的资本化积累，是很难满足生产发展的需求的，所以必须从外部筹集资金。</p>
<p>而公司筹集长期资本一般有三种方式：一是向银行借贷；二是发行公司债券；三是发行股票。其中，股票市场是上市公司筹集资金的主要途径之一。原因在于前两种方式的利息较高，且存在时间限制，这不仅增加了公司的经营成本，而且使公司的资本难以稳定，因而有很大的局限性。</p>
<p>而利用发行股票的方式来筹集资金，则无须还本付息，只需在利润中划拨一部分出来支付红利即可。把这三种筹资方式综合比较起来，发行股票的方式无疑是最符合经济原则的，对公司来说是最有利的。所以发行股票来筹集资本就成为发展大企业经济的一种重要形式，而股票交易在整个证券交易中因此而占有相当重要的地位。</p>
<h2 id="股市相关术语"><a href="#股市相关术语" class="headerlink" title="股市相关术语"></a>股市相关术语</h2><blockquote>
<p>了解股市相关的术语，也就是了解股市的领域特定语言，对于进一步学习有着重要意义。学习术语也是走进一个领域的必经之路。</p>
</blockquote>
<ul>
<li>集合竞价</li>
</ul>
<blockquote>
<p>集合竞价是指对一段时间内接收的买卖申报一次性集中撮合的竞价方式。</p>
</blockquote>
<p>  9：15——9：20这五分钟，交易主机可接收买卖申报，也可接收撤单申报，但不对买卖申报或撤销申报做处理。<br>  9：20——9：25、14:57——15:00，交易主机不接受参与竞价交易的撤销申报。</p>
<ul>
<li>股票价格</li>
</ul>
<blockquote>
<p>是指股票在证券市场上买卖时的价格，市场不断撮合交易， 股票价格也由此不断产生变化， 这是直接反映股票价值的重要信息。</p>
</blockquote>
<ul>
<li>成交量(VOL)</li>
</ul>
<blockquote>
<p>成交量是股票在某一个单位时间内（分钟、小时、天）的成交数量。市场活跃时， 供不应求， 成交量一般比较大； 市场冷清时， 供大于求， 成交量萎缩， 代表人气低下。</p>
</blockquote>
<ul>
<li>外盘</li>
</ul>
<blockquote>
<p>外盘就是股票的买家以卖家的卖出价而买入成交，当成交价在卖出价时，将成交数量加入外盘累计数量中，这是一种买盘比较积极的表现。</p>
</blockquote>
<ul>
<li>内盘</li>
</ul>
<blockquote>
<p>内盘是指卖家以买家的买入价而卖出成交， 当成交价在买入价时，将成交数量加入内盘累计数量中， 这是一种抛售比较明显的表现。</p>
</blockquote>
<ul>
<li>开盘价</li>
</ul>
<blockquote>
<p>是指某种证券在证券交易所每个交易日开市后的第一笔每股买卖成交价格。世界上大多数证券交易所都采用成交额最大原则来确定开盘价。</p>
<p>如果开市后一段时间内（通常为半小时）某种证券没有买卖或没有成交，则取前一日的收盘价作为当日证券的开盘价。如果某证券连续数日未成交，则由证券交易所的场内中介经纪人根据客户对该证券买卖委托的价格走势提出指导价，促使成交后作为该证券的开盘价。在无形化交易市场中，如果某种证券连续数日未成交，以前一日的收盘价作为它的开盘价。</p>
</blockquote>
<ul>
<li>收盘价</li>
</ul>
<blockquote>
<p>指某种证券在证券交易所一天交易活动结束前最后一笔交易的成交价格。如当日没有成交，则采用上一交易日的收盘价作为当天的收盘价。收盘价是当日行情的标准，又是下一个交易日开盘价的依据，可据以预测未来证券市场行情；所以投资者对行情分析时，一般采用收盘价作为计算依据。</p>
</blockquote>
<ul>
<li>涨跌幅限制</li>
</ul>
<blockquote>
<p>是指在一个交易日内，除上市首日证券外，国内证券的交易价格相对上一交易日收市价格的涨跌幅度不得超过10%；超过涨跌限价的委托为无效委托。[<strong>这个机制本质上是一种“韭菜”保护程序，在美股并不存在类似的限制</strong>]</p>
</blockquote>
<h2 id="股票行情"><a href="#股票行情" class="headerlink" title="股票行情"></a>股票行情</h2><blockquote>
<p>股票行情指股票交易所内各只股票的涨幅变化及交易流通情况。每只股票的行情实质是由<strong>价格</strong>与<strong>时间</strong>组成。</p>
</blockquote>
<p><strong>股票价格</strong>，是指股票在证券市场上买卖时的价格。股票本身没有价值，仅是一种凭证。</p>
<p>其有价格的原因是它能给其持有者带来股利收入，故买卖股票实际上是购买或出售一种领取股利收入的凭证。票面价值是参与公司利润分配的基础，股利水平是一定量的股份资本与实现的股利比率，利息率是货币资本的利息率水平。</p>
<p>股票的<strong>买卖价格</strong>，即股票行市的高低，直接取决于股息的数额与银行存款利率的高低。它直接受供求的影响，而供求又受股票市场内外诸多因素影响，从而使股票的行市背离其票面价值。例如公司的经营状况、信誉、发展前景、股利分配政策以及公司外部的经济周期变动、利率、货币供应量和国家的政治、经济与重大政策等是影响股价波动的潜在因素，而股票市场中发生的交易量、交易方式和交易者成份等等可以造成股价短期波动。另外，人为地操纵股票价格，也会引起股价的涨落。</p>
<h2 id="股票交易规则"><a href="#股票交易规则" class="headerlink" title="股票交易规则"></a>股票交易规则</h2><ul>
<li>交易时间</li>
</ul>
<blockquote>
<p>股票交易时间在工作日的上午和下午，上午是9:30-11:30，下午是13:00-15:00。我们管开始交易叫“<strong>开盘</strong>”，交易结束叫“<strong>收盘</strong>”。</p>
</blockquote>
<ul>
<li>交易品种</li>
</ul>
<blockquote>
<p>交易品种属于在上交所、深交所上市的股票（A股、B股）、债券（国债和企业债券）、封闭式基金、ETF基金和权证等。 A股股票是以<strong>人民币</strong>进行交易的股票，是投资者股票交易的主要品种。B股股票是以<strong>外币</strong>进行交易的股票。上海证券交易所的B股以美元进行交易，深圳证券交易所的B股以港币进行交易。</p>
</blockquote>
<ul>
<li>交易制度</li>
</ul>
<blockquote>
<p>实行 T+1 操作，当天买入的股票第二天才能卖出。不能透支及买空卖空。(<strong>区别于币市的7*24实时交易，这种方式更加安全可靠，且能够在监管之下避免诸如对敲等非法交易手段。</strong>)</p>
</blockquote>
<ul>
<li>交易单位</li>
</ul>
<blockquote>
<p>买入股票或基金，申报数量应当为100股(份)或其整数倍，A股、基金的申报价格最小变动单位为0.01元人民币。股票(基金)单笔申报最大数量应当低于100万股(份)。</p>
</blockquote>
<p>备注：100股称为“1手”。</p>
<h2 id="股票是如何交易的？"><a href="#股票是如何交易的？" class="headerlink" title="股票是如何交易的？"></a>股票是如何交易的？</h2><p>股票在股市属于一种“商品”，它会在买卖双方之间交易。</p>
<p>买卖双方，即买方、卖方。</p>
<p><strong>“多”</strong> 和 <strong>“空”</strong>，这两个词在金融市场上很常见，所谓“多”，就是指上涨、向好，所谓“空”，就是下跌，向差。</p>
<h3 id="什么是看多-看空-做多-做空"><a href="#什么是看多-看空-做多-做空" class="headerlink" title="什么是看多/看空/做多/做空"></a>什么是看多/看空/做多/做空</h3><p>所以“看多”，就是指对之后的行情走势比较看好，比如说“看多某只股票”就是觉得这个股票之后会涨。 “看空”则相反。再就是“做多”，“做”的意思等同于“交易”了。“做多”就是认为未来会涨，所以买入。</p>
<p>那”做空“就是认为未来会跌，然后卖出了？卖出其实并不是做空，因为卖出了，其实就跟你没关系了。所谓“卖空“，是指认为未来某只股票会跌，所以先借到比如30万股该股票，然后以现价（比如10元/股）卖出，等到股票下跌后（比如跌到5元/股），再买回来还给别人，从而实现盈利。因为 <strong>国内没有卖空</strong> 的机制，所以大家可能并不熟悉， 在期货市场就可以实现做空。</p>
<p>看空与看多并不会直接影响股市价格走势，而做多与做空则会实际对价格走势造成影响。</p>
<p>做多，即买入股票，股市本身是撮合交易，它遵循“价格优先、时间优先”的规律。</p>
<p>对于买方而言，出价越高，越容易成交；</p>
<p>对于卖方而言，出价越低，越容易成交。</p>
<p>所以做多成交，会使得市场中的股价不断抬升，相反，做空成交则会使得市场中的价格走势不断降低。</p>
<p>从这里我们也能看出，这种多空交易本身是一种博弈，而完善的金融市场本质上就是这样的一个具备“多空”矛盾于一身的市场。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对金融市场中的股票交易进行了概要讲解，希望这些入门级别的概念能够帮助读者打开金融学习的大门，为更好的了解世界是如何运转的打好基础。</p>
<blockquote>
<p>预告：后续会基础推出撮合交易原理及代码实现的文章，敬请期待。</p>
</blockquote>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ul>
<li>智牛股-6-股票与撮合交易</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;金融是这个世界运转不可或缺的部分，学习一点儿金融交易知识也是我们了解世界运行规律的一种方式。本系列“金融交易101”主要目的为普及一些金融交易相关的基础概念，不作为任何的投资建议与参考。希望我们在了解了这些金融证券交易的知识之后，能够明辨风险，谨慎理财。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;股市，顾名思义，股票市场。核心在于股票，市场的运转围绕着股票这一核心概念展开。&lt;/p&gt;
    
    </summary>
    
      <category term="金融系统" scheme="http://wuwenliang.net/categories/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="金融系统" scheme="http://wuwenliang.net/tags/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>调优利器-火焰图使用图鉴</title>
    <link href="http://wuwenliang.net/2022/02/22/%E8%B0%83%E4%BC%98%E5%88%A9%E5%99%A8-%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BD%BF%E7%94%A8%E5%9B%BE%E9%89%B4/"/>
    <id>http://wuwenliang.net/2022/02/22/调优利器-火焰图使用图鉴/</id>
    <published>2022-02-22T04:54:43.000Z</published>
    <updated>2022-02-22T05:57:22.672Z</updated>
    
    <content type="html"><![CDATA[<p>本来想起个题目叫 “什么？你还没用过这个工具？” 或者 “再见，火焰图”。但是想了想，己所不欲，勿施于人。</p>
<p>正常写个题目就好了，非搞这么多噱头，就是为了所谓的阅读量和点击量。</p>
<p>如果内容是干货，对人有帮助还好，要是满怀期待打开，进去划拉划拉，越看越不对劲，最后拉到末尾才近乎“上当了”，又是可恶的推广软文，这种感觉就如同吃了翔味的巧克力一样，让人反胃。</p>
<blockquote>
<p>言归正传，今天来聊聊性能调优利器，火焰图的安装、使用及分析方法。</p>
<p>火焰图（Flame Graph）是由 Linux 性能优化大师 Brendan Gregg 发明的，和所有其他的 profiling 方法不同的是，火焰图以一个全局的视野来看待时间分布，它从底部往顶部，列出所有可能导致性能瓶颈的调用栈。</p>
</blockquote>
<p>先看一个火焰图的样例，看不懂不要紧，后文会解释怎么去理解，稍安勿躁。</p>
<p><img src="/2022/02/22/调优利器-火焰图使用图鉴/fire.PNG" alt="fire.PNG"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要获得火焰图，需要安装一套组件，核心的组件主要有</p>
<ul>
<li>async-profiler : 性能数据采集</li>
<li>FlameGraph     : 性能数据分析，并生成火焰图</li>
</ul>
<p>接下来按顺序讲解安装过程，读者朋友如果严格按照这个步骤来操作，一般都没有问题。</p>
<h3 id="原料准备"><a href="#原料准备" class="headerlink" title="原料准备"></a>原料准备</h3><p>至少需要有一套linux机器，笔者用的是centos-7。</p>
<p>可以搞个阿里云的ecs，也可以搞个虚拟机，当然直接在公司机器上操作也未尝不可，但是要注意安全，root权限下操作要小心（你懂的）。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>在正式安装之前，先确保环境已经准备好。否则环境搞了半天搞不定，直接放弃，打出GG。</p>
<blockquote>
<p>至少保证jdk、perl、c++编译器已经安装完毕。</p>
</blockquote>
<ol>
<li>安装Java，不用多说了哇，网上教程一大堆。</li>
</ol>
<blockquote>
<p>yum -y install git</p>
</blockquote>
<ol>
<li>安装GCC编译器</li>
</ol>
<blockquote>
<p>yum install gcc gcc-c++</p>
</blockquote>
<p>如果去搜索一下火焰图的其他教程，你可以会发现，有些教程让你安装 perf，我也试过了，装了perf，然后用perf-map-agent去搜集性能数据，直接失败了。</p>
<p>换成async-profiler，直接一次成功。不想踩坑的同学，直接用async-profiler吧，省心。</p>
<h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><p>很多教程都说，要安装git，然后使用git clone方式下载源码，但是他们没有交代的是，除了git安装外，你还需要经过配置才可以实现源码下载。</p>
<p>其实源码获取有更简便的方式，或许也不太简便吧，管他呢。</p>
<blockquote>
<p>安装lrzsz，用于上传文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y lrzsz</div></pre></td></tr></table></figure>
<blockquote>
<p>安装完成之后，获取async-profiler源码包。</p>
</blockquote>
<p>进入async-profiler源码地址，<a href="https://github.com/jvm-profiling-tools/async-profiler，" target="_blank" rel="external">https://github.com/jvm-profiling-tools/async-profiler，</a> 微信禁止外链，读者可以自行复制粘贴至浏览器访问。</p>
<p><img src="/2022/02/22/调优利器-火焰图使用图鉴/download-async.PNG" alt="download-async.PNG"></p>
<p>点击图中红线圈住的 <strong>“download zip”</strong> ，待下载完成之后，通过 <strong>sz -y</strong> 方式上传源码包。</p>
<p><img src="/2022/02/22/调优利器-火焰图使用图鉴/upload-async.PNG" alt="upload-async.PNG"></p>
<blockquote>
<p>使用相同的方式，将FlameGraph的源码包也上传至服务器。</p>
</blockquote>
<p>进入FlameGraph源码地址，<a href="https://github.com/brendangregg/FlameGraph" target="_blank" rel="external">https://github.com/brendangregg/FlameGraph</a> 下载源码压缩包，也一并上传至服务器。</p>
<p>具体的图不贴了，和上面一模一样。</p>
<h3 id="安装async-profiler"><a href="#安装async-profiler" class="headerlink" title="安装async-profiler"></a>安装async-profiler</h3><p>接着就到重头戏了，首先介绍如何安装async-profiler。</p>
<p>进入async-profiler源码上传路径，解压源码（直接unzip async-profiler.zip），进入解压后的文件目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd async-profiler</div><div class="line">make</div></pre></td></tr></table></figure>
<p>make完成之后，等待安装完成即可。</p>
<h3 id="安装FlameGraph"><a href="#安装FlameGraph" class="headerlink" title="安装FlameGraph"></a>安装FlameGraph</h3><p>实际上FlameGraph也无需安装，将代码上传并解压，就可以直接使用。</p>
<h2 id="【实战】分析Java性能，生成火焰图"><a href="#【实战】分析Java性能，生成火焰图" class="headerlink" title="【实战】分析Java性能，生成火焰图"></a>【实战】分析Java性能，生成火焰图</h2><p>接着讲一个实战案例。</p>
<p>首先，要有一个分析目标程序，我在服务器上部署了一个基于netty的im聊天demo，同时启动服务端与客户端。</p>
<p>启动服务端：</p>
<blockquote>
<p>nohup java -jar im-server-1.0.0-jar-with-dependencies.jar &gt; Log.log 2&gt;&amp;1 &amp;</p>
</blockquote>
<p>启动客户端，指定服务端地址（客户端与服务端在同一个机器）</p>
<blockquote>
<p>java -jar  -Dremote_ip=127.0.0.1 im-client-1.0.0-jar-with-dependencies.jar </p>
</blockquote>
<h3 id="启动性能分析"><a href="#启动性能分析" class="headerlink" title="启动性能分析"></a>启动性能分析</h3><p>启动性能分析，持续收集一分钟服务端性能指标。</p>
<p>先获取服务端的PID：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">[root@snowalker ~]# ps -ef | grep java</div><div class="line">root      9349     1  0 Feb11 ?        00:09:40 java -jar im-server-1.0.0-jar-with-dependencies.jar</div></pre></td></tr></table></figure>
<p>PID为9349，接着启动async-profiler收集java进程的性能指标。</p>
<blockquote>
<p>./profiler.sh -d 60 -o collapsed -f /tmp/test_01.txt ${pid}</p>
</blockquote>
<p>简单解释下，</p>
<ul>
<li>-d表示的是持续时长，60代表持续采集时间60s；</li>
<li>-o表示的是采集规范，这里用的是collapsed；</li>
<li>-f后面的路径，表示的是数据采集后生成的数据存放的文件路径（这里放在了/tmp/test_01.txt）</li>
<li>${pid} 表示的是采集目标进程的pid，也就是上面提到的30937</li>
</ul>
<p>pid为进程实际的进程id，这里就是9349，那么只需要执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">./profiler.sh -d 60 -o collapsed -f /tmp/test_02.txt 9349</div></pre></td></tr></table></figure>
<p>运行期间，处于阻塞状态，直到约定时间完成。</p>
<p>运行期间，接着模拟用户聊天，连续发送消息至服务端：</p>
<p><img src="/2022/02/22/调优利器-火焰图使用图鉴/send-message.PNG" alt="send-message.PNG"></p>
<p>性能数据收集结束之后，到/tmp/ 查看输出的性能指标文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@snowalker tmp]# ll</div><div class="line">-rw-r--r-- 1 root root   6008 Feb 22 12:45 test_02.txt</div></pre></td></tr></table></figure>
<p>可以看到，性能指标已经收集完成，接着就到火焰图生成工具-<strong>FlameGraph</strong>的出场时间了。</p>
<h3 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h3><p>执行命令</p>
<blockquote>
<p>perl flamegraph.pl –colors=java /tmp/test_02.txt &gt; /tmp/test_02.svg</p>
</blockquote>
<p>查看tmp路径下文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@snowalker tmp]# ll</div><div class="line">-rw-r--r-- 1 root root  32452 Feb 22 12:46 test_02.svg</div><div class="line">-rw-r--r-- 1 root root   6008 Feb 22 12:45 test_02.txt</div></pre></td></tr></table></figure>
<p>可以看到已经生成一张svg格式的图片，下载图片到本地：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sz test_02.svg</div></pre></td></tr></table></figure></p>
<p>使用浏览器打开图片，一张美观的火焰图展现在面前：</p>
<p><img src="/2022/02/22/调优利器-火焰图使用图鉴/" alt="fire.png"></p>
<h2 id="如何阅读火焰图？"><a href="#如何阅读火焰图？" class="headerlink" title="如何阅读火焰图？"></a>如何阅读火焰图？</h2><p>有了火焰图，我们得读懂它才能利用它进行性能优化。</p>
<p>一眼看过去，红红火火的，密密麻麻，可能你觉得案例中 不够密密麻麻，如果分析的是线上的程序，那复杂程度足够让人眼花缭乱。</p>
<p>那么我们应该如何理解火焰图的内容呢？</p>
<p>简单的说：</p>
<ol>
<li>火焰图，每一列代表一个调用栈，每一个格子代表一个函数</li>
<li>纵轴，即垂直方向的y轴，展示了栈的深度，按照调用关系从下到上排列。最顶上格子代表采样时，正在占用 cpu 的函数。</li>
<li>横轴，即水平方向的x轴，表示：火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起。需要注意的是它并不代表时间。【横轴没有特殊的含义，不代表调用关系！】</li>
<li>横轴格子的 <strong>宽度</strong> 代表其在采样中出现频率，<em>所以一个格子的宽度越大，说明它是瓶颈原因的可能性就越大。</em></li>
<li>火焰图格子的颜色是随机的暖色调，方便区分各个调用信息。</li>
<li>其他的采样方式也可以使用火焰图， on-cpu 火焰图横轴是指 cpu 占用时间，off-cpu 火焰图横轴则代表阻塞时间。</li>
<li>采样方式可以是单线程、多线程、多进程甚至是多 host，进阶用法参考文档：<a href="https://www.brendangregg.com/flamegraphs.html" target="_blank" rel="external">https://www.brendangregg.com/flamegraphs.html</a></li>
</ol>
<p>另外，多说两句，火焰图的栈深度与y轴高度成正比，可以这么认为：造成性能问题的基本都处于调用栈的栈顶位置。</p>
<p>因为栈顶位置的性能问题会间接拖慢整个调用栈，简单的举个例子：方法A调用方法B，方法B调用方法C。</p>
<p>如果方法C执行的慢会则间接导致方法B慢，从而导致方法A慢。符合我们说的通过分析栈顶从而达到分析瓶颈的目的。</p>
<p>如果A方法本身就慢呢？通过火焰图也是可以看出来的，这种底层栈的宽度很宽，但是建立在其撒花姑娘的调用链线条都很窄，火焰图呈现“┻”型，那么我们基本可以确定，栈底方法本身就存在性能问题。</p>
<p>我们的一个分析火焰图的基本原则就是，从栈顶看起，往栈底分析。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来想起个题目叫 “什么？你还没用过这个工具？” 或者 “再见，火焰图”。但是想了想，己所不欲，勿施于人。&lt;/p&gt;
&lt;p&gt;正常写个题目就好了，非搞这么多噱头，就是为了所谓的阅读量和点击量。&lt;/p&gt;
&lt;p&gt;如果内容是干货，对人有帮助还好，要是满怀期待打开，进去划拉划拉，越看越
    
    </summary>
    
      <category term="Java" scheme="http://wuwenliang.net/categories/Java/"/>
    
    
      <category term="Java" scheme="http://wuwenliang.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>源码级探究Mybatis原理-以查询为例</title>
    <link href="http://wuwenliang.net/2022/02/20/%E6%BA%90%E7%A0%81%E7%BA%A7%E6%8E%A2%E7%A9%B6Mybatis%E5%8E%9F%E7%90%86-%E4%BB%A5%E6%9F%A5%E8%AF%A2%E4%B8%BA%E4%BE%8B/"/>
    <id>http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/</id>
    <published>2022-02-20T14:03:15.000Z</published>
    <updated>2022-02-20T16:21:39.428Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名Java后端开发者，尤其是国内开发者，从刚参加工作开始就与Mybatis打交道了。</p>
<p>用了这么久的Mybatis难免会心生疑问：</p>
<ul>
<li>我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？</li>
<li>都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？</li>
<li>为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?</li>
</ul>
<blockquote>
<p>硬核万字长文，点个再看，转发，多谢啦~</p>
</blockquote>
<a id="more"></a>
<p>随着工作经验越多，对这些问题的疑惑就会越发强烈。而读源码是解决这些疑问的根本方法。</p>
<p>那么就跟随笔者的脚步，试着用一篇文章，以一个查询为例，从源码角度一步一步揭开Mybatis的神秘面纱。</p>
<h2 id="一、先看一个demo"><a href="#一、先看一个demo" class="headerlink" title="一、先看一个demo"></a>一、先看一个demo</h2><pre><code>private SqlSessionFactory sqlSessionFactory;

@Before
public void prepare() throws IOException {
    String resource = &quot;mybatis-config.xml&quot;;
    InputStream inputStream = Resources.getResourceAsStream(resource);
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
}

/**
 * 通过 SqlSession.getMapper(XXXMapper.class)  接口方式
 * @throws IOException
 */
@Test
public void testSelect() throws IOException {
    SqlSession session = sqlSessionFactory.openSession(); // ExecutorType.BATCH
    try {
        BlogMapper mapper = session.getMapper(BlogMapper.class);
        Blog blog = mapper.selectBlogById(1);
        System.out.println(blog);
    } finally {
        session.close();
    }
}
</code></pre><p>这是一个非Spring项目的Test用例类，逻辑很直观，就是在测试通过id查询一行记录；在执行查询之间加载配置文件。</p>
<p>执行该测试用例，日志输出如下：</p>
<pre><code>Opening JDBC Connection
Created connection 1325808650.
Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@4f063c0a]
==&gt;  Preparing: select * from blog where bid = ? 
==&gt; Parameters: 1(Integer)
&lt;==    Columns: bid, name, author_id, type
&lt;==        Row: 1, RabbitMQ延时消息, 1001, 0
getNullableResult---1NORMAL
&lt;==      Total: 1
Blog(bid=1, name=RabbitMQ延时消息, authorId=1001, blogType=0)
</code></pre><p>我们就通过这个ById查询的案例，对Mybatis运行的过程抽丝剥茧，还原出一个完整的脉络。</p>
<h2 id="二、一图总览全局"><a href="#二、一图总览全局" class="headerlink" title="二、一图总览全局"></a>二、一图总览全局</h2><blockquote>
<p>按照惯例我们用一张简单概括的流程图引领全局，先建立一个宏观的印象。</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/1.png" alt="1.png"></p>
<p>从图中可以看到，Mybatis主要的工作流程分为以下几步：</p>
<ol>
<li>加载并解析配置文件</li>
<li>获取SqlSession对象作为与数据库交互的接口</li>
<li>通过Executor对象封装数据库操作，执行SQL操作</li>
<li>调用底层的JDBC接口，与数据库进行真正的交互</li>
<li>向数据库提交参数，并封装返回参数</li>
</ol>
<h3 id="加载并解析配置文件"><a href="#加载并解析配置文件" class="headerlink" title="加载并解析配置文件"></a>加载并解析配置文件</h3><p>在Mybatis启动的时候回去加载配置文件，一般来说文件包含全局配置文件（文件名为 <strong>mybatis-config.xml</strong>） ，以及映射器配置文件（也就是各种Mapper.xml文件）；</p>
<h3 id="获取SqlSession对象作为与数据库交互的接口"><a href="#获取SqlSession对象作为与数据库交互的接口" class="headerlink" title="获取SqlSession对象作为与数据库交互的接口"></a>获取SqlSession对象作为与数据库交互的接口</h3><p>Mybatis在加载完配置文件之后，会去获取SqlSession对象，这个对象是应用程序与数据库之间的桥梁，封装了程序与数据库之间的连接。</p>
<p>一般来说，一个SqlSession对象中包含了一个Connection，我们都知道Connection是线程不安全的，因此导致SqlSession对象也是线程不安全的。因此如果将SqlSession作为成员变量使用，存在风险。（应当使用SqlSessionTemplate，这部分后面再说）。</p>
<blockquote>
<p>注意：SqlSession是提供给应用层的一个访问数据库的接口，它并不是真正的SQL执行者，它内部封装了JDBC核心对象，如Statement，ResultSet等。</p>
</blockquote>
<h3 id="通过SqlSessionFactory获取SqlSession会话"><a href="#通过SqlSessionFactory获取SqlSession会话" class="headerlink" title="通过SqlSessionFactory获取SqlSession会话"></a>通过SqlSessionFactory获取SqlSession会话</h3><p>如果要获取一个SqlSession会话，就需要有会话工厂，即：SqlSessionFactory。它包含了所有的配置信息，而Factory又是通过Builder创建的，这部分后文代码分析中会说。</p>
<h3 id="通过Executor对象封装数据库操作，执行SQL操作"><a href="#通过Executor对象封装数据库操作，执行SQL操作" class="headerlink" title="通过Executor对象封装数据库操作，执行SQL操作"></a>通过Executor对象封装数据库操作，执行SQL操作</h3><p>SqlSession持有Executor对象，Executor在执行query、update、insert等操作时，会创建一系列的对象处理参数、处理结果集，核心的对象是StatementHandler，它本质上是对Statement的封装。</p>
<h2 id="三、走进源码，一探究竟"><a href="#三、走进源码，一探究竟" class="headerlink" title="三、走进源码，一探究竟"></a>三、走进源码，一探究竟</h2><h3 id="3-1-SqlSessionFactory的创建"><a href="#3-1-SqlSessionFactory的创建" class="headerlink" title="3.1 SqlSessionFactory的创建"></a>3.1 SqlSessionFactory的创建</h3><blockquote>
<p>首先是SqlSession的创建过程；SqlSession需要通过SqlSessionFactory创建，而SqlSessionFactory又是通过SqlSessionFactoryBuilder创建的。</p>
</blockquote>
<pre><code># org.apache.ibatis.session.SqlSessionFactoryBuilder#build
public SqlSessionFactory build(InputStream inputStream) {
  return build(inputStream, null, null);
}
</code></pre><p>事实上，inputStream就是配置文件的文件输入流，它传给了SqlSessionFactoryBuilder的build重载方法，我们看一下这个方法的实现。</p>
<pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    // 用于解析 mybatis-config.xml，同时创建了 Configuration 对象 &gt;&gt;
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    // 解析XML，最终返回一个 DefaultSqlSessionFactory &gt;&gt;
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}
</code></pre><p>可以看到，SqlSessionFactoryBuilder底层是通过xml解析方式，对配置文件进行解析，并基于解析的结果构建了SqlSessionFactory的实例，这里返回的是默认的SqlSessionFactory—&gt;DefaultSqlSessionFactory。</p>
<pre><code>public SqlSessionFactory build(Configuration config) {
  return new DefaultSqlSessionFactory(config);
}
</code></pre><p><strong>注意：此处就已经通过配置文件解析出了Configuration，并通过DefaultSqlSessionFactory构造方法创建了DefaultSqlSessionFactory实例。后文要用！</strong></p>
<blockquote>
<p>xml解析过程，感兴趣的读者可以自行研究，简单的说无非就是对xml文件的dom节点进行读取和匹配，获取属性加载到内存，Mybatis自己基于javax的xml操作api封装了一个工具类，<strong>org.apache.ibatis.parsing.XPathParser</strong> 。</p>
</blockquote>
<h3 id="3-2-SqlSession的创建"><a href="#3-2-SqlSession的创建" class="headerlink" title="3.2 SqlSession的创建"></a>3.2 SqlSession的创建</h3><p>在使用的demo中，我们通过SqlSessionFactory获取到一个SqlSession实例。</p>
<pre><code>SqlSession session = sqlSessionFactory.openSession();
</code></pre><p>进入 openSession 方法一探究竟。</p>
<pre><code># org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSession()
public SqlSession openSession() {
  return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
}
</code></pre><p>继续进入 openSessionFromDataSource 方法：</p>
<pre><code>private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
  Transaction tx = null;
  try {
    final Environment environment = configuration.getEnvironment();
    // 获取事务工厂
    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
    // 创建事务
    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
    // 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;
    final Executor executor = configuration.newExecutor(tx, execType);
    return new DefaultSqlSession(configuration, executor, autoCommit);
  } catch (Exception e) {
    closeTransaction(tx); // may have fetched a connection so lets call close()
    throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
</code></pre><p>这里的逻辑比较核心，主要做了几件事：</p>
<ol>
<li>获取到事务工厂；</li>
<li>通过事务工厂创建了事务，如果是使用Spring框架，则由Spring框架开启事务；</li>
<li>根据事务工厂和默认的执行器类型，创建执行器</li>
</ol>
<p>最后通过DefaultSqlSession的构造方法，创建出DefaultSqlSession实例，它是SqlSession接口的默认实现。</p>
<p>到此，我们就持有了一个SqlSession对象，并且它还持有了一个Executor执行器实例。</p>
<h3 id="代理Mapper对象，执行SQL"><a href="#代理Mapper对象，执行SQL" class="headerlink" title="代理Mapper对象，执行SQL"></a>代理Mapper对象，执行SQL</h3><p>回到我们的demo代码中：</p>
<pre><code>@Test
public void testSelect() throws IOException {
    SqlSession session = sqlSessionFactory.openSession(); // ExecutorType.BATCH
    try {
        // 重点看这行代码
        BlogMapper mapper = session.getMapper(BlogMapper.class);
        Blog blog = mapper.selectBlogById(1);
        System.out.println(blog);
    } finally {
        session.close();
    }
}
</code></pre><p>我们已经拿到了SqlSession，接着通过 <strong>session.getMapper(BlogMapper.class)</strong>; 获取到了BlogMapper接口的实现类。</p>
<p>注意，我说的并不是获取到了BlogMapper，因为大家使用过Mybatis框架都知道BlogMapper是个接口，那么此处拿到的，必然是BlogMapper的实例。</p>
<p>接口的实例，嗯，有点意思了，我们明明只写了个接口，并没有实现这个接口啊？</p>
<p>是不是想到了什么？对，就是动态代理。</p>
<p>此处获取到的Mapper实例，就是Mybatis框架帮我们创建出的代理对象。</p>
<blockquote>
<p>进入 DefaultSqlSession#getMapper 方法</p>
</blockquote>
<pre><code>@Override
public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
  return configuration.getMapper(type, this);
}
</code></pre><p>ok，继续往下看：</p>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre><p>这里，我们发现Mapper对象是通过 mapperRegistry 这个所谓的Mapper注册中心中获取到的，它的数据结构是一个HashMap:</p>
<pre><code># org.apache.ibatis.session.Configuration
protected final MapperRegistry mapperRegistry = new MapperRegistry(this);

# org.apache.ibatis.binding.MapperRegistry
public class MapperRegistry {
  private final Configuration config;
  private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();
</code></pre><p>既然我们能够通过Mapper接口类型get到接口的代理类，那它是多会儿put到Map里的?</p>
<p>仔细想一下应当能够想到，我们此时已经是在sql的执行期了，在这之前必然是配置文件的解析期间执行的put操作。具体代码如下：</p>
<pre><code>/**
* org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement
* Mapper解析
* @param parent
* @throws Exception
*/
private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    for (XNode child : parent.getChildren()) {
      // 不同的定义方式的扫描，最终都是调用 addMapper()方法
      // （添加到 MapperRegistry）。这个方法和 getMapper() 对应

      // package    包

      if (&quot;package&quot;.equals(child.getName())) {
        String mapperPackage = child.getStringAttribute(&quot;name&quot;);
        configuration.addMappers(mapperPackage);

      } else {
        String resource = child.getStringAttribute(&quot;resource&quot;);
        String url = child.getStringAttribute(&quot;url&quot;);
        String mapperClass = child.getStringAttribute(&quot;class&quot;);

        if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {

          // resource    相对路径

          ErrorContext.instance().resource(resource);
          InputStream inputStream = Resources.getResourceAsStream(resource);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          // 解析 Mapper.xml，总体上做了两件事情 &gt;&gt;
          mapperParser.parse();

        } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {

          // url    绝对路径

          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();

        } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
          // class     单个接口
          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
        }
      }
    }
  }
}
</code></pre><p>通过这段代码我们可以看到，无论是通过指定扫描包路径，还是resources相对路径，或者url绝对路径，或者单个Mapper添加的方式，Mybatis本质上都是通过 <strong>addMapper()方法添加到 MapperRegistry</strong>。</p>
<blockquote>
<p>继续回到Mapper代理对象创建过程中来。</p>
</blockquote>
<pre><code># org.apache.ibatis.session.Configuration#getMapper
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre><p>继续看mapperRegistry.getMapper方法逻辑。</p>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
  }
  try {
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
  }
}
</code></pre><p>我们发现，通过接口类型从HashMap中取到了一个 <strong>MapperProxyFactory</strong> Mapper代理工厂的实例。</p>
<blockquote>
<p>MapperProxyFactory实际上是对Mapper接口的包装，我们只需要看源码就知道了。</p>
</blockquote>
<pre><code>public class MapperProxyFactory&lt;T&gt; {

  private final Class&lt;T&gt; mapperInterface;
  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();
</code></pre><blockquote>
<p>构造方法接受一个Mapper的class类型，对其进行封装。</p>
</blockquote>
<pre><code>public MapperProxyFactory(Class&lt;T&gt; mapperInterface) {
  this.mapperInterface = mapperInterface;
}
</code></pre><p>获取到MapperProxyFactory实例之后，通过 <strong>mapperProxyFactory.newInstance(sqlSession)</strong> 就创建出了Mapper的代理对象。</p>
<pre><code>public T newInstance(SqlSession sqlSession) {
  final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
  return newInstance(mapperProxy);
}
</code></pre><p>这里通过SqlSession、Mapper接口、方法缓存（<strong>简单的说就是Mapper的那一堆方法，每次反射创建太耗费性能了，就缓存到一个Map里</strong>）创建出MapperProxy 对象，进一步调用的如下方法：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
  // 1：类加载器:2：被代理类实现的接口、3：实现了 InvocationHandler 的触发管理类
  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}
</code></pre><p>这里把创建代理对象的操作委托给了MapperProxy，<strong>我们发现，它的核心就是创建代理Mapper的代理对象 （h对象）。</strong></p>
<h3 id="MapperProxy具体是如何创建的Mapper代理？"><a href="#MapperProxy具体是如何创建的Mapper代理？" class="headerlink" title="MapperProxy具体是如何创建的Mapper代理？"></a>MapperProxy具体是如何创建的Mapper代理？</h3><p>我们都知道，动态代理在JDK中是通过实现InvocationHandler接口实现的，那么大胆猜想MapperProxy必然实现了InvocationHandler接口。</p>
<pre><code>public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {
</code></pre><p>果然如此。</p>
<p>我们来看它的invoke方法实现：</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    // toString hashCode equals getClass等方法，无需走到执行SQL的流程
    if (Object.class.equals(method.getDeclaringClass())) {
      return method.invoke(this, args);
    } else {
      // 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的 invoke
      // 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke
      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
    }
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }
}
</code></pre><p>可以看到，如果是普通方法，直接执行，不需要特殊处理；</p>
<p>否则就获取匹配的缓存Mapper方法，执行数据库操作。</p>
<blockquote>
<p>重点看一下  cachedInvoker(method).invoke(proxy, method, args, sqlSession); 逻辑。</p>
</blockquote>
<pre><code>private MapperMethodInvoker cachedInvoker(Method method) throws Throwable {
  try {

    // Java8 中 Map 的方法，根据 key 获取值，如果值是 null，则把后面Object 的值赋给 key
    // 如果获取不到，就创建
    // 获取的是 MapperMethodInvoker（接口） 对象，只有一个invoke方法

    return methodCache.computeIfAbsent(method, m -&gt; {
      if (m.isDefault()) {

        // 接口的默认方法(Java8)，只要实现接口都会继承接口的默认方法，例如 List.sort()

        try {
          if (privateLookupInMethod == null) {
            return new DefaultMethodInvoker(getMethodHandleJava8(method));
          } else {
            return new DefaultMethodInvoker(getMethodHandleJava9(method));
          }
        } catch (IllegalAccessException | InstantiationException | InvocationTargetException
            | NoSuchMethodException e) {
          throw new RuntimeException(e);
        }

      } else {

        // 创建了一个 MapperMethod
        return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));

      }
    });
  } catch (RuntimeException re) {
    Throwable cause = re.getCause();
    throw cause == null ? re : cause;
  }
}
</code></pre><p>这里针对Java8接口的默认方法做了些处理，这个地方不用特殊关注，我们重点看else逻辑：</p>
<pre><code>// 创建了一个 MapperMethod
return new PlainMethodInvoker(
    new MapperMethod(
      mapperInterface, 
      method,
      sqlSession.getConfiguration()));
</code></pre><h2 id="Mybatis执行sql语句的真正开端："><a href="#Mybatis执行sql语句的真正开端：" class="headerlink" title="Mybatis执行sql语句的真正开端："></a>Mybatis执行sql语句的真正开端：</h2><blockquote>
<p>上文中，我们费尽努力，获取到了 <strong>PlainMethodInvoker</strong> 实例，其实到这里，才是Mybatis执行SQL真正的起点。</p>
</blockquote>
<p>不要慌，继续跟上我的脚步，我们一鼓作气往后看。</p>
<p>上文中，我们知道Mapper对象实际上是Mapper接口的代理对象，而且是JDK的动态代理。</p>
<p>当执行Mapper的各种数据库操作方法时，实际上是调用的代理对象的方法，也就是invoke方法。</p>
<p>对于Mapper方法而言，其实就是调用的PlainMethodInvoker的invoke方法。</p>
<p>忘了？那么我们再复习一下这部分的代码：</p>
<pre><code>// org.apache.ibatis.binding.MapperProxy#invoke
// 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke
return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
</code></pre><p>接着来看PlainMethodInvoker的invoke方法：</p>
<pre><code>@Override
public Object invoke(
                    Object proxy, 
                    Method method, 
                    Object[] args, 
                    SqlSession sqlSession) throws Throwable {
  // SQL执行的真正起点
  return mapperMethod.execute(sqlSession, args);
}
</code></pre><p>实际上这里的mapperMethod就是我们Mapper接口或者说XML文件中定义的方法名了。</p>
<blockquote>
<p>接着就是重头戏，MapperMethod#execute 方法，完整代码我贴这儿了。</p>
</blockquote>
<pre><code>// org.apache.ibatis.binding.MapperMethod#execute
public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        // 普通 select 语句的执行入口 &gt;&gt;
        result = sqlSession.selectOne(command.getName(), param);
        if (method.returnsOptional()
            &amp;&amp; (result == null || !method.getReturnType().equals(result.getClass()))) {
          result = Optional.ofNullable(result);
        }
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
  }
  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
    throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName()
        + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
  }
  return result;
}
</code></pre><p>重点看那个switch case，不用注释一眼看过去基本上也能看个八九不离十，这里就是通过sql的类型去执行不同的jdbc操作。</p>
<blockquote>
<p>可以看到，熟悉的操作他来了，通过SqlSession完成一系列的数据库操作。</p>
</blockquote>
<p>我们的demo是一个查询操作，那么我们就挑select来看看。</p>
<p>普通select语句的入口如下：</p>
<pre><code>result = sqlSession.selectOne(command.getName(), param);
</code></pre><p>继续深入：</p>
<pre><code>// DefaultSqlSession#selectOne(java.lang.String, java.lang.Object)
@Override
public &lt;T&gt; T selectOne(String statement, Object parameter) {
  // 来到了 DefaultSqlSession
  // Popular vote was to return null on 0 results and throw exception on too many.
  List&lt;T&gt; list = this.selectList(statement, parameter);
  if (list.size() == 1) {
    return list.get(0);
  } else if (list.size() &gt; 1) {
    throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());
  } else {
    return null;
  }
}
</code></pre><p>可以看到是通过selectList来完成查询多个和单个。</p>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
  // 为了提供多种重载（简化方法使用），和默认值
  // 让参数少的调用参数多的方法，只实现一次
  return this.selectList(statement, parameter, RowBounds.DEFAULT);
}
</code></pre><p>继续看多参重载方法：</p>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    // 如果 cacheEnabled = true（默认），Executor会被 CachingExecutor装饰
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
</code></pre><p>核心代码就是executor.query，我们进去看看：</p>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
  BoundSql boundSql = ms.getBoundSql(parameter);
  // 一级缓存和二级缓存的CacheKey是同一个
  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
  return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
}
</code></pre><p>这里涉及到一级缓存和二级缓存，不是重点，我们就想看看最终是怎么执行的jdbc操作，那么就只需要继续看query重载。</p>
<pre><code>// org.apache.ibatis.executor.BaseExecutor#query
@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {

  // 异常体系之 ErrorContext
  ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());

  if (closed) {
    throw new ExecutorException(&quot;Executor was closed.&quot;);
  }

  if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
    // flushCache=&quot;true&quot;时，即使是查询，也清空一级缓存
    clearLocalCache();
  }

  List&lt;E&gt; list;
  try {

    // 防止递归查询重复处理缓存
    queryStack++;
    // 查询一级缓存
    // ResultHandler 和 ResultSetHandler的区别
    list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;

    if (list != null) {
      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
    } else {

      // 真正的查询流程
      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);

      ...省略N行代码...
</code></pre><p>涉及到缓存的，通通与我无关，只看真正的查询流程 <strong>queryFromDatabase</strong>。</p>
<pre><code>private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
  List&lt;E&gt; list;
  // 先占位
  localCache.putObject(key, EXECUTION_PLACEHOLDER);
  try {
    // 三种 Executor 的区别，看doUpdate
    // 默认Simple
    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
  } finally {
    // 移除占位符
    localCache.removeObject(key);
  }
  // 写入一级缓存
  localCache.putObject(key, list);
  if (ms.getStatementType() == StatementType.CALLABLE) {
    localOutputParameterCache.putObject(key, parameter);
  }
  return list;
}
</code></pre><h3 id="看到jdbc了，胜利的曙光。"><a href="#看到jdbc了，胜利的曙光。" class="headerlink" title="看到jdbc了，胜利的曙光。"></a>看到jdbc了，胜利的曙光。</h3><p>舒服，继续看doQuery方法，看到resultHandler了么，结果处理器，感觉离结果更近了。</p>
<pre><code>// org.apache.ibatis.executor.SimpleExecutor#doQuery
@Override
public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
  Statement stmt = null;
  try {
    Configuration configuration = ms.getConfiguration();
    // 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
    // 获取一个 Statement对象
    stmt = prepareStatement(handler, ms.getStatementLog());
    // 执行查询
    return handler.query(stmt, resultHandler);
  } finally {
    // 用完就关闭
    closeStatement(stmt);
  }
}
</code></pre><p>查询用的Exucutor就是默认的SimpleExecutor，看到了熟悉的prepareStatement获取流程，基本上就到底层jdbc了。那么我们就看看 <strong>prepareStatement(handler, ms.getStatementLog());</strong></p>
<pre><code>private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
  Statement stmt;
  Connection connection = getConnection(statementLog);
  // 获取 Statement 对象
  stmt = handler.prepare(connection, transaction.getTimeout());
  // 为 Statement 设置参数
  handler.parameterize(stmt);
  return stmt;
}
</code></pre><p>看到这里，就到jdbc层面了，我们看到了熟悉的Connection，获取到connection之后再获取Statement。</p>
<p>这里的Statement就是java.sql的statement接口。</p>
<blockquote>
<p>org.apache.ibatis.executor.statement.SimpleStatementHandler#query</p>
</blockquote>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
  String sql = boundSql.getSql();
  statement.execute(sql);
  return resultSetHandler.handleResultSets(statement);
}
</code></pre><p>已经获取到了sql，通过Statement去执行sql，在通过resultSetHandler处理结果集。</p>
<h4 id="通过Statement去执行sql"><a href="#通过Statement去执行sql" class="headerlink" title="通过Statement去执行sql"></a>通过Statement去执行sql</h4><pre><code>statement.execute(sql);
</code></pre><p>这里就已经是jdbc层面的操作了，通过与数据库建立的connection提交并执行sql。</p>
<h4 id="通过resultSetHandler处理结果集"><a href="#通过resultSetHandler处理结果集" class="headerlink" title="通过resultSetHandler处理结果集"></a>通过resultSetHandler处理结果集</h4><blockquote>
<p>都到最后了，我们也不慌了，那么就看看org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSets是如何处理结果集的。</p>
</blockquote>
<pre><code>@Override
public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
  ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

  final List&lt;Object&gt; multipleResults = new ArrayList&lt;&gt;();

  int resultSetCount = 0;
  ResultSetWrapper rsw = getFirstResultSet(stmt);

  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
  int resultMapCount = resultMaps.size();
  validateResultMapsCount(rsw, resultMapCount);
  while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
    ResultMap resultMap = resultMaps.get(resultSetCount);
    handleResultSet(rsw, resultMap, multipleResults, null);
    rsw = getNextResultSet(stmt);
    cleanUpAfterHandlingResultSet();
    resultSetCount++;
  }

  String[] resultSets = mappedStatement.getResultSets();
  if (resultSets != null) {
    while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
      if (parentMapping != null) {
        String nestedResultMapId = parentMapping.getNestedResultMapId();
        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
        // 在此处处理结果集
        handleResultSet(rsw, resultMap, null, parentMapping);
      }
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }
  }

  return collapseSingleResultList(multipleResults);
}
</code></pre><p>这么一坨代码，只需要重点看</p>
<pre><code>handleResultSet(rsw, resultMap, null, parentMapping);

private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException {
  try {
    if (parentMapping != null) {
      handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);
    } else {
      if (resultHandler == null) {
        DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);
        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);
        multipleResults.add(defaultResultHandler.getResultList());
      } else {
        handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);
      }
    }
  } finally {
    // issue #228 (close resultsets)
    closeResultSet(rsw.getResultSet());
  }
}
</code></pre><p>看看handleRowValues的逻辑 (有点心累)</p>
<p>最终，来到了这个地方：</p>
<pre><code>// org.apache.ibatis.executor.resultset.DefaultResultSetHandler
//         #handleRowValuesForSimpleResultMap
private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)
    throws SQLException {
  DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;&gt;();

  // 看到了吧，没什么好说的，就是jdbc的结果集处理
  ResultSet resultSet = rsw.getResultSet();

  skipRows(resultSet, rowBounds);
  while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) {
    ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);
    Object rowValue = getRowValue(rsw, discriminatedResultMap, null);
    storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);
  }
}
</code></pre><p>看到了熟悉的ResultSet获取结果集的操作，Mybatis执行sql的流程基本就结束了。</p>
<p>底层还是熟悉的JDBC操作。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实写了这么多，也没啥想总结的，我们通过一个查询操作，完整的把Mybatis从解析文件到执行sql，再到结果集处理都从源码级别剖析了一遍。</p>
<p>那么我们回答一下开头的问题：</p>
<h3 id="我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？"><a href="#我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？" class="headerlink" title="我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？"></a>我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？</h3><p>其实我们获取到的Mapper对象，已经是Mybatis帮我们生成的代理对象了，这个代理对象拥有与jdbc交互的一切必要条件。</p>
<h3 id="都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？"><a href="#都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？" class="headerlink" title="都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？"></a>都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？</h3><p>稍微往上翻翻，我们刚讲了，实际上最底层就是封装的jdbc的接口。</p>
<p>我们看不到但是用到了，并且用起来还很爽，这就是封装的魅力啊。</p>
<h3 id="为什么在Spring中使用Mybatis，不用加-Repository-Component之类的注解，就可以随用随注入（如：-Autowired）"><a href="#为什么在Spring中使用Mybatis，不用加-Repository-Component之类的注解，就可以随用随注入（如：-Autowired）" class="headerlink" title="为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?"></a>为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?</h3><p>这个问题，就放到之后的文章讲解吧，那么就敬请期待下一篇：Mybatis与Spring的爱情故事（从源码层面解析，Mybatis是如何利用Spring扩展点，实现与Spring整合的。）</p>
<p>最后，贴张图，概括一下这个过程。图是借来的，仅供学习讨论，侵删。</p>
<blockquote>
<p>创建会话工厂SqlSessionFactory</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/1.png" alt="flow/1.png"></p>
<blockquote>
<p>创建会话SqlSession</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/2.png" alt="flow/2.png"></p>
<blockquote>
<p>创建代理对象</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/3.png" alt="flow/3.png"></p>
<blockquote>
<p>调用代理对象，执行SQL流程</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/4.png" alt="flow/4.png"></p>
<p>那么，不见不散。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名Java后端开发者，尤其是国内开发者，从刚参加工作开始就与Mybatis打交道了。&lt;/p&gt;
&lt;p&gt;用了这么久的Mybatis难免会心生疑问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？&lt;/li&gt;
&lt;li&gt;都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？&lt;/li&gt;
&lt;li&gt;为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;硬核万字长文，点个再看，转发，多谢啦~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://wuwenliang.net/categories/Java/"/>
    
    
      <category term="Java" scheme="http://wuwenliang.net/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring扩展点1-研磨ImportBeanDefinitionRegistrar</title>
    <link href="http://wuwenliang.net/2022/01/29/Spring%E6%89%A9%E5%B1%95%E7%82%B91-%E7%A0%94%E7%A3%A8ImportBeanDefinitionRegistrar/"/>
    <id>http://wuwenliang.net/2022/01/29/Spring扩展点1-研磨ImportBeanDefinitionRegistrar/</id>
    <published>2022-01-29T03:05:41.000Z</published>
    <updated>2022-01-29T04:24:33.367Z</updated>
    
    <content type="html"><![CDATA[<p>本文开始，我们将系统地对Spring框架的扩展点进行学习，通过案例分析与图例结合，step by step地对Spring看似神秘的扩展点的机理与应用进行研究。</p>
<p>首先通过一张图对Spring框架各种扩展点的调用顺序（Bean生命周期）进行先入为主的概览。</p>
<p><img src="/2022/01/29/Spring扩展点1-研磨ImportBeanDefinitionRegistrar/0.png" alt="0.png"></p>
<a id="more"></a>
<p>可以看到图片的一开始便是Spring对Bean定义（BeanDefinition）进行解析和注册，Bean的注册主要就是通过ImportBeanDefinitionRegistrar实现的。</p>
<p>Spring框架主要就是通过ImportBeanDefinitionRegistrar实现对bean的动态注册。源码如下：</p>
<pre><code>public interface ImportBeanDefinitionRegistrar {
    // 通过解析给定的注解元信息，向Spring容器中注册Bean定义
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,
            BeanNameGenerator importBeanNameGenerator) {

        registerBeanDefinitions(importingClassMetadata, registry);
    }
    default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    }
}
</code></pre><p>实现ImportBeanDefinitionRegistrar接口的类的都会被ConfigurationClassPostProcessor处理，ConfigurationClassPostProcessor实现了BeanFactoryPostProcessor接口，所以ImportBeanDefinitionRegistrar中动态注册的bean是优先于依赖其的bean初始化的，同时它也可以被aop、validator等机制处理。</p>
<h2 id="编码实现手动Bean注入"><a href="#编码实现手动Bean注入" class="headerlink" title="编码实现手动Bean注入"></a>编码实现手动Bean注入</h2><blockquote>
<p>日常的业务开发中，我们很少会通过ImportBeanDefinitionRegistrar来对bean进行注入。</p>
<p>而是通过xml文件声明或者注解如：@Component、@Service、@Bean等方式对bean进行注入和声明。</p>
<p>那么什么场景下才需要通过ImportBeanDefinitionRegistrar注册并注入bean呢？</p>
</blockquote>
<p>在中间件开发场景下，就会用到手动bean注入。原因在于中间件/框架的开发者并不知道调用方/框架使用者是通过什么方式对bean进行注入的。</p>
<p>当然我们也可以让使用者们显式的对框架中的bean进行定义，但是这样就显著的增加了工作量和出错率，因此对于框架开发而言，常常通过ImportBeanDefinitionRegistrar实现bean的隐式注入和声明，减少调用方整合框架的复杂度。</p>
<blockquote>
<p>我们通过一个模拟场景来介绍一下如何通过编码实现bean的手动隐式注入。、</p>
</blockquote>
<h3 id="1、定义ImportBeanDefinitionRegistrar实现类"><a href="#1、定义ImportBeanDefinitionRegistrar实现类" class="headerlink" title="1、定义ImportBeanDefinitionRegistrar实现类"></a>1、定义ImportBeanDefinitionRegistrar实现类</h3><p>首先定义一个实现ImportBeanDefinitionRegistrar接口的类，并编写bean注册逻辑。</p>
<pre><code>public class MyBeanDefinationRegistry implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, BeanFactoryAware {

    private BeanFactory beanFactory;
    private ResourceLoader resourceLoader;

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }

    @Override
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

        MyClassPathBeanDefinitionScanner scanner = new MyClassPathBeanDefinitionScanner(registry, false);
        scanner.setResourceLoader(resourceLoader);
        scanner.registerFilters();
        scanner.doScan(&quot;com.spring.framework&quot;);

        GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
        genericBeanDefinition.setBeanClass(TestBean.class);
        genericBeanDefinition.setScope(BeanDefinition.SCOPE_SINGLETON);
        registry.registerBeanDefinition(&quot;testBean&quot;, genericBeanDefinition);
    }
}
</code></pre><p>重点关注 <strong>BeanDefinitionRegistry</strong> 方法，这里提供了两种bean扫描方式。</p>
<h4 id="方式1：基于包路径的扫描"><a href="#方式1：基于包路径的扫描" class="headerlink" title="方式1：基于包路径的扫描"></a>方式1：基于包路径的扫描</h4><pre><code>MyClassPathBeanDefinitionScanner scanner = 
    new MyClassPathBeanDefinitionScanner(registry, false);
scanner.setResourceLoader(resourceLoader);
scanner.registerFilters();
scanner.doScan(&quot;com.spring.framework&quot;);
</code></pre><ol>
<li>自定义一个ClassPathBeanDefinitionScanner实例，并将bean定义注册器BeanDefinitionRegistry引用传递进去，这是一种委托机制；</li>
<li>设置ResourceLoader，ResourceLoader的引用通过ResourceLoaderAware获得，并指向当前类的成员变量；</li>
<li>调用registerFilters方法（该方法为自定义方法，本质是调用了addIncludeFilter），让Spring去扫描带有特定标志的类进行管理与加载；（具体的代码稍后进行分析）；</li>
<li>调用doScan，传递需要扫描的包路径，这个路径就是框架开发者自定义的包路径，该路径下存放的就是框架本身的bean，<strong>这个路径是完全由框架的开发者决定的，而且我们一般可以认为，该路径一旦定义就不会更改。并且该路径也不适合暴露给框架的调用者</strong>。</li>
</ol>
<h4 id="方式2：直接注册BeanDefinition"><a href="#方式2：直接注册BeanDefinition" class="headerlink" title="方式2：直接注册BeanDefinition"></a>方式2：直接注册BeanDefinition</h4><pre><code>GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
genericBeanDefinition.setBeanClass(TestBean.class);
genericBeanDefinition.setScope(BeanDefinition.SCOPE_SINGLETON);
registry.registerBeanDefinition(&quot;testBean&quot;, genericBeanDefinition);
</code></pre><p>方式2比较简单，但是相对的也比方式1繁琐。</p>
<blockquote>
<p>TestBean 是模拟的一个框架的内部bean组件，实际开发中可以根据需要填充必要的属性和方法，这里只是作为演示。</p>
</blockquote>
<pre><code>public class TestBean {
}
</code></pre><p>通过声明GenericBeanDefinition，并未其添加需要注册的Bean的class，scope（单例or多例），beanName等属性，具体的属性可以看下图：</p>
<p><img src="/2022/01/29/Spring扩展点1-研磨ImportBeanDefinitionRegistrar/1,png" alt="1.png"></p>
<p>最后通过 <strong>registry.registerBeanDefinition</strong> 将设置好属性的GenericBeanDefinition注册，并设置beanName；</p>
<h4 id="对比方式1方式2"><a href="#对比方式1方式2" class="headerlink" title="对比方式1方式2"></a>对比方式1方式2</h4><p>通过代码我们可以直观的看到，方式1比方式2更加方便，可以实现批量bean的扫描与注入；</p>
<p>而方式2则需要逐个bean进行注入，但是相对的，方式2也更加灵活，能够实现 <strong>细粒度</strong> 的beanDefinition声明和定义。</p>
<h3 id="2、定义ClassPathBeanDefinitionScanner实现类"><a href="#2、定义ClassPathBeanDefinitionScanner实现类" class="headerlink" title="2、定义ClassPathBeanDefinitionScanner实现类"></a>2、定义ClassPathBeanDefinitionScanner实现类</h3><p>通过定义ClassPathBeanDefinitionScanner的实现类，告诉Spring需要对哪些类进行管理（addIncludeFilter）以及不需要关注哪些类（addExcludeFilter）。</p>
<pre><code>public class MyClassPathBeanDefinitionScanner extends ClassPathBeanDefinitionScanner {

    public MyClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {
        super(registry, useDefaultFilters);
    }

    /**
    * 比较重要的一个点就是registerFilters()这个方法，
    * 在里面我们可以定义让Spring去扫描带有特定标志的类选择进行管理或者是选择不管理；
    * 通过addIncludeFilter()方法和通过addExcludeFilter()方法；
    */
    protected void registerFilters() {
        /**
        *  TODO addIncludeFilter  满足任意includeFilters会被加载
        */
        addIncludeFilter(new AnnotationTypeFilter(SnoWalkerAutoInject.class));
    }

    @Override
    protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
        return super.doScan(basePackages);
    }
}
</code></pre><p>可以看到，扫描器ClassPathBeanDefinitionScanner扫描类路径上的需要被管理的类，通过BeanFactory创建Bean给ApplicationComtext(Spring容器)管理；</p>
<h4 id="registerFilters分析"><a href="#registerFilters分析" class="headerlink" title="registerFilters分析"></a>registerFilters分析</h4><p>registerFilters是自定义的方法，核心的逻辑就是通过addIncludeFilter添加了一个包扫描的规则：</p>
<p>这里是通过注解类型的Filter通知Spring容器对添加了SnoWalkerAutoInject自定义注解的bean进行管理。</p>
<p>我们可以看到，自定义的MyClassPathBeanDefinitionScanner重写了父类的doScan方法，本质上调用了父类的doScan，以实现对指定路径下的bean进行扫描。</p>
<p>最终实际上是在ApplicationContext中调用了doScan，实现了对bean定义的扫描及实例化，我们可以看一下源码实现：</p>
<pre><code>/**
 * Create a new AnnotationConfigApplicationContext, scanning for components
 * in the given packages, registering bean definitions for those components,
 * and automatically refreshing the context.
 * @param basePackages the packages to scan for component classes
 */
public AnnotationConfigApplicationContext(String... basePackages) {
    this();
    scan(basePackages);
    refresh();
}
</code></pre><p>AnnotationConfigApplicationContext构造方法中，对package进行了扫描，并调用refresh方法对bean进行初始化和实例化。</p>
<h3 id="3、自定义注解"><a href="#3、自定义注解" class="headerlink" title="3、自定义注解"></a>3、自定义注解</h3><p>自定义注解，并添加到需要装载到Spring容器中的框架类上：</p>
<pre><code>@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER})
public @interface SnoWalkerAutoInject {
}
</code></pre><p>定义几个模拟的框架类，用以模拟框架的逻辑。实际的开发中，我们可以按照需求的实际需要，开发框架代码，并标记自定义的注解。</p>
<pre><code>@SnoWalkerAutoInject
public class FrameWorkConfigA {

    public FrameWorkConfigA() {
        System.out.println(&quot;自定义框架组件A-初始化逻辑&quot;);
    }
}

@SnoWalkerAutoInject
public class FrameWorkConfigB {

    public FrameWorkConfigB() {
        System.out.println(&quot;自定义框架组件B-初始化逻辑&quot;);
    }
}

@SnoWalkerAutoInject
public class FrameWorkConfigC {

    public FrameWorkConfigC() {
        System.out.println(&quot;自定义框架组件C-初始化逻辑&quot;);
    }
}
</code></pre><h3 id="4、配置ImportBeanDefinitionRegistrar实现类"><a href="#4、配置ImportBeanDefinitionRegistrar实现类" class="headerlink" title="4、配置ImportBeanDefinitionRegistrar实现类"></a>4、配置ImportBeanDefinitionRegistrar实现类</h3><p>如何使用自定义的ImportBeanDefinitionRegistrar实现类对bean进行装载呢？</p>
<p>最终我们还是需要定义一个配置类，通过@Import注解配置ImportBeanDefinitionRegistrar实现。</p>
<pre><code>@Configuration
@Import(MyBeanDefinationRegistry.class)
@ComponentScan(&quot;com.spring.framework&quot;)
public class MyConf {
}
</code></pre><ol>
<li>MyConf是自定义的配置类，标注了 @Configuration 注解。</li>
<li>通过@Import将实现了ImportBeanDefinitionRegistrar接口的MyBeanDefinationRegistry包含进来；</li>
<li>添加扫描包，以方便spring对该包下的类进行扫描并进行选择性的装载；</li>
</ol>
<h3 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h3><p>编写测试类：</p>
<pre><code>public class App {

    public static void main(String[] args) {
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(&quot;com.spring&quot;);

        final TestBean testBean = (TestBean) applicationContext.getBean(&quot;testBean&quot;);
        System.out.println(testBean.getClass());
    }
}
</code></pre><ol>
<li>首先我们声明并初始化一个AnnotationConfigApplicationContext容器；</li>
<li>接着从容器中通过BeanName获取通过GenericBeanDefinition定义的TestBean实例，打印其Class类型；</li>
<li>观察日志输出，期望能够看到框架代码FrameWorkConfigA、FrameWorkConfigB、FrameWorkConfigC的构造方法日志打印，并看到TestgBean的Class类型打印。</li>
</ol>
<p>运行测试类，观察控制台日志输出：</p>
<pre><code>自定义框架组件A-初始化逻辑
自定义框架组件B-初始化逻辑
自定义框架组件C-初始化逻辑

class com.spring.TestBean
</code></pre><p>可以看到符合预期，这表明，通过ImportBeanDefinitionRegistrar自定义手动bean注入符合预期。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们全篇对ImportBeanDefinitionRegistrar在Spring容器装载bean的过程进行了综述，并通过一个模拟框架开发的案例，对如何通过ImportBeanDefinitionRegistrar实现bean的自定义注入进行了代码级别的讲解和分析。</p>
<p>如果在实际的开发案例中需要实现自定义的bean注入，减少调用方整合的复杂度，那么我们完全可以通过本文讲解的方式，利用ImportBeanDefinitionRegistrar扩展点实现。</p>
<h2 id="下期预告："><a href="#下期预告：" class="headerlink" title="下期预告："></a>下期预告：</h2><p>下期我们将分析讲解BeanPostProcessor扩展点在Spring框架中的作用，并讲解BeanPostProcessor在实战开发中的使用。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文开始，我们将系统地对Spring框架的扩展点进行学习，通过案例分析与图例结合，step by step地对Spring看似神秘的扩展点的机理与应用进行研究。&lt;/p&gt;
&lt;p&gt;首先通过一张图对Spring框架各种扩展点的调用顺序（Bean生命周期）进行先入为主的概览。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/29/Spring扩展点1-研磨ImportBeanDefinitionRegistrar/0.png&quot; alt=&quot;0.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring扩展点" scheme="http://wuwenliang.net/categories/Spring%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    
    
      <category term="Spring扩展点" scheme="http://wuwenliang.net/tags/Spring%E6%89%A9%E5%B1%95%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>归于平静，甘于平凡</title>
    <link href="http://wuwenliang.net/2021/12/31/%E5%BD%92%E4%BA%8E%E5%B9%B3%E9%9D%99%EF%BC%8C%E7%94%98%E4%BA%8E%E5%B9%B3%E5%87%A1/"/>
    <id>http://wuwenliang.net/2021/12/31/归于平静，甘于平凡/</id>
    <published>2021-12-31T14:54:57.000Z</published>
    <updated>2021-12-31T15:15:12.686Z</updated>
    
    <content type="html"><![CDATA[<p>题诗：</p>
<pre><code>不要温和地走进那良夜，
老年应当在日暮时燃烧咆哮；
怒斥，怒斥光明的消逝。
虽然智慧的人临终时懂得黑暗有理，
因为他们的话没有迸发出闪电，他们
也并不温和地走进那个良夜。
善良的人，当最后一浪过去，高呼他们脆弱的善行
可能曾会多么光辉地在绿色的海湾里舞蹈，
怒斥，怒斥光明的消逝。
狂暴的人抓住并歌唱过翱翔的太阳，
懂得，但为时太晚，他们使太阳在途中悲伤，
也并不温和地走进那个良夜。
严肃的人，接近死亡，用炫目的视觉看出
失明的眼睛可以像流星一样闪耀欢欣，
怒斥，怒斥光明的消逝。
您啊，我的父亲．在那悲哀的高处．
现在用您的热泪诅咒我，祝福我吧．我求您
不要温和地走进那个良夜。
怒斥，怒斥光明的消逝。
</code></pre><p>平常的日子，地球又一次完成了它伟大的公转，于是，一年又过去。</p>
<p>往年每逢公历年的末尾，总是会像写故事一样，洋洋洒洒的罗列自己一年来达成的目标，嗟叹一番未完成的事情，然后立下当时自信能够在接下来一年<br>能够完成的flag，最后再下一次所谓年终总结中，继续这个循环。</p>
<p>这次，我承认我又不能免俗的继续写这个所谓的“年终总结”。只是觉得，如果不写的话，我将又丢掉一个本就少的可怜的习惯。</p>
<p>仅仅是出于习惯，我写给自己。</p>
<p>总得找个主题，这一年，复杂，我想不出别的词来概括我的一年，下意识的想到了复杂。</p>
<p>这是一个男孩变成所谓男人的故事，经历很多，结婚，生子，跳槽，网暴，写书…..太多的事情，让你变得急躁。</p>
<p>做加法容易，做减法难。</p>
<p>着急地想要做完这件事，奔赴下一件事；</p>
<p>从一个孩子变为一个父亲，只觉得，脚步都变得不同往常。</p>
<p>从此不是为了自己而活，一切的美好语言比不上陪伴二字。</p>
<p>感谢妻的辛苦，感谢父母的照顾，感谢陪伴。</p>
<p>经历的事情确实很多，但此时的心态却不同往常，往日肯定会大篇幅的去逐个罗列，然后写上一段所谓心得。这都是过去式了。</p>
<p>要向前看。</p>
<p>活着，生活着，努力生活着，就很满足了。</p>
<p>于是我想到了八个字，归于平静，甘于平凡。</p>
<p>事情太多，加法做太多，心情变得急躁，于是什么都想要，于是总会计较得失。</p>
<p>来年，接下来的日子里，要学会做减法，断舍离，关注重要的，忽略次要的，要接受自己是一个普通人的事实，不虚妄，不浮夸。</p>
<p>甘于平凡，修身修心，过好平常的每天，陪伴身边的人。</p>
<p>不炫耀，不盲从，负责任，扮演好每个需要扮演的角色，不逾矩。</p>
<p>不再立虚无的目标，学会衡量承诺的重量。</p>
<p>感谢过去的自己，做好现在的自己，迎接更好的自己。</p>
<p>迎接更好的2022。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题诗：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;不要温和地走进那良夜，
老年应当在日暮时燃烧咆哮；
怒斥，怒斥光明的消逝。
虽然智慧的人临终时懂得黑暗有理，
因为他们的话没有迸发出闪电，他们
也并不温和地走进那个良夜。
善良的人，当最后一浪过去，高呼他们脆弱的善行
可能曾会多么光辉地
    
    </summary>
    
      <category term="年度总结" scheme="http://wuwenliang.net/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年度总结" scheme="http://wuwenliang.net/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>RocksDB了解一下？</title>
    <link href="http://wuwenliang.net/2021/07/22/Rocksdb%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F/"/>
    <id>http://wuwenliang.net/2021/07/22/Rocksdb了解一下？/</id>
    <published>2021-07-22T14:55:04.000Z</published>
    <updated>2021-07-22T15:50:39.863Z</updated>
    
    <content type="html"><![CDATA[<p>项目中需要实现高效的IO操作，不仅支持查询、写入数据，还需要实现数据的持久化。选型最终选择了RocksDB，那么本文就来一睹RocksDB的芳容。</p>
<h2 id="RocksDB是什么？"><a href="#RocksDB是什么？" class="headerlink" title="RocksDB是什么？"></a>RocksDB是什么？</h2><blockquote>
<p>RocksDB是Facebook开发的一款高效的数据库软件，是采用C++编写而成的。</p>
</blockquote>
<p>RocksDB是一款key-value型数据存储设施，具备四个特点，其具有四大特点。</p>
<p><strong>高性能</strong>：RocksDB使用一套C++编写而成的高性能日志结构的数据库引擎。 它的Key和value支持任意大小的字节流。</p>
<p><strong>可适配性</strong>：RocksDB适合于多种不同工作场景。从像MyRocks这样的数据存储引擎到应用数据缓存, 甚至是嵌入式工作场景，RocksDB都可以从容面对这些不同的数据工作需求。</p>
<p><strong>为快速存储而优化</strong>：RocksDB为快速而又低延迟的存储设备（例如闪存或者高速硬盘）进行了特殊优化处理，将最大限度发挥闪存和RAM的高度率读写性能。</p>
<p><strong>基础和高级的数据库操作</strong>：RocksDB提供了一些基础的操作，例如打开和关闭数据库。它对于合并、压缩、过滤等高级操作，也提供了支持。</p>
<p>如果对RocksDB感兴趣，可以去读它的源码，地址为：<a href="https://github.com/facebook/rocksdb" target="_blank" rel="external">https://github.com/facebook/rocksdb</a></p>
<h2 id="在Java工程中使用RocksDB"><a href="#在Java工程中使用RocksDB" class="headerlink" title="在Java工程中使用RocksDB"></a>在Java工程中使用RocksDB</h2><p>如何在Java工程中使用RocksDB呢？</p>
<p>首先建立一个maven工程，在pom.xml中引入RocksDB依赖：</p>
<pre><code>&lt;!-- https://mvnrepository.com/artifact/org.rocksdb/rocksdbjni --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.rocksdb&lt;/groupId&gt;
    &lt;artifactId&gt;rocksdbjni&lt;/artifactId&gt;
    &lt;version&gt;6.20.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>接着我们通过一个demo尝试在Java中使用RocksDB。</p>
<h3 id="初始化RocksDB"><a href="#初始化RocksDB" class="headerlink" title="初始化RocksDB"></a>初始化RocksDB</h3><pre><code>private RocksDB rocksDB;

private String path = &quot;D:/rocksdb&quot;;

public RocksDBDemo() {
    RocksDB.loadLibrary();
    Options options = new Options();
    options.setCreateIfMissing(true);
    try {
        rocksDB = RocksDB.open(options, path);
    } catch (RocksDBException e) {
        e.printStackTrace();
    }
}

public RocksDB rocksDB() {
    return this.rocksDB;
}
</code></pre><p>首先指定一个路径用于创建RocksDB的log文件：rocksdb写入时，直接以append方式写到log文件以及memtable，随即返回，因此非常快速。</p>
<p>接着通过RocksDB.loadLibrary();导入库，然后设置Options，并打开rocksDB，此时成员变量rocksDB就可以拿来进行操作了。</p>
<h3 id="RocksDB读写"><a href="#RocksDB读写" class="headerlink" title="RocksDB读写"></a>RocksDB读写</h3><pre><code>RocksDBDemo rocksDBDemo = new RocksDBDemo();
RocksDB rocksDB = rocksDBDemo.rocksDB();
// 写入
rocksDB.put(&quot;name&quot;.getBytes(), &quot;snowalker&quot;.getBytes());
// 读取
byte[] bytes = rocksDB.get((&quot;name&quot;.getBytes()));
System.out.println(&quot;读取结果:&quot; + new String(bytes));

// 遍历
RocksIterator iter = rocksDB.newIterator();
for (iter.seekToFirst();iter.isValid();iter.next()) {
    System.out.println(&quot;iter key: &quot; + new String(iter.key()) + &quot;,iter value: &quot; +
            new String(iter.value()));
}
</code></pre><p>RocksDBDemo是我们的测试类名，首先获取rocksDB引用，然后调用put，get方法进行读写操作。</p>
<p>其中put方法签名为：</p>
<pre><code>public void put(final byte[] key, final byte[] value)
    throws RocksDBException {
    put(nativeHandle_, key, 0, key.length, value, 0, value.length);
}
</code></pre><p>get方法签名为：</p>
<pre><code>public byte[] get(final byte[] key) throws RocksDBException {
    return get(nativeHandle_, key, 0, key.length);
}
</code></pre><p>通过rocksDB.newIterator()可以获取迭代器，借助迭代器能够执行迭代操作，这里是读取了一下key与value。</p>
<h3 id="rocksDB的write操作"><a href="#rocksDB的write操作" class="headerlink" title="rocksDB的write操作"></a>rocksDB的write操作</h3><p>rocksdb的一个WriteBatch是原子操作，要么全部成功，要么全部失败，</p>
<blockquote>
<p>具体的实现原理是在整个log的写的过程中只会调用Write操作，最后会调用一次flush，所以如果中间发生机器crash，所有的都会失败，否则所有的都会成功。</p>
</blockquote>
<p>看一段实际代码：</p>
<pre><code>// write batch test
try (final WriteOptions writeOpt = new WriteOptions()) {
    for (int i = 0; i &lt;= 10; ++i) {
        try (final WriteBatch batch = new WriteBatch()) {
            for (int j = 0; j &lt;= 10; ++j) {
                batch.put(String.format(&quot;%d * %d%s&quot;, i, j, &quot;--batch&quot;).getBytes(),
                        String.format(&quot;%d&quot;, i * j).getBytes());
            }
            rocksDB.write(writeOpt, batch);
        }
    }
}
</code></pre><p>这里实际上将乘法表写入了rocksDB。</p>
<p>运行代码，观察目录D:/rocksdb中出现了以下文件：</p>
<p><img src="/2021/07/22/Rocksdb了解一下？/1.PNG" alt="1.PNG"></p>
<p>简单对这几种文件进行讲解：</p>
<p>我们可以从后缀看出：主要有这几种类型</p>
<ul>
<li>sst文件</li>
<li>CURRENT文件</li>
<li>manifest文件</li>
<li>log文件</li>
<li>LOG文件和LOCK文件</li>
</ul>
<p>其中</p>
<ol>
<li>sst文件存储的是落地的数据</li>
<li>CURRENT文件存储的是当前最新的是哪个manifest文件</li>
<li>manifest文件存储的是Version的变化</li>
<li>log文件是rocksdb的write ahead log，就是在写db之前写的数据日志文件，类似binlog</li>
<li>LOG文件是一些日志信息，是供调试用的</li>
<li>LOCK是打开db锁，只允许同时有一个进程打开db</li>
</ol>
<p>这里我们重点看一下log文件中的内容，由于写入的byte，可能有乱码。</p>
<p><img src="/2021/07/22/Rocksdb了解一下？/2.PNG" alt="2.PNG"></p>
<p>从图中可以看到，实际上是顺序写入了我们在代码中设置的key-value。</p>
<h2 id="解释一下rocksdb的flush操作"><a href="#解释一下rocksdb的flush操作" class="headerlink" title="解释一下rocksdb的flush操作"></a>解释一下rocksdb的flush操作</h2><p>Flush是指将memtable的数据导入到sst中，变成持久化存储，从而不必担心数据丢失了。</p>
<pre><code>1.首先在memtable的add的时候，
会检测是否memtable的大小达到了max write buffer，
如果是就将should_flush_置为true，
并会在WriteBatch的Handler里面调用CheckMemtableFull，
将当前column family加入flush_scheduler。

2.在Write的时候，调用ScheduleFlushes，
将需要flush的column family的memtable切换一个新的，
同时将原来的memtable加入cfd的imm中，
如果这个column family data的imm数量大于min_write_buffer_number_to_merge，
并启动一个新的线程调用BGWorkFlush

由于真正的Flush过程是在另一个线程完成的，所以这个地方并不会block写过程
</code></pre><h2 id="rocksDB的WAL（write-ahead-log）"><a href="#rocksDB的WAL（write-ahead-log）" class="headerlink" title="rocksDB的WAL（write ahead log）"></a>rocksDB的WAL（write ahead log）</h2><p>rocksdb的write ahead log（WAL）是指：<br>每次写操作，rocksdb会先写write ahead log，然后才会写db<br>write ahead log可以配置到单独的空间，并且可以配置WAL文件的单独的删除机制。</p>
<p>这种原因是为了保存WAL文件，达到特殊的目的，比如，其他sst文件放在不可靠存储里面，而WAL放到可靠存储里面。</p>
<p>对RocksDB 的写操作而言，每次都必写到两个地方：</p>
<ol>
<li>基于内存的数据结构memtable（达到quota 后会flush 至SST file）。</li>
<li>预写日志-Write Ahead Log（WAL）。<br>如果出现异常情况，WAL 可以用来完整恢复memtable 中的数据，恢复db 的原有的状态。</li>
</ol>
<p>默认配置下，RocksDB 通过每次用户写之后flush WAL，来保证进程crash 后的一致性。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们主要对rocksDB做了一个了解和学习，一般来说，使用它的目的在于高性能的写入，实现数据的快速持久化。</p>
<p>业界不乏优秀的中间件底层依赖了rocksDB，如TiDB。</p>
<p>###</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中需要实现高效的IO操作，不仅支持查询、写入数据，还需要实现数据的持久化。选型最终选择了RocksDB，那么本文就来一睹RocksDB的芳容。&lt;/p&gt;
&lt;h2 id=&quot;RocksDB是什么？&quot;&gt;&lt;a href=&quot;#RocksDB是什么？&quot; class=&quot;headerli
    
    </summary>
    
      <category term="专题-分布式" scheme="http://wuwenliang.net/categories/%E4%B8%93%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="专题-分布式" scheme="http://wuwenliang.net/tags/%E4%B8%93%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
