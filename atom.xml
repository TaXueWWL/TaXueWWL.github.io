<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝·闻·道</title>
  <subtitle>SnoWalker&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wuwenliang.net/"/>
  <updated>2022-10-26T16:56:23.313Z</updated>
  <id>http://wuwenliang.net/</id>
  
  <author>
    <name>SnoWalker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Aeron-CookBook学习之路-Agrona Agents与空闲策略Idle Strategies</title>
    <link href="http://wuwenliang.net/2022/10/26/Aeron-CookBook%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-Agrona%E4%BB%A3%E7%90%86%E4%B8%8E%E7%A9%BA%E9%97%B2%E7%AD%96%E7%95%A5/"/>
    <id>http://wuwenliang.net/2022/10/26/Aeron-CookBook学习之路-Agrona代理与空闲策略/</id>
    <published>2022-10-26T15:30:22.000Z</published>
    <updated>2022-10-26T16:56:23.313Z</updated>
    
    <content type="html"><![CDATA[<p>在2006 年，爱德华·李 （Edward A. Lee） 撰写了一篇题为“线程中的问题”的技术报告。 在技术报告中，他有以下说法：</p>
<blockquote>
<p>线程，是非常不确定的一种计算模型。而程序员的工作就是要修剪这种不确定性。 </p>
<p>尽管许多技术研究通过提供更加有效的裁减措施来改进线程模型，但我（爱德华本人）认为这是在开倒车。 </p>
<p>我们应该从本质上构建确定性的、可组合的组件，而不是去裁减这种非确定性。 </p>
<p>应该在需要的时候明确并且明智地引入非确定性，而不是在不需要它的地方将其删除。</p>
</blockquote>
<p>对于Aeron而言，Agrona Agents（Agrona代理） 和 Idle Strategies（空闲策略） 是实现爱德华的建议的一种实现方式。</p>
<p>当与 Aeron 一起使用时，Agrona Agents允许基于开发人员以易于推理的方式，安全地构建确定性的资源，从而管理线程。</p>
<h1 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a>Agents</h1><p><strong>Agrona Agents是在应用程序逻辑中执行的，具备工作周期的容器。</strong></p>
<p>例如处理 Aeron 中订阅的消息。 </p>
<p>Agents的工作周期间隔和CPU消耗地增加，由空闲策略进行控制。 Agents可以调度在专用的线程上，当然也可以作为一组复合Agents（a composite group of agents）的一部分在单个线程上运行。</p>
<p>典型的Agents工作周期是通过轮询Agents的 doWork 函数实现的，一旦doWork方法返回零，就会回调选中的空闲策略，代码逻辑如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public final class Sample implements Agent</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    public int doWork()</div><div class="line">    &#123;</div><div class="line">        int workCount = 0;</div><div class="line">        workCount += dutyCyclePart1();</div><div class="line">        workCount += dutyCyclePart2();</div><div class="line">        return workCount;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Yielding-Idle-Strategy-（空闲让步策略）"><a href="#Yielding-Idle-Strategy-（空闲让步策略）" class="headerlink" title="Yielding Idle Strategy （空闲让步策略）"></a>Yielding Idle Strategy （空闲让步策略）</h2><blockquote>
<p>下面这段代码是 Yielding Idle Strategy （中译为：空闲让步策略）的关键部分，它展示了对workCount值进行校验的关键逻辑模板。如果 workCount 结果小于等于零，则Agents线程将由“运行态Running”转为就绪态“Runnable”，让渡cpu时间片供自己及其余同优先级线程进行时间片抢占。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public final class YieldingIdleStrategy implements IdleStrategy </div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    public void idle(int workCount) &#123;</div><div class="line">        if (workCount &lt;= 0) &#123;</div><div class="line">            Thread.yield();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着这些 Agent 和 IdleStrategy 会在 AgentRunner 中组合在一起，代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class AgentRunner implements Runnable, AutoCloseable</div><div class="line">&#123;</div><div class="line">...</div><div class="line">    public void run()</div><div class="line">    &#123;</div><div class="line">    ...</div><div class="line">        // 当线程运行态</div><div class="line">        while (isRunning)</div><div class="line">        &#123;</div><div class="line">            // 执行工作周期的逻辑</div><div class="line">            doDutyCycle(idleStrategy, agent);</div><div class="line">        &#125;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void doDutyCycle(final IdleStrategy idleStrategy, final Agent agent)</div><div class="line">    &#123;</div><div class="line">    ...</div><div class="line">        // 执行agent的doWork方法，即业务逻辑</div><div class="line">        final int workCount = agent.doWork();</div><div class="line">        // 根据返回值决定是否要进行执行空闲策略</div><div class="line">        idleStrategy.idle(workCount);</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Idle-Strategies（空闲策略）"><a href="#Idle-Strategies（空闲策略）" class="headerlink" title="Idle Strategies（空闲策略）"></a>Idle Strategies（空闲策略）</h2><p>Agrona 提供了一系列默认的空闲策略，但是如果以后需要，开发者很容易实现自定义的空闲策略。</p>
<p>默认空闲策略及其解释如下：</p>
<ul>
<li><p>SleepingIdleStrategy（休眠空闲策略）： 通过使用 parkNanos 将线程阻塞在给定的时间段内实现休眠；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void idle(int workCount) &#123;</div><div class="line">    if (workCount &lt;= 0) &#123;</div><div class="line">        LockSupport.parkNanos(this.sleepPeriodNs);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>SleepingMillisIdleStrategy（另一种休眠空闲策略）：这是基于thread.sleep(millseconds)方法实现的在某个给定时间段内使线程阻塞的空闲策略。 <strong>适用于在低规格机器上进行本地开发或者在运行了大量进程的机器上使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void idle(int workCount) &#123;</div><div class="line">    if (workCount &lt;= 0) &#123;</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(this.sleepPeriodMs);</div><div class="line">        &#125; catch (InterruptedException var3) &#123;</div><div class="line">            Thread.currentThread().interrupt();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>YieldingIdleStrategy（让步空闲策略）：使用 thread.yield 来让出线程控制权的策略，在上文我们已经专门解释过；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void idle(int workCount) &#123;</div><div class="line">    if (workCount &lt;= 0) &#123;</div><div class="line">        Thread.yield();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>BackoffIdleStrategy（退避空闲策略）： 这是一种<strong>激进的策略</strong>，它的机制为先是自旋，然后过渡到让步，然后再过渡到阻塞在可进行配置的纳秒时间内的一种复合策略。 <strong>这是 Aeron Cluster 的默认策略</strong>。可以看到它的idle()方法是随着运行不断升级空闲处理策略的（是不是类似synchronized锁膨胀）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public void idle() &#123;</div><div class="line">    switch (this.state) &#123;</div><div class="line">        case 0:</div><div class="line">            this.state = 1;</div><div class="line">            // 进入自旋逻辑</div><div class="line">            ++this.spins;</div><div class="line">            break;</div><div class="line">        case 1:</div><div class="line">            // 自旋</div><div class="line">            ThreadHints.onSpinWait();</div><div class="line">            if (++this.spins &gt; this.maxSpins) &#123;</div><div class="line">                this.state = 2;</div><div class="line">                this.yields = 0L;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        case 2:</div><div class="line">            // 让步cpu</div><div class="line">            if (++this.yields &gt; this.maxYields) &#123;</div><div class="line">                this.state = 3;</div><div class="line">                this.parkPeriodNs = this.minParkPeriodNs;</div><div class="line">            &#125; else &#123;</div><div class="line">                Thread.yield();</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        case 3:</div><div class="line">            // 阻塞</div><div class="line">            LockSupport.parkNanos(this.parkPeriodNs);</div><div class="line">            this.parkPeriodNs = Math.min(this.parkPeriodNs &lt;&lt; 1, this.maxParkPeriodNs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>NoOpIdleStrategy：这是目前可用的最激进的空闲策略。顾名思义，什么操作都不做，也就是根本不会空闲。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void idle(int workCount) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void idle() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>BusySpinIdleStrategy: 这将调用 java.lang.Thread.onSpinWait()方法。 这个策略在Java 9+版本的JVM运行时可用。 它向 CPU 提供了一个微弱的标识：如果线程处于一个循环中并且正忙于等待某个操作，那么CPU可能会在不执行OS系统级调度的前提下将额外的资源分配给另一个线程。（也就是CPU会对这种处于循环忙等的线程进行资源调度，分配资源给其他线程）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void idle(int workCount) &#123;</div><div class="line">    if (workCount &lt;= 0) &#123;</div><div class="line">        ThreadHints.onSpinWait();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// org.agrona.hints.ThreadHints#onSpinWait</div><div class="line">public static void onSpinWait() &#123;</div><div class="line">    if (null != ON_SPIN_WAIT_METHOD_HANDLE) &#123;</div><div class="line">        try &#123;</div><div class="line">            ON_SPIN_WAIT_METHOD_HANDLE.invokeExact();</div><div class="line">        &#125; catch (Throwable var1) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现自定义空闲策略"><a href="#实现自定义空闲策略" class="headerlink" title="实现自定义空闲策略"></a>实现自定义空闲策略</h3><p>如果你想要实现自定义空闲策略，则只需要实现 IdleStrategy 接口，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface IdleStrategy &#123;</div><div class="line">    void idle(int count);</div><div class="line">    void idle();</div><div class="line">    void reset();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Scheduling-Agents（代理调度机制）"><a href="#Scheduling-Agents（代理调度机制）" class="headerlink" title="Scheduling Agents（代理调度机制）"></a>Scheduling Agents（代理调度机制）</h3><p>如果要开启Agent的生命周期，那么你需要决定如何对它进行调度。</p>
<ul>
<li>你可以让Agent在 Agrona 提供的一个线程上运行；</li>
<li>你也可以提供一个线程工厂（thread factory）来运行你的Agent；</li>
<li>您可以从一组Agent（a collection of agents）中构造一个 CompositeAgent，然后你就可以将这些Agent作为一个调度单元进行调度。</li>
</ul>
<blockquote>
<p><strong>注意:</strong> 并不是所有的空闲策略都是线程安全的。因此通常我们建议为每个被调度的Agent制定不同的空闲策略。（专策略专用）</p>
</blockquote>
<p>一旦你已经决定了如何执行一个Agent，那么就可以使用 Agent Runner 启动它。</p>
<p>下面是代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">final AgentRunner runner =</div><div class="line">      new AgentRunner(idleStrategy, errorHandler, errorCounter, agent);</div><div class="line">AgentRunner.startOnThread(runner);</div></pre></td></tr></table></figure>
<p>构造一个AgentRunner实例，构造参数中，</p>
<ul>
<li>idleStrategy可以设置为上述任何空闲策略之一，</li>
<li>最后一个参数为一个Agent引用实例。 </li>
<li>errorHandler（错误处理器）通常会接受字符串，并捕获引发的错误。</li>
<li>errorCounter（错误计数器）用于计算该Agent引发的错误。 </li>
</ul>
<p>最后通过调用AgentRunner.startOnThread 告诉 Agrona 将Agent调度在一个新线程上。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此我们就基本了解了Aeron中的Agrona Agent及其空闲策略的分类及基本使用，如果需要进一步学习，请自行参考完整代码示例：<a href="https://aeroncookbook.com/aeron-cookbook/ipc/" target="_blank" rel="external">https://aeroncookbook.com/aeron-cookbook/ipc/</a></p>
<h3 id="复习：java线程生命周期"><a href="#复习：java线程生命周期" class="headerlink" title="复习：java线程生命周期"></a>复习：java线程生命周期</h3><blockquote>
<p>最后我们一起简单复习一下Java中线程的生命周期，温故知新。</p>
</blockquote>
<ul>
<li><p>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new Thread();</p>
</li>
<li><p>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
</li>
<li><p>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就     绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
</li>
<li><p>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<ul>
<li><p>等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；</p>
</li>
<li><p>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
</li>
<li><p>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</p>
</li>
</ul>
</li>
<li><p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</p>
</li>
</ul>
<h2 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a>下一篇</h2><p>频道，流，以及会话 （Channels, Streams and Sessions）</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>本文原文链接：<a href="https://aeroncookbook.com/agrona/agents-idle-strategies/" target="_blank" rel="external">https://aeroncookbook.com/agrona/agents-idle-strategies/</a></p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在2006 年，爱德华·李 （Edward A. Lee） 撰写了一篇题为“线程中的问题”的技术报告。 在技术报告中，他有以下说法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程，是非常不确定的一种计算模型。而程序员的工作就是要修剪这种不确定性。 &lt;/p&gt;
&lt;p&gt;尽管许多技
    
    </summary>
    
      <category term="Aeron" scheme="http://wuwenliang.net/categories/Aeron/"/>
    
    
      <category term="Aeron" scheme="http://wuwenliang.net/tags/Aeron/"/>
    
  </entry>
  
  <entry>
    <title>Aeron CookBook学习之路-MediaDriver概览</title>
    <link href="http://wuwenliang.net/2022/10/25/Aeron-CookBook%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-MediaDriver%E6%A6%82%E8%A7%88/"/>
    <id>http://wuwenliang.net/2022/10/25/Aeron-CookBook学习之路-MediaDriver概览/</id>
    <published>2022-10-25T14:38:17.000Z</published>
    <updated>2022-10-25T15:50:10.791Z</updated>
    
    <content type="html"><![CDATA[<p>本文我们重点介绍Aeron核心组件中的Media Driver（媒体驱动）。、</p>
<p>在继续之前，读者应该熟悉代理和空闲策略部分。由于我们是按照顺序进行学习，因此关于代理与空闲策略（Agents &amp; Idle Strategies），将在下一篇文章讲解。</p>
<h2 id="什么是Media-Driver"><a href="#什么是Media-Driver" class="headerlink" title="什么是Media Driver"></a>什么是Media Driver</h2><p>Media Driver （媒体驱动程序） 组件负责管理通过UDP 或 IPC（这两种方式我们成为Media）发送和接收数据，用于任何活动的发布和/或订阅场景。</p>
<p>Media Driver很灵活，它可以通过修改配置以适应大多数场景，包括但不限于：具有很小延迟的高性能场景，乃至对资源要求极为宽松的低资源环境。 </p>
<p>虽然Media Driver在概念上类似于分布式消息代理（消息队列的broker，比如kafka、RocketMQ的broker组件），但它缺少一些broker所具备的功能。 因此最好将 Aeron 的Media Driver与消息代理broker区别对待（但是可以类比进行理解）。</p>
<p>下图显示了构成嵌入在应用程序中的Media Driver的核心组件。</p>
<p>图</p>
<blockquote>
<p>可以看到，发布与订阅均借助Media Driver实现，而Media Driver之间通过Media进行通讯（UDP或者IPC）</p>
</blockquote>
<h2 id="Media-Driver核心组件解析"><a href="#Media-Driver核心组件解析" class="headerlink" title="Media Driver核心组件解析"></a>Media Driver核心组件解析</h2><h3 id="Driver-Conductor（驱动协调器）"><a href="#Driver-Conductor（驱动协调器）" class="headerlink" title="Driver Conductor（驱动协调器）"></a>Driver Conductor（驱动协调器）</h3><p>Driver Conductor 接受来自 Aeron 客户端内发布者和订阅者的命令，并协调Media Driver的操作。此外，Driver Conductor 还负责名字解析任务（类比域名解析）；</p>
<h3 id="Receiver（接收器）"><a href="#Receiver（接收器）" class="headerlink" title="Receiver（接收器）"></a>Receiver（接收器）</h3><p>Receiver管理连接Media Driver的所有数据接收过程。数据传输轮询器（Data Transport Poller）接收 UDP 数据，并使用 Java NIO 与操作系统的网络栈进行交互。</p>
<p>除了从媒体（IPC/UDP）接收数据外，Receiver还管理接收到的images（快照），根据需要发送 NAK 和状态消息。</p>
<h3 id="Sender（发送器）"><a href="#Sender（发送器）" class="headerlink" title="Sender（发送器）"></a>Sender（发送器）</h3><p>发送者管理媒体（IPC/UDP）上的数据传输。</p>
<h3 id="Client-Conductor（客户端协调器）"><a href="#Client-Conductor（客户端协调器）" class="headerlink" title="Client Conductor（客户端协调器）"></a>Client Conductor（客户端协调器）</h3><p>Client Conductor负责与Driver Conductor进行通信。</p>
<h2 id="Media-Driver目录结构"><a href="#Media-Driver目录结构" class="headerlink" title="Media Driver目录结构"></a>Media Driver目录结构</h2><blockquote>
<p>对于生产环境而言，Media Driver目录文件夹应位于 <strong>\dev\shm</strong> 路径下。 您需要确保文件系统有足够的存储空间来存储所有镜像（images）和发布内容。 </p>
<p>有关更多详细信息，请参阅 发布和订阅 （<a href="https://aeroncookbook.com/aeron/publications-subscriptions/#implications-on-devshm）。" target="_blank" rel="external">https://aeroncookbook.com/aeron/publications-subscriptions/#implications-on-devshm）。</a></p>
</blockquote>
<p>图</p>
<p>上图中展示了一个Media Driver文件夹，其中打开了一个 IPC 发布内容。 Media Driver文件夹包含以下内容：</p>
<ul>
<li>blank.template：它是一个空的日志缓冲区文件，对于一个新的发布过程具备复制支持</li>
<li>cnc.dat： 这是在 Aeron 客户端和Media Driver之间共享的 命令-控制内存映射文件。 同时它也是 AeronStat 读取的 Aeron 计数器的所在位置。</li>
<li>images (文件夹)    ：此文件夹包含所有远程发布的打开镜像（image）</li>
<li>loss-report.dat：该文件存储了 Aeron 丢包的所有详细信息。 对于了解一段时间内的网络行为很有用。 LossStat 工具用于读取它的内容。</li>
<li>Publications（文件夹）：此文件夹包含所有打开的发布日志缓冲区。</li>
</ul>
<h2 id="配置和运行时部署选项"><a href="#配置和运行时部署选项" class="headerlink" title="配置和运行时部署选项"></a>配置和运行时部署选项</h2><p>Media Driver可以嵌入在进程中运行或在进程外运行。 当进程用完时，您可以使用 Java 或 C 版本的Media Driver。</p>
<p>除了Media Driver，在 Aeron源代码中还发现了另外两个变体：</p>
<ul>
<li>LowLatencyMediaDriver：在示例文件夹中可以找到，它使用低延迟的最佳设置来设置MediaDriver</li>
<li>JavaTestMediaDriver：在测试文件夹中可以找到。通过引入损失能力设置MediaDriver</li>
</ul>
<h2 id="Media-Driver线程模式"><a href="#Media-Driver线程模式" class="headerlink" title="Media Driver线程模式"></a>Media Driver线程模式</h2><p>在Media Driver中选择正确的资源分配，应当考虑进程中可用的资源和性能要求。</p>
<p>如果将超出可用资源的资源过度分配给 Aeron 进程可能对应用程序的稳定性和性能非常不利。（系统资源需要对Aeron进行合理分配）</p>
<h3 id="Dedicated模式（适用于线上环境or资源充足的环境中）"><a href="#Dedicated模式（适用于线上环境or资源充足的环境中）" class="headerlink" title="Dedicated模式（适用于线上环境or资源充足的环境中）"></a>Dedicated模式（适用于线上环境or资源充足的环境中）</h3><p>在专用线程模式（ThreadingMode.DEDICATED）下，Media Driver 将使用 3 个线程，每个线程都有特定的空闲策略：</p>
<ul>
<li>Sender线程（使用 senderIdleStrategy策略）；</li>
<li>Receiver线程（使用receiverIdleStrategy策略）；</li>
<li>Driver Conductor线程（使用conductorIdleStrategy策略）。</li>
</ul>
<p>这是默认的线程模式，最好在关注性能且系统有足够资源的场景下使用。</p>
<p>如果要进一步提高性能，请将线程绑定（pin）到特定的 CPU 核心上。</p>
<h3 id="Shared-Network模式（折中场景）"><a href="#Shared-Network模式（折中场景）" class="headerlink" title="Shared Network模式（折中场景）"></a>Shared Network模式（折中场景）</h3><p>运行在Shared Network模式下(ThreadingMode.SHARED_NETWORK) 将线程数减少到两个：</p>
<ul>
<li>Sender 和 Receiver 被安排在一个复合代理中（ [sender-receiver线程]，使用 sharedNetworkIdleStrategy策略）；</li>
<li>Driver Conductor（driver-conductor线程，使用conductorIdleStrategy策略）</li>
</ul>
<h3 id="Shared模式（适合开发及资源较少场景）"><a href="#Shared模式（适合开发及资源较少场景）" class="headerlink" title="Shared模式（适合开发及资源较少场景）"></a>Shared模式（适合开发及资源较少场景）</h3><p>运行在共享模式 (ThreadingMode.SHARED) 下，将线程数减少到一个。</p>
<p>复合代理托管了 Sender、Receiver 和 Conductor 代理。 </p>
<p>这可以看作是线程dump中的 [sender-receiver-driver-conductor]线程，并利用了 Media Driver Context 中定义的 sharedIdleStrategy策略。 这最适合开发或运行在可用资源较少的运行环境中。</p>
<h3 id="扩展：C-Media-Driver"><a href="#扩展：C-Media-Driver" class="headerlink" title="扩展：C Media Driver"></a>扩展：C Media Driver</h3><p>通过用 C 语言编写Media Driver，Real Logic 可以尽可能多地控制Media Driver运行的硬件和操作系统，并且它允许团队从 Java 虚拟机和垃圾收集器中删除对性能敏感的组件。</p>
<p>从 Java 方面来看，使用 C Media Driver通常是透明的。 开发者所需要做的就是将自己的 Aeron 客户端指向 C Media Driver 的文件夹，理论上，一切都会像以前一样工作。</p>
<p>与在独立模式下运行的 Java Media Driver一样，如果多个 Aeron 客户端都在同一台物理机器上，C Media Driver可以与它们一起运行。</p>
<h3 id="获取-C-Media-Driver"><a href="#获取-C-Media-Driver" class="headerlink" title="获取 C Media Driver"></a>获取 C Media Driver</h3><p>C 媒体驱动程序必须从源代码构建（因操作系统而异）：</p>
<p><a href="https://aeroncookbook.com/cookbook-content/build-macos-cpp-driver/" target="_blank" rel="external">https://aeroncookbook.com/cookbook-content/build-macos-cpp-driver/</a></p>
<p><a href="https://aeroncookbook.com/cookbook-content/build-ubuntu-cpp-driver/" target="_blank" rel="external">https://aeroncookbook.com/cookbook-content/build-ubuntu-cpp-driver/</a></p>
<p><a href="https://aeroncookbook.com/cookbook-content/build-windows-cpp-driver/" target="_blank" rel="external">https://aeroncookbook.com/cookbook-content/build-windows-cpp-driver/</a></p>
<p>构建完成会同时构建几个 C语言 版本的 Aeron Sample Tools（AeronStat、ErrorStat、LossStat）。</p>
<h3 id="配置-C-Media-Driver"><a href="#配置-C-Media-Driver" class="headerlink" title="配置 C Media Driver"></a>配置 C Media Driver</h3><p>默认情况下，C 媒体驱动程序运行需要以下条件： </p>
<ul>
<li>具有繁忙自旋线程（busy spin thread）优先级的三个线程（sender, receiver, driver conductor线程）</li>
<li>十秒驱动程序超时</li>
<li>16mb缓冲区长度。</li>
</ul>
<p>如果需要覆盖设置，通常有两个选择：</p>
<ul>
<li>从文件或 URL 加载参数</li>
<li>使用 -D 参数（与 Java 中相同）通过命令行传入参数，将 .更换为 _。例如<ul>
<li>-Daeron.driver.timeout=30000 （C版本的支持点号）</li>
<li>-Daeron_driver_timeout=30000（java版本的传参不支持点号）</li>
</ul>
</li>
</ul>
<h2 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a>下一篇</h2><p>代理与空闲策略 （<a href="https://aeroncookbook.com/agrona/agents-idle-strategies/）" target="_blank" rel="external">https://aeroncookbook.com/agrona/agents-idle-strategies/）</a></p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文我们重点介绍Aeron核心组件中的Media Driver（媒体驱动）。、&lt;/p&gt;
&lt;p&gt;在继续之前，读者应该熟悉代理和空闲策略部分。由于我们是按照顺序进行学习，因此关于代理与空闲策略（Agents &amp;amp; Idle Strategies），将在下一篇文章讲解。&lt;/
    
    </summary>
    
      <category term="Aeron" scheme="http://wuwenliang.net/categories/Aeron/"/>
    
    
      <category term="Aeron" scheme="http://wuwenliang.net/tags/Aeron/"/>
    
  </entry>
  
  <entry>
    <title>Aeron CookBook学习之路-aeron概览</title>
    <link href="http://wuwenliang.net/2022/10/25/Aeron-CookBook%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-aeron%E6%A6%82%E8%A7%88/"/>
    <id>http://wuwenliang.net/2022/10/25/Aeron-CookBook学习之路-aeron概览/</id>
    <published>2022-10-25T13:38:34.000Z</published>
    <updated>2022-10-26T15:30:37.789Z</updated>
    
    <content type="html"><![CDATA[<p>本系列基于Aeron cookbook编写，通过对原版英文文档进行翻译，加入笔者的一些思考，努力为Aeron提供一份可参考可阅读的中文参考资料。</p>
<p>话不多说，开始我们的学习之旅。</p>
<h1 id="1-Aeron是什么"><a href="#1-Aeron是什么" class="headerlink" title="1.Aeron是什么"></a>1.Aeron是什么</h1><p>Aeron是一个开源高性能消息传输机制(单向)，它支持高效可靠的UDP单播、UDP多播和IPC消息传输。</p>
<p>Aeron 以可预测的延迟，有效地跨进程或跨网络边界复制有序日志缓冲区。<br>Aeron API 提供了三个主要交互点 </p>
<ol>
<li>Media Driver 媒体驱动程序</li>
<li>Publications  发布</li>
<li>Subscriptions 订阅</li>
</ol>
<blockquote>
<p>Media Driver 当前支持通过 UDP 和 IPC 进行传输。 </p>
<p>UDP套接字交互可以卸载到 Open Onload，如果必要的驱动程序和硬件可供使用，</p>
</blockquote>
<p>除了核心 IPC 和 UDP 功能外，Aeron 还提供：</p>
<ul>
<li>Aeron Archive，它为流提供磁盘支持的存储</li>
<li>Aeron Cluster，允许开发人员构建基于 RAFT 协议的容错服务</li>
</ul>
<blockquote>
<p><strong>思考</strong>：<br>由于Aeron天然支持RAFT协议，并且具备高性能的消息处理能力，因此多使用在金融交易领域，它同时提供了高性能和高可靠的特性。（事实上，Aeron正是real-logic开发的，该团队的另一款代表作disruptor在金融高频交易场景被大规模应用，其超高性能超低延时得到了业界的普遍赞誉。）</p>
<p>从这里也可以想到，Aeron本身属于有状态服务的范畴，所以学习曲线、开发曲线、运维难度都高于传统的无状态服务框架； </p>
</blockquote>
<h1 id="2-Aeron架构"><a href="#2-Aeron架构" class="headerlink" title="2.Aeron架构"></a>2.Aeron架构</h1><p>Media Driver 和 Aeron 客户端 API 构成了 Aeron 的核心。</p>
<p>Aeron Archive 和 Aeron Cluster 添加其他组件，如<a href="https://aeroncookbook.com/aeron-archive/overview/" target="_blank" rel="external">存档概览</a>和<a href="https://aeroncookbook.com/aeron-cluster/overview/" target="_blank" rel="external">集群概览</a>中所述。</p>
<p>图</p>
<h2 id="基本代码案例"><a href="#基本代码案例" class="headerlink" title="基本代码案例"></a>基本代码案例</h2><blockquote>
<p>下面是一个完整的跨IPC发送消息的方法。 </p>
<p>为了让它尽可能简单，发布者和订阅者在同一个线程上——但这在现实世界的应用程序中是没有意义的。 </p>
<p>尽管如此，它还是很有用的，因为它显示了最小 Aeron 应用程序的完整设置。</p>
<p>该代码可以在 Aeron-ipc 项目的 SimplestCase.java 文件中找到。</p>
</blockquote>
<p>作为示例的一部分，我们将构建 4 个部分：</p>
<ul>
<li>Aeron API；</li>
<li>Media Driver 媒体驱动程序；</li>
<li>a Subscription; 一个发布者</li>
<li>a Publication 一个订阅者</li>
</ul>
<h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class AeronSimpleDemo &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String channel = &quot;aeron:ipc&quot;;</div><div class="line">        String message = &quot;this is a new Message.&quot;;</div><div class="line">        IdleStrategy idleStrategy = new SleepingIdleStrategy();</div><div class="line">        UnsafeBuffer unsafeBuffer = new UnsafeBuffer(ByteBuffer.allocate(256));</div><div class="line"></div><div class="line">        try (</div><div class="line">                MediaDriver driver = MediaDriver.launch();</div><div class="line">                Aeron aeron = Aeron.connect();</div><div class="line">                Subscription sub = aeron.addSubscription(channel, 10);</div><div class="line">                Publication pub = aeron.addPublication(channel, 10);</div><div class="line">        ) &#123;</div><div class="line">            while (!pub.isConnected()) &#123;</div><div class="line">                // 连接失败，阻塞</div><div class="line">                idleStrategy.idle();</div><div class="line">            &#125;</div><div class="line">            unsafeBuffer.putStringAscii(0, message);</div><div class="line">            System.out.println(&quot;sending:&quot; + message);</div><div class="line">            // 尝试发布</div><div class="line">            while (pub.offer(unsafeBuffer) &lt; 0) &#123;</div><div class="line">                idleStrategy.idle();</div><div class="line">            &#125;</div><div class="line">            FragmentHandler handler = ((buffer, offset, length, header) -&gt; &#123;</div><div class="line">                System.out.println(&quot;received:&quot; + buffer.getStringAscii(offset));</div><div class="line">            &#125;);</div><div class="line">            while (sub.poll(handler, 1) &lt;= 0) &#123;</div><div class="line">                idleStrategy.idle();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sending:this is a new Message.</div><div class="line">received:this is a new Message.</div></pre></td></tr></table></figure>
<h2 id="代码剖析"><a href="#代码剖析" class="headerlink" title="代码剖析"></a>代码剖析</h2><h3 id="参数构造"><a href="#参数构造" class="headerlink" title="参数构造"></a>参数构造</h3><p>首先进行参数构造，主要是这几行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String channel = &quot;aeron:ipc&quot;;</div><div class="line">String message = &quot;this is a new Message.&quot;;</div><div class="line">IdleStrategy idleStrategy = new SleepingIdleStrategy();</div><div class="line">UnsafeBuffer unsafeBuffer = new UnsafeBuffer(ByteBuffer.allocate(256));</div></pre></td></tr></table></figure>
<ul>
<li>第 1 行指定 Aeron 发布者和订阅者进行通信的通道。这是使用 Aeron URL 方案定义的，本示例中的通道为IPC 通道。另请参阅有关频道配置的 Aeron Wiki   <a href="https://github.com/real-logic/aeron/wiki/Channel-Configuration" target="_blank" rel="external">https://github.com/real-logic/aeron/wiki/Channel-Configuration</a></li>
<li>第 2 行指定发布者要发送的消息内容。</li>
<li>第 3 行指定要使用的空闲策略，在本例中是 SleepingIdleStrategy，该策略将线程停顿 1 微秒（默认）。</li>
<li>第 4 行提供了一个堆外缓冲区，该缓冲区（UnsafeBuffer）是不安全的缓冲区，它主要用来保存要发送的消息。为简单起见，我们为它分配了 256 个字节，当然，这个大小是可以调整的。</li>
</ul>
<p>另请参阅：<a href="https://aeroncookbook.com/agrona/agents-idle-strategies/" target="_blank" rel="external">代理和空闲策略-Agents &amp; Idle Strategies</a></p>
<h3 id="构造Aeron对象"><a href="#构造Aeron对象" class="headerlink" title="构造Aeron对象"></a>构造Aeron对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try (</div><div class="line">        MediaDriver driver = MediaDriver.launch();</div><div class="line">        Aeron aeron = Aeron.connect();</div><div class="line">        Subscription sub = aeron.addSubscription(channel, 10);</div><div class="line">        Publication pub = aeron.addPublication(channel, 10);</div></pre></td></tr></table></figure>
<p>这几行代码创建了用于发送和接收数据的关键Aeron对象。</p>
<ul>
<li>第 1 行创建媒体驱动程序（MediaDriver）。 Media Driver负责所有的IPC和网络活动，后面会详细讨论</li>
<li>第 2 行创建 Aeron 对象。这是应用程序中用于与 Aeron 交互的主要 API</li>
<li>第 3 行创建消息的订阅者，用于轮询接收消息</li>
<li>第 4 行创建消息发布者，用于消息的发布</li>
</ul>
<p>另请参阅：<a href="https://aeroncookbook.com/aeron/media-driver/" target="_blank" rel="external">媒体驱动程序-Media Driver</a></p>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1.           while (!pub.isConnected()) &#123;</div><div class="line">                // 连接失败，阻塞</div><div class="line">2.              idleStrategy.idle();</div><div class="line">3.            &#125;</div><div class="line">4.            unsafeBuffer.putStringAscii(0, message);</div><div class="line">5.            System.out.println(&quot;sending:&quot; + message);</div><div class="line">6.            // 尝试发布</div><div class="line">7.            while (pub.offer(unsafeBuffer) &lt; 0) &#123;</div><div class="line">8.                idleStrategy.idle();</div><div class="line">9.           &#125;</div></pre></td></tr></table></figure>
<p>这些代码行负责发布消息。 </p>
<p>首先，应用程序等待发布者（Subscription）达到连接状态。 当连接成功之后，将消息写入不安全缓冲区（unsafeBuffer），最后将缓冲区提供给发布者。 </p>
<p>下面对关键代码行进行解释：</p>
<ul>
<li>仅在连接建立成功后，第 1 行（pub.isConnected()）才返回 true。 这是在一个while循环中轮询的过程，每个循环操作之间有1微秒的暂停，直到连接成功（底层代码为LockSupport.park实现的）。</li>
<li>第 7 行（pub.offer(unsafeBuffer) &lt; 0）为发布者提供了缓冲区，发布者通过offer方法将message发布出去。 当返回的值小于零时，某种机制会阻止发布者往缓冲区写入数据。 空闲策略再次轮询直到发布者可以继续写入缓冲区。</li>
</ul>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.            FragmentHandler handler = ((buffer, offset, length, header) -&gt; &#123;</div><div class="line">2.                System.out.println(&quot;received:&quot; + buffer.getStringAscii(offset));</div><div class="line">3.            &#125;);</div><div class="line">4.            while (sub.poll(handler, 1) &lt;= 0) &#123;</div><div class="line">5.                idleStrategy.idle();</div><div class="line">6.            &#125;</div></pre></td></tr></table></figure>
<p>代码的最后一部分负责接受来自订阅的消息。 </p>
<p>首先，声明一个 FragmentHandler 用于接受消息，然后订阅者持续进行轮询，直到 Aeron将消息传递过来。</p>
<p>下面对关键行进行分析：</p>
<ul>
<li>第 1-2 行构造了 FragmentHandler。 在这个场景下，我们知道它是一个简单的小消息体，因此我们使用了最基本的FragmentHandler来接受消息。 如果消息体比较大，那么可以使用FragmentAssembler重新组装消息。</li>
<li>第 4 行轮询数据订阅。 与发布过程一样，poll的返回值若等于或小于零表明没有收到消息，则以微秒空闲时间进行轮询。</li>
</ul>
<h2 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a>下一篇</h2><p><a href="https://aeroncookbook.com/aeron/media-driver/" target="_blank" rel="external">Aeron-CookBook学习之路-MediaDriver概述</a></p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列基于Aeron cookbook编写，通过对原版英文文档进行翻译，加入笔者的一些思考，努力为Aeron提供一份可参考可阅读的中文参考资料。&lt;/p&gt;
&lt;p&gt;话不多说，开始我们的学习之旅。&lt;/p&gt;
&lt;h1 id=&quot;1-Aeron是什么&quot;&gt;&lt;a href=&quot;#1-Aeron
    
    </summary>
    
      <category term="Aeron" scheme="http://wuwenliang.net/categories/Aeron/"/>
    
    
      <category term="Aeron" scheme="http://wuwenliang.net/tags/Aeron/"/>
    
  </entry>
  
  <entry>
    <title>当代中式软件开发现状之我见-这就是敏捷？</title>
    <link href="http://wuwenliang.net/2022/07/20/%E4%B8%AD%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%B0%E7%8A%B6%E4%B9%8B%E6%88%91%E8%A7%81-%E8%BF%99%E5%B0%B1%E6%98%AF%E6%95%8F%E6%8D%B7%EF%BC%9F/"/>
    <id>http://wuwenliang.net/2022/07/20/中式软件开发现状之我见-这就是敏捷？/</id>
    <published>2022-07-20T13:44:38.000Z</published>
    <updated>2022-07-20T15:48:41.184Z</updated>
    
    <content type="html"><![CDATA[<p>历史的车轮滚滚向前，当代互联网也早已过了而立之年。</p>
<p>各种优秀的理念，各种优秀的实践，提出，兴起，推广，衰落。你方唱罢我登场。</p>
<p>而这其中，最为人津津乐道的当属–敏捷开发。</p>
<h2 id="唠一唠敏捷"><a href="#唠一唠敏捷" class="headerlink" title="唠一唠敏捷"></a>唠一唠敏捷</h2><p>2001年，当时软件领域的多位大佬在一起开了个会，大家聊得很开心，各种理念碰撞交汇，意趣相投，相见恨晚。</p>
<p>于是这几位好朋友在一起把讨论的结果总结为一份“敏捷宣言”。寥寥数语，包含4条价值观和12条原则，奠定了敏捷开发的基调。</p>
<h3 id="12条原则"><a href="#12条原则" class="headerlink" title="12条原则"></a>12条原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">我们遵循以下原则：</div><div class="line">01.我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。</div><div class="line">02.欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。</div><div class="line">03.经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。</div><div class="line">04.业务人员和开发人员必须相互合作，项目中的每一天都不例外。</div><div class="line">05.激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。</div><div class="line">06.不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。</div><div class="line">07.可工作的软件是进度的首要度量标准。</div><div class="line">08.敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。</div><div class="line">09.坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。</div><div class="line">10.以简洁为本，它是极力减少不必要工作量的艺术。</div><div class="line">11.最好的架构、需求和设计出自自组织团队。</div><div class="line">12.团队定期地反思如何能提高成效，并依此调整自身的举止表现。</div></pre></td></tr></table></figure>
<p>是的，我承认贴上宣言的内容是为了占篇幅的，你可以直接跳过，这样我的歉意也会少一些。</p>
<p>但是我仍旧想让你看一下它的四条价值观的内容。</p>
<h3 id="4条价值观"><a href="#4条价值观" class="headerlink" title="4条价值观"></a>4条价值观</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</div><div class="line"></div><div class="line">  个体和互动高于流程和工具</div><div class="line"></div><div class="line">  工作的软件高于详尽的文档</div><div class="line"></div><div class="line">  客户合作高于合同谈判</div><div class="line"></div><div class="line">  响应变化高于遵循计划</div><div class="line"></div><div class="line">也就是说，尽管右项有一定的价值，我们更重视左项的价值。</div></pre></td></tr></table></figure>
<p>寥寥数语，道出了敏捷的核心价值。</p>
<ul>
<li>流程和工具固然重要，但作为工具而言他们的目的在于调动个体，提升成员间的互动；</li>
<li>文档详尽对加深理解和解释清楚问题而言的确意义非凡，但是能够交付可工作的软件才是更高目的；</li>
<li>开会，沟通，交流，是弄明白需求的重要步骤，这其中不免发生博弈，大概率会出现观点的交锋，刁难，疑问，甚至情绪化。但是不同角色间的合作更为重要，围绕着解决问题本身触发的交流才是更为有价值的交流，而这种善意的交流也体现了团队价值和尊重；</li>
<li>只要有需求，先聊排期，先列计划。这是避免犯错、把控节奏的有效措施，但是变化会导致计划调整，变化会使得计划失效，拥抱变化不仅仅是裁员时候才反复强调的口号，更应当在平时的工作中体现出来，它不是一种“恐吓”，它应该是一种人文关怀。</li>
</ul>
<h2 id="那么中式敏捷团队的特点是什么？"><a href="#那么中式敏捷团队的特点是什么？" class="headerlink" title="那么中式敏捷团队的特点是什么？"></a>那么中式敏捷团队的特点是什么？</h2><p>中式软件开发团队，尤其是互联网开发团队，喜欢吸收年轻血液，乐于引入先进的经验和实践。这是好事。</p>
<p>于是我们看到，看板用起来了，泳道列出来了，迭代跑起来了，站会也开起来了。</p>
<p>工作开始，第一件事，每日站会，大家机械式的发言，我今天要做ABCD这几件事，如果精力足够，我将继续做EFGH这几件事；</p>
<p>进入工作状态，又一个需求过来了，哦，天哪，这是啥，没听过啊。看看多会儿要，wow，产品说要倒排，明天就评审，今天就得给排期。</p>
<p>只能硬着头皮用经验去估计了，没办法，咱也没参与需求讨论，咱也没参与预评审，但是我们是一个敏捷的团队。敏捷的团队从来都是扁平化的，每个人都是资源池中的一个可自由调度的资源，轮到你做就得你做，当仁不让。</p>
<p>一天时间了解下需求背景，产品说发布时间是两周后，那就是说还有10个人日的时间，开发3天，单侧1.5天，联调1天，测试3天，预发1.5天。</p>
<p>先这么排吧，你问为啥单测要1.5天？我只能说这叫经验。</p>
<p>我们采用了业界领先的TDD模式，要编写完善的测试用例，指令覆盖率要达到90%以上，分支覆盖率要达到70%以上。</p>
<blockquote>
<p>这都是套话，实际上是因为你不得不写这么多用例，否则代码提交都提交不上去，流水线直接卡住你。到时候耽误了代码合并，影响提测，就等着复盘吧。<br>关于复盘，也是一个有意思的事情，我们下一篇文章再说。</p>
</blockquote>
<p>吭哧吭哧写了一通设计文档，编码，单测写了一通，又自然地迎来了敏捷开发团队的每日必修课：晚会站会。</p>
<p>此时，看板出场了。</p>
<p>看板里，井井有条地罗列着A B C D E … 等一堆事项，每个事项下又有着1 2 3 4 5…个任务。每个开发像勤劳的蚂蚁一样，将任务从一个泳道，搬到了另一个泳道，并战战兢兢地在任务进度上了小心翼翼地增加了若干百分比。</p>
<p>会议上，所有参与者挨个介绍着自己所负责任务的进度，嗯，一片和谐。</p>
<p>看啊，多么精干的敏捷团队，多么高效的工作方式。</p>
<blockquote>
<p>听啊，这件事情和我有多少关系？这个百分比有多少可信度？<br>哎呀，又有一个会要参加了<br>得嘞，饭点儿快到了。</p>
</blockquote>
<p>我们不禁提问，这样的节奏是敏捷的么？这样的team是敏捷的么？</p>
<p>相信你自有答案在心中。</p>
<h2 id="用了看板-jira-站会就是敏捷了？"><a href="#用了看板-jira-站会就是敏捷了？" class="headerlink" title="用了看板/jira/站会就是敏捷了？"></a>用了看板/jira/站会就是敏捷了？</h2><p>这里其实是一个哲学问题，神与形的边界在哪里。</p>
<p>哲学里有一个“忒休斯之船”的概念，说的是有一艘叫做“忒休斯”的木船，工人们每天更换一个船上的零件，日复一日，直到有一日，船上最后一个零件被更换掉了。</p>
<p>那么问题是，此时这艘船，还是忒休斯吗？</p>
<p>我们说，在水手的心中，它还是忒休斯。</p>
<p>人有其魂，船有其神。</p>
<p>这艘的信念和意志不灭，于是在水手的心中，忒休斯永存。</p>
<p>将目光收回，我们问，是否用了看板/jira/站会，乃至所谓TDD，就是在实践敏捷开发了？</p>
<p>明确回答，不是。</p>
<p>敏捷宣言的价值观中，有这样一条</p>
<blockquote>
<p>个体和互动高于流程和工具</p>
</blockquote>
<p>如果仅仅是引入了工具链，即便再先进，投入的资源再多，也不过是流于表面。</p>
<p>真正的敏捷是要调用个体之间的互动，而这种互动必然是良性的，平等的，没有信息差的，友好共享的。</p>
<p>你知道我在说什么。</p>
<p>于是我们可以多聊几句，我们聊聊层级官僚制，或者说科层制。</p>
<p>科层制在人类发展中，被认为是最为理性的组织结构。</p>
<p>一个理想的科层制架构，命令从上往下，层层传达，职责层层系分，每一层的人都知道自己要干什么，井井有条。像是一个精密的仪器，永不出错。</p>
<p>这里我只说几句，毕竟这个话题不能聊深。</p>
<p>我想说的是，在传统的zz领域和传统实体行业，科层制尚存在低效、长臂管辖、信息丢失等现象，试问在讲究效率与变化的互联网/IT行业，它就能保证不出查错，高效运转吗？</p>
<p>我想，没有人敢站出来，拍着胸脯说，你是错的，这是对的。</p>
<p>人是有思想的动物，信息越透明，人的思想越广阔。反之，信息差越多，越激发误解与不满情绪，而这种不透明，绝对多数是来自自上而下的，而这种自上而下往往会在基层集中体现。</p>
<p>我不谈什么皈依者狂热，那太绝对化，我只想表达一个观点，基层的公平性与信息的透明性应当如何体现？</p>
<p>聊回资源池。</p>
<blockquote>
<p>所谓资源池，是指对于一个团队的成员而言，每个个体都是可调度的资源单位。<br>理想情况下，若团队中每个个体的认知水平相差不多，原则上，凡是涉及到该团队的需求和问题，任意调度团队中此时有时间投入新需求/新问题的个体，都能够cover。</p>
</blockquote>
<p>资源池可以说是中式软件开发，在多年迭代与探索中，为了提高人力资源利用率而总结出的一套可行手段。</p>
<p>那么，保证这个模式能够健康良性运行的前提，便是消除信息差。</p>
<h2 id="敏捷与信息差之间的矛盾是否可调和？"><a href="#敏捷与信息差之间的矛盾是否可调和？" class="headerlink" title="敏捷与信息差之间的矛盾是否可调和？"></a>敏捷与信息差之间的矛盾是否可调和？</h2><p>自然地，我们提出这样一个问题。</p>
<p>两者矛盾，是否可调和？</p>
<p>我们说可以，解决方式在于消除信息差。</p>
<p>有人可能要站出来反对了，你这意思是直接取消基层的调度管理节点吗？</p>
<p>兄弟，坐下说话，别激动。</p>
<p>那我们聊聊，基层调度节点的设立吧。</p>
<p>设立基层调度节点，无外乎因为人多了，一级管理节点精力有限，难以顾及方方面面，因此需要设立基层的调度节点来协调工作。</p>
<p>这没问题，这不正是经典的分治法么。</p>
<p>那问题在哪里？问题在于，将原本繁琐的事情进行某个维度的划分，再分担给基层调度节点，就万事大吉了么？</p>
<p>对于一级管理节点，的确减轻了压力，但是对于基层的资源池角色呢？</p>
<p>要知道，基层调度节点可是从资源池里选出来的，也就是说，在全局上，能够切实干活儿的实际资源池角色减少了。这是一方面。</p>
<p>另一方面，将新增的调度节点去作为对接任务的分发器，对于真正干活儿的资源池角色而言，何时介入需求，变成了该调度角色决定的事情。</p>
<p>何时介入，以及介入何种需求，都是黑盒子。</p>
<p>我们分开说。</p>
<h3 id="何时介入有影响么"><a href="#何时介入有影响么" class="headerlink" title="何时介入有影响么"></a>何时介入有影响么</h3><p>当然有，一个需求，或者说一个问题，前期沟通不是你，前期讨论你没参与。直接丧失了接触第一手资料的机会；这其中有多少信息丢失？</p>
<p>进一步，等你介入的时候，都已经到了切实的落地环节，怎么做已经有人帮你想好了，甚至可能连设计大纲都写出来了。</p>
<p>你要做的就是照着这个图纸，修房子。与戴着镣铐跳舞，何其相似。</p>
<p>对于解决一个具有一定规模的问题而言，这种基于他人的思路解决问题的方式，从根源上就限制作为一个独立个体的思考能力。</p>
<p>万事俱备，就差一个程序员了。</p>
<p>魔幻现实主义。</p>
<p>写代码，或者说，软件开发，是一种创造。如果你要创造，那就从头到尾都是你作为核心在创造，你的想法，你的设计，你的代码。一气呵成。</p>
<p>当然，对于复杂问题，多人参与也是应该的，但是至少这其中至少存在这么一个角色，他参与了整个问题的生命周期，我想这对于少犯错，提升健壮性，意义巨大。</p>
<p>为何要你的想法，你的设计，再变成我的代码？这其中要损失多少个脑细胞，换来多少句亲切的问候？不敢多想。</p>
<p>那，如何破局？</p>
<p>山人有补药和苦药两剂，且听山人道来。</p>
<p>补药，温顺，我们的目的是为了减少信息差，提高参与度与个体互动，那不妨在问题早期讨论阶段就让可能的参与者参与到讨论中，在这其中，挑选时间、精力、能力均能胜任的一人或多人参与后期的设计和编码。</p>
<p>你会发现，作为调度节点，每个问题上，都不再是单打独斗，总有人会和你一起分担来自问题/需求的压力；作为资源池中的角色，有想法，有一手知识，有你的设计，最后你将自己的想法和设计付诸落地，一件美事。</p>
<p>补药如此精妙，那苦药又如何？</p>
<p>既是苦药，怕不会太好下咽。从资源池中来，回资源池中去吧。</p>
<p>足下可否明示？</p>
<blockquote>
<p>我是说，去TMD的调度节点吧。</p>
</blockquote>
<p>调度节点，本质上还是资源池中的一员，选出来作为调度节点，是为了更好的协调复杂事项，做好问题的预调研，预分配。</p>
<p>但是实际上呢？好像，调度成了主要职责了，dispatch各种事项给资源池中的executor，在各个上下文中灵活切换，然后不时回调一下，看看进度如何，以便灵活组织语言进行汇总上报。</p>
<p>精彩，精彩，精彩。</p>
<p>作为调度节点，你可能委屈，“我的精力都被各种事项占满，再让我去负起资源池角色的责任，臣妾做不到啊”。</p>
<p>可以理解，但是请让事情的透明度更高一些，让executor们的参与度更高一些，停止你的所谓好心行为，你设计，你讨论，为什么要executor来买单？</p>
<p>你设计，你讨论，那就你来开发。毕竟，我们是一个敏捷团队，而这，是最敏捷的，最少上下文切换的。</p>
<p>除此之外，作为调度节点，别忘了自己的基类还是一个executor，本质上是executor implements Dispatcher，那么，请继续保持作为executor的公平性。</p>
<p>该值的班，该复的盘，请不要躲避，听我说谢谢你。</p>
<p>不患寡而患不均，这其中的利弊，我想作为资源池中的翘楚，调度节点比我更清楚。</p>
<h2 id="如何更好的发挥资源池的优势，提升敏捷度？"><a href="#如何更好的发挥资源池的优势，提升敏捷度？" class="headerlink" title="如何更好的发挥资源池的优势，提升敏捷度？"></a>如何更好的发挥资源池的优势，提升敏捷度？</h2><p>资源池这种实践模式，确实被实践验证为能够切实解决问题，落地想法的模式，虽然存在不合理之处，但是不掩盖它的光芒。</p>
<p>那么基于资源池模式不改变的前提，如何发挥它的优势，更好服务于敏捷软件开发流程呢？</p>
<p>这里提供一个场景，供君品鉴。</p>
<p>产品同学有一个好的点子，想为系统添加一个新的产品线，该产品线能够带来日PV增加百分之5的效果。于是产品同学编写prd，并向需求池中投递需求，并期望支持的人力资源。</p>
<p>资源池中进行调度的开发同学，根据自己在甘特图上的排期及任务分配情况，对需求池中的需求进行主动拣选，并进行预排期。</p>
<p>一旦锁定了该任务，该同学便会成为该需求的owner，后续的讨论、设计、开发、测试均需要参与，并负责到上线。</p>
<p>有会必邀，邀必参与，自己想，自己参与沟通，自己落地，自己追结果，自己负责。出问题，自己复盘，问心无愧。</p>
<h2 id="康威定律的启示"><a href="#康威定律的启示" class="headerlink" title="康威定律的启示"></a>康威定律的启示</h2><p>康威定律告诉我们，设计系统的架构受制于产生这些设计的组织的沟通结构。也就是说，产品必然是其（人员）组织沟通结构的缩影。</p>
<p>你的组织架构是什么样的，如如何运作的，基本上你的业务架构也是这么运作的。</p>
<p>业务架构，技术架构在迭代，组织架构也需要迭代，否则滞后冗赘的组织架构必然带来畸形抵消的业务架构、技术架构。</p>
<p>一个敏捷的团队，是自革新的，是自迭代的。</p>
<p>让前线的特种部队能够呼唤集团炮火。这是日渐销声匿迹的中台遗留下的一句经典。</p>
<p>你可以说中台是失败的，但是你不能否认这句话的积极意义。</p>
<p>与业务交互的团队，尤其是自诩敏捷的团队，一定是一个精悍的特种部队，扁平化，高效化，信息透明化，专家化。</p>
<p>如果这个团队把整个后勤部门都携带在身边，那么行军效率一定不会很高。</p>
<p>让后勤待在后勤的位置，让部队前出侦查。这才是现代化战争的作战形态。这也是康威定律给我的启示。</p>
<p>拥抱变化，不是自上而下的指示，而是推己及人的感悟，是整个团队所乐于拥抱的态度，是历史螺旋上升的坐标。</p>
<h2 id="结语：敏捷之于个人又如何？"><a href="#结语：敏捷之于个人又如何？" class="headerlink" title="结语：敏捷之于个人又如何？"></a>结语：敏捷之于个人又如何？</h2><p>之于个人，敏捷的背后，也许是内卷。</p>
<p>关于内卷，我不想多聊，我不反对内卷，这是一种选择，它也许是一种无奈，也许是一种随波逐流，也许是发自内心的自我鞭策。</p>
<p>都无所谓，只要是自己的想法，自己的选择，内卷或者躺平，无关风月。</p>
<p>纷繁的会议里，你知道哪个是重要的；琐碎的事务中，你知道优先级是如何排列的。</p>
<p>并行的需求中，你能够把握结果走向；复杂的问题里，你知道问题就在那里，答案就在那里。</p>
<p>你知道，你有一群好队友，你知道，你有一个好team。</p>
<p>你知道，你有一颗清醒、独立的内心；你知道，你知道。</p>
<p>你知道，你不知道。</p>
<p>心存敬畏，踏实向前，不迎合所谓的文化，不沉溺于所谓的氛围，不抱怨所谓的现状，不停止思考的大脑。</p>
<p>敏捷，发乎于内心，行乎于个人，成乎于群体。</p>
<p>中式软件开发的现状，已经是世俗化的，利益导向化的，实用主义化的。对于敏捷团队而言，始终是服务于业务增长的，要深知，当代中式互联网软件开发，几无技术驱动型，放眼望去，皆为业务驱动型。</p>
<p>那么想明白这个道理，再去实践，就会少一些压力，多一些豁达。</p>
<p>不妥协，不偏激，不随波，不逐流。</p>
<p>有想法，便会踏实，不轻易追逐内卷节奏；</p>
<p>有目标，便会沉稳，不停止自我迭代脚步。</p>
<p>其实，软件开发里，根本没有敏捷。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;历史的车轮滚滚向前，当代互联网也早已过了而立之年。&lt;/p&gt;
&lt;p&gt;各种优秀的理念，各种优秀的实践，提出，兴起，推广，衰落。你方唱罢我登场。&lt;/p&gt;
&lt;p&gt;而这其中，最为人津津乐道的当属–敏捷开发。&lt;/p&gt;
&lt;h2 id=&quot;唠一唠敏捷&quot;&gt;&lt;a href=&quot;#唠一唠敏捷&quot; cl
    
    </summary>
    
      <category term="杂谈" scheme="http://wuwenliang.net/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://wuwenliang.net/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>学点儿金融交易术语</title>
    <link href="http://wuwenliang.net/2022/07/20/%E5%AD%A6%E7%82%B9%E5%84%BF%E9%87%91%E8%9E%8D%E4%BA%A4%E6%98%93%E6%9C%AF%E8%AF%AD/"/>
    <id>http://wuwenliang.net/2022/07/20/学点儿金融交易术语/</id>
    <published>2022-07-20T07:41:01.000Z</published>
    <updated>2022-07-20T09:03:46.474Z</updated>
    
    <content type="html"><![CDATA[<p>对于韭菜而言，哪里有赚钱的可能就一股脑儿钻进哪里。也不管是否有一套自己的交易系统。</p>
<p>范围缩小到股市交易和虚拟货币市场，也是同样的道理。</p>
<p>合格的韭菜是要有一套体系化的交易系统，较为全面的交易术语体系的，作为扫盲，也作为警示，本文对金融交易中的一些术语进行讲解。</p>
<p>声明：</p>
<blockquote>
<p>文中的概念和场景仅作为学习使用，不作为投资建议。</p>
<p>市场有风险，入市需谨慎！</p>
</blockquote>
<p>闲话就说到这里，我们进入正题。</p>
<a id="more"></a>
<h1 id="什么是仓位？"><a href="#什么是仓位？" class="headerlink" title="什么是仓位？"></a>什么是仓位？</h1><blockquote>
<p>指投资⼈实有投资和实际投资资⾦的⽐例</p>
</blockquote>
<h1 id="什么是满仓？"><a href="#什么是满仓？" class="headerlink" title="什么是满仓？"></a>什么是满仓？</h1><blockquote>
<p>将全部资⾦买⼊股票或其他投资资产，如基金、⽐特币等</p>
</blockquote>
<h1 id="什么是全仓模式"><a href="#什么是全仓模式" class="headerlink" title="什么是全仓模式"></a>什么是全仓模式</h1><blockquote>
<p>账户权益中的资产都作为保证⾦使⽤，无空闲可用资金，风险最大。（多个仓位共享保证⾦）</p>
</blockquote>
<h1 id="什么是逐仓模式"><a href="#什么是逐仓模式" class="headerlink" title="什么是逐仓模式"></a>什么是逐仓模式</h1><blockquote>
<p>各个仓位单独核算保证⾦,盈亏互不影响</p>
</blockquote>
<h1 id="减仓"><a href="#减仓" class="headerlink" title="减仓"></a>减仓</h1><blockquote>
<p>把部分资产（如股票）卖出，但不全部卖出</p>
</blockquote>
<h1 id="重仓"><a href="#重仓" class="headerlink" title="重仓"></a>重仓</h1><blockquote>
<p>资⾦和股票资产相⽐，股票资产份额占多，风险较高</p>
</blockquote>
<h1 id="轻仓"><a href="#轻仓" class="headerlink" title="轻仓"></a>轻仓</h1><blockquote>
<p>资⾦和股票资产相⽐，资⾦份额占多，风险可控</p>
</blockquote>
<h1 id="空仓"><a href="#空仓" class="headerlink" title="空仓"></a>空仓</h1><blockquote>
<p>把⼿⾥所持股票全部卖出，全部转为资⾦，此时离场呈观望状态</p>
</blockquote>
<h1 id="⽌盈-止损"><a href="#⽌盈-止损" class="headerlink" title="⽌盈/止损"></a>⽌盈/止损</h1><blockquote>
<p>止盈：获得⼀定收益后，将所持股票卖出以保住盈利</p>
<p>⽌损：亏损到⼀定程度后，将所持股票卖出以防⽌亏损进⼀步扩⼤</p>
</blockquote>
<h1 id="⽜市与熊市"><a href="#⽜市与熊市" class="headerlink" title="⽜市与熊市"></a>⽜市与熊市</h1><blockquote>
<p>牛市：价格持续上升，前景乐观</p>
<p>熊市：价格持续下跌，前景黯淡</p>
</blockquote>
<h1 id="多头与空头"><a href="#多头与空头" class="headerlink" title="多头与空头"></a>多头与空头</h1><blockquote>
<p>多头：又称做多。属于买⽅，认为交易产品（如期货、股票）未来会上涨，进行买⼊，待价格确实上涨后，⾼价卖出获利，了结。</p>
<p>空头：又称做空。属于卖方，认为交易产品（如期货、股票）未来会下跌，将⼿中持有的资产（或向交易平台借资产） 卖出，待交易产品价格下跌后，低价买⼊获利了结，属于投机行为。</p>
</blockquote>
<h1 id="建仓与补仓"><a href="#建仓与补仓" class="headerlink" title="建仓与补仓"></a>建仓与补仓</h1><blockquote>
<p>建仓：买⼊期货、股票开仓；</p>
<p>补仓：分批买⼊资产，如：先买⼊1手股票，之后再买⼊1手</p>
</blockquote>
<h1 id="盘整（横盘）"><a href="#盘整（横盘）" class="headerlink" title="盘整（横盘）"></a>盘整（横盘）</h1><blockquote>
<p>K线波动较小，大趋势为横向抖动，表明当前价格波动幅度较⼩，市场较为稳定，情绪理性、</p>
</blockquote>
<h1 id="反弹"><a href="#反弹" class="headerlink" title="反弹"></a>反弹</h1><blockquote>
<p>价格下跌时，因下跌过快⽽价格回升调整</p>
</blockquote>
<h1 id="阴跌"><a href="#阴跌" class="headerlink" title="阴跌"></a>阴跌</h1><blockquote>
<p>价格缓慢下滑</p>
</blockquote>
<h1 id="跳⽔（瀑布）"><a href="#跳⽔（瀑布）" class="headerlink" title="跳⽔（瀑布）"></a>跳⽔（瀑布）</h1><blockquote>
<p>价格快速下跌，幅度很⼤</p>
</blockquote>
<h1 id="割⾁-韭菜行为"><a href="#割⾁-韭菜行为" class="headerlink" title="割⾁[韭菜行为]"></a>割⾁[韭菜行为]</h1><blockquote>
<p>买⼊股票后，价格下跌，为避免亏损扩⼤⽽赔本忍痛卖出。或借币做空后，价格上涨，赔本买⼊股票。本质上是韭菜行为，也叫追涨杀跌。</p>
</blockquote>
<h1 id="套牢与解套"><a href="#套牢与解套" class="headerlink" title="套牢与解套"></a>套牢与解套</h1><blockquote>
<p>套牢: 预期价格上涨，不料买⼊后价格反而下跌；或预期价格下跌，不料卖出后，币价却上涨，舍不得割肉，只能观望，等着亏损减少转盈，此时就是被套住了。</p>
<p>解套: 买⼊股票后价格下跌造成暂时的账⾯损失，但之后价格回升，扭亏为盈。</p>
</blockquote>
<h1 id="踏空-事后诸葛亮行为"><a href="#踏空-事后诸葛亮行为" class="headerlink" title="踏空[事后诸葛亮行为]"></a>踏空[事后诸葛亮行为]</h1><blockquote>
<p>因看淡后市卖出股票后，股票价格却⼀路上涨，自己未能及时买⼊，因此未能赚得利润，美其名曰自己踏空了，实际上就是纯纯的事后诸葛亮，纯纯牛马行为。</p>
</blockquote>
<h1 id="超买与超卖"><a href="#超买与超卖" class="headerlink" title="超买与超卖"></a>超买与超卖</h1><blockquote>
<p>超买: 价格持续上升到⼀定⾼度，买⽅⼒量基本⽤尽，价格即将下跌, 牛转熊</p>
<p>超卖: 价格持续下跌到⼀定低点，卖⽅⼒量基本⽤尽，价格即将回升 ，熊转牛</p>
</blockquote>
<h1 id="诱多与诱空"><a href="#诱多与诱空" class="headerlink" title="诱多与诱空"></a>诱多与诱空</h1><blockquote>
<p>诱多：股票价格盘整已久，下跌可能性较⼤，空头⼤多已卖出股票，突然空⽅将币价拉⾼，诱使多⽅以为币价将会上涨，纷纷买⼊，结果空⽅打压币价，使多⽅套牢。受损多为散户；</p>
<p>诱空：多头买⼊股票后，故意打压股票价格，使空头以为价格将会下跌，纷纷 抛出，结果误⼊多头的陷阱；</p>
</blockquote>
<h1 id="泰达币是什么？"><a href="#泰达币是什么？" class="headerlink" title="泰达币是什么？"></a>泰达币是什么？</h1><blockquote>
<p>这是一个虚拟货币市场的概念。</p>
<p>即USDT，是⽬前使⽤较为⼴泛的基准币，是⼀种将加密货币与法币 （美元）挂钩的虚拟货币， 是⼀种保存在外汇储备账户、获得法定货币⽀持的虚拟货币，⽬前最 流⾏，⼀个对应⼀美元， </p>
<p>发⾏它的⽬的就是防⽌加密货币出现价格⼤幅波动，因为⼀个泰达币 价值就基本上值1美元。也叫稳定币。 </p>
<p>所以，⼀般的交易流程为：先⽤法币购买基准币，然后在中心交易平台上进⾏资⾦划转。再进行币币之间的交易行为。</p>
</blockquote>
<h1 id="币对"><a href="#币对" class="headerlink" title="币对"></a>币对</h1><blockquote>
<p>对于法币⽽⾔，货币对是由两种货币组成的外汇交易汇率，由两个 ISO 代码加⼀分隔符表示，例如 欧元/美元(EUR/USD)，其中第⼀个 代码代表 “ 基本货币 ” ，另⼀个则是 “ ⼆级货币 ” 。 </p>
<p>对于虚拟币⽽⾔，币对如：BTC/USDT，表示USDT就是计价货币， BTC是交易货币。 意思就是：通过USDT对BTC进⾏计价，实现对BTC的交易</p>
</blockquote>
<p>举几个例子说明下。</p>
<blockquote>
<p>⽤⼀种资产（quote currency，计价货币）去定价另⼀种资产 （base currency，基础货币）,⽐如⽤⼈⺠币（CNY）去定价⽐特 币（BTC），就形成了⼀个BTC/CNY的交易对，</p>
<p>交易对的价格代 表的是买⼊1单位的基础货币（⽐如BTC）需要⽀付多少单位的计 价货币（⽐如CNY），或者卖出⼀个单位的基础货币（⽐如 BTC）可以获得多少单位的计价货币（⽐如CNY）。</p>
<p>当BTC对 CNY的价格上涨时，同等单位的CNY能够兑换的BTC是减少的， ⽽同等单位的BTC能够兑换的CNY是变多的。 </p>
<p>以下是⼀些常⻅的交易对：<br>BTC/CNY：⽤⼈⺠币（CNY）去定价⽐特币（BTC），该交易对 的价格代表1个BTC值多少CNY。 </p>
<p>LTC/CNY：⽤⼈⺠币（CNY）去定价莱特币（LTC），该交易对 的价格代表1个LTC值多少CNY。 </p>
<p>ETH/CNY：⽤⼈⺠币（CNY）去定价以太坊（ETH），该交易对 的价格代表1个ETH值多少CNY。 </p>
<p>LTC/BTC：⽤⽐特币（BTC）去定价莱特币（LTC），该交易对的 价格代表1个LTC值多少BTC。 </p>
<p>ETH/BTC：⽤⽐特币（BTC）去定价以太坊（ETH），该交易对 的价格代表1个ETH值多少BTC。</p>
</blockquote>
<h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h1><blockquote>
<p>可以类比保险。</p>
<p>可以理解为就是做买卖的合同。⽐如⽤100块买1克⻩⾦，双⽅会签订合同，合约是通过约定，缴纳一定的保证金，让买方提前锁定交易产品的价格，约定在未来某个时间以一个固定价格买入特定的交易产品。</p>
</blockquote>
<h1 id="杠杆"><a href="#杠杆" class="headerlink" title="杠杆"></a>杠杆</h1><blockquote>
<p>类似于之前菜市场的秤杆，⽤⼀个相对较⼩的秤砣可以平衡（计量） 较重的货物。举例，假设⻩⾦1克是100元，那在1:100的杠杆下，⽤ 户只需要花1块钱就能买到1克⻩⾦。 通过杠杆可以实现少量资⾦撬 动数倍资⾦的⽬的。</p>
</blockquote>
<h1 id="平仓"><a href="#平仓" class="headerlink" title="平仓"></a>平仓</h1><blockquote>
<p>通俗解释，在交易的时候，我觉得要涨了——看多，</p>
<p>此时就要⼀张看 涨的订单（合约），也称为买⼊，</p>
<p>假如到时候真涨了，我为了赚钱， 就把这个之前低价买⼊的订单，卖出来赚差价，此时的卖出订单的⾏ 为就是平仓。 </p>
<p>反之，在交易的时候，我觉得要下跌——看空，</p>
<p>此时就要⼀张看跌的 订单（合约），也称为卖出，</p>
<p>在期货交易⾥就是借货卖出，⽐如我预 测⻩⾦要跌了，交易所允许我借货——借⼊⼀定单位的⻩⾦，以现在 价格卖掉。</p>
<p>假如到时候真跌了，我为了赚钱，就把这个之前相对⾼价 卖出的订单，重新买⼊来赚取差价，这些⻩⾦也就归还了，此时的买 ⼊（买回货物）⾏为也是平仓。 </p>
<p>所以，合约（订单）的平仓动作有两个⽅向，看多和看空都是可以 的。平仓的⽬的就是结束交易，或者说结束订单（合约）。</p>
</blockquote>
<h1 id="保证⾦"><a href="#保证⾦" class="headerlink" title="保证⾦"></a>保证⾦</h1><blockquote>
<p>1、它的来源是期货交易所，在期货市场上，交易者只需按期货合约价 格的⼀定⽐率交少量资⾦作为财⼒的象征，或者说担保，缴纳了保证 ⾦才能参与期货合约的买卖。并且期货交易有杠杆，持仓后的保证⾦ 余额会可能变化 </p>
<p>2、在股票交易所，它的保证⾦只是⼀个通俗的说法，实际上指的是⽤ 来买股票的钱，它没有杠杆，因此不买股票时帐户⾥也不需要缴纳保 证⾦，在买股票之前，需要先把你银⾏的钱转到股票账户⾥才能买卖 股票，钱在银⾏⾥叫存款，在股票账户⾥就叫保证⾦</p>
</blockquote>
<h1 id="爆仓"><a href="#爆仓" class="headerlink" title="爆仓"></a>爆仓</h1><blockquote>
<p>简单说就是你的保证⾦为负值的时候。也就是亏损且亏损值还⼤于了 你的交易账户中的保证⾦，此时保证⾦扣完以后就没有可⽤资⾦了， 机构⼀般就会强制平仓，也就是所谓的爆仓。通俗的理解就是，愿赌 服输。</p>
</blockquote>
<h1 id="平仓和爆仓最-明显的区别"><a href="#平仓和爆仓最-明显的区别" class="headerlink" title="平仓和爆仓最 明显的区别"></a>平仓和爆仓最 明显的区别</h1><blockquote>
<p>平仓是主动的，是为及时⽌盈或⽌损⽽⾃⾏选择清仓的⾏为 </p>
<p>爆仓是被动的，是投资者的保证⾦为零甚⾄为负，但⼜来不及追加保 证⾦⽽被强⾏平仓的⾏为</p>
</blockquote>
<h1 id="交割-交收-和-结算"><a href="#交割-交收-和-结算" class="headerlink" title="交割 交收 和 结算"></a>交割 交收 和 结算</h1><blockquote>
<p>以证券交易举例：买卖双⽅达成交易后，应根据清算的结果，</p>
<p>在事先 约定的时间内履⾏合约。</p>
<p>买⽅需交付⼀定款项获得所购证券，卖⽅需 交付⼀定证券获得相应价款。</p>
<p>在钱货两清的过程中（关键词是钱货两清），证券（货物）的收付称为交割，资⾦的收付称为交收。</p>
<p>⽽证券 清算和交割、交收两个过程统称为证券结算</p>
</blockquote>
<h1 id="撮合交易"><a href="#撮合交易" class="headerlink" title="撮合交易"></a>撮合交易</h1><blockquote>
<p>撮合成交是国内期货交易所与证券交易所的常⻅达成交易的⽅式，是 指买卖双⽅将交易买卖的意向（交易委托），报送到交易所，由交易 所按⼀定的原则进⾏配对，由交易所记录成交信息，并反馈交易结果。</p>
</blockquote>
<h1 id="市价委托-与-限价委托"><a href="#市价委托-与-限价委托" class="headerlink" title="市价委托 与 限价委托"></a>市价委托 与 限价委托</h1><blockquote>
<p>1、市价委托，也叫市场委托，</p>
<p>顾名思义即委托⼈要求证券商按此时此 刻的市场价格快速买进或卖出证券，在交易系统⾥它的优先级默认最⾼，但是该模式很容易有变化，因为你委托给券商，券商在下单的过 程有⼀个时间差，并且该模式是⽆需等待，下单直接交易的，⽐如你 看到某个股票跌到10元了，想买⼊，等券商真正买⼊时，可能已经是 11元了，当然反之也可能是9元。这个不⼀定。 </p>
<p>2、限价委托，即委托⼈要求券商按限定的价格买进或卖出证券。</p>
<p>证券商在执⾏时必须按限价或低于限价买进；委托⼈提出限价委托卖出证 券,证券商执⾏时则必须按限价或⾼于限价卖出 ⼀句话简单的说：市价委托，交易系统会主动撮合，⼀定会成交，但是价格不⼀定最优，</p>
<p>⽽限价就是限定价格，若卖出，则成交不会低于 你的卖出价格，反之买⼊，则成交价格不会⾼于你的买⼊价格。 </p>
<p>我国的上海证券交易所和深圳证券交易所都采取了限价委托⽅式，如 果投资者⻓期⽆法成交，必须撤单以后再挂单，否则会⼀直到收盘都 ⽆法成交。 </p>
<p>如果想⽴即成交的话就⽤市价委托，想在⾃⼰理想的价位成交的话就 ⽤限价委托。</p>
</blockquote>
<h1 id="挂单-吃单"><a href="#挂单-吃单" class="headerlink" title="挂单 吃单"></a>挂单 吃单</h1><blockquote>
<p>当交易委托到市场后⽴即成交的即为吃单（taker），</p>
<p>委托 到市场后等待成交的即为挂单（maker） </p>
<p>⼿续费⼀般都是挂单低于吃单，挂单是被动成交，吃单是主动成交。 </p>
<p>挂单为了提⾼流动性，⽽吃单消耗流动性，中心化交易所中，对于缺乏流动性的交易产品，平台⼀般都⿎励挂单，故挂单⼿续费⽐吃单的低。以增加流动性。</p>
</blockquote>
<h1 id="集中撮合处理"><a href="#集中撮合处理" class="headerlink" title="集中撮合处理"></a>集中撮合处理</h1><p>所有买委托 </p>
<blockquote>
<p>按照委托限价由⾼到低的顺序排列，限价相同者按照进 ⼊系统的时间先后排列； </p>
</blockquote>
<p>所有卖委托 </p>
<blockquote>
<p> 按委托限价由低到⾼的顺序排列，限价相同者按照进⼊系统的时间先后排列。 </p>
<p>依序逐笔将排在前⾯的买委托与卖委托配对成交，即按照 <strong>“价格优先，同等价格下时间优先”</strong> 的成交顺序依次成交，直⾄成交条件不满⾜为⽌，</p>
<p>即不存在限价⾼于等于成交价的叫买委托、或不存在限价低于等于成交价的叫卖委托。</p>
<p>所有成交都以同⼀成交价成交。 集中撮合成交的委托单，按Taker⼿续费率⽀付⼿续费。</p>
</blockquote>
<h1 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h1><blockquote>
<p>即券商，一般每个券商都有一个唯⼀编号</p>
</blockquote>
<h1 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h1><blockquote>
<p>挂单（maker）没有成交的，都在深度⾥，成交的就不在了。</p>
</blockquote>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于韭菜而言，哪里有赚钱的可能就一股脑儿钻进哪里。也不管是否有一套自己的交易系统。&lt;/p&gt;
&lt;p&gt;范围缩小到股市交易和虚拟货币市场，也是同样的道理。&lt;/p&gt;
&lt;p&gt;合格的韭菜是要有一套体系化的交易系统，较为全面的交易术语体系的，作为扫盲，也作为警示，本文对金融交易中的一些术语进行讲解。&lt;/p&gt;
&lt;p&gt;声明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文中的概念和场景仅作为学习使用，不作为投资建议。&lt;/p&gt;
&lt;p&gt;市场有风险，入市需谨慎！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;闲话就说到这里，我们进入正题。&lt;/p&gt;
    
    </summary>
    
      <category term="金融系统" scheme="http://wuwenliang.net/categories/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="金融系统" scheme="http://wuwenliang.net/tags/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>复杂系统架构之道-有状态服务</title>
    <link href="http://wuwenliang.net/2022/06/11/%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1/"/>
    <id>http://wuwenliang.net/2022/06/11/复杂系统架构之道-有状态服务/</id>
    <published>2022-06-11T08:30:23.000Z</published>
    <updated>2022-06-11T09:13:00.572Z</updated>
    
    <content type="html"><![CDATA[<p>概述常见的服务状态形式，</p>
<p>无状态的演进过程 好处 及 劣势</p>
<p>为何要有状态</p>
<p>状态的核心之道</p>
<p>状态与一致性（分片与sequence进度追赶，水位）</p>
<p>wal机制</p>
<p>异步化 无锁化 disruptor</p>
<p>各种分片</p>
<p>上下文传递 context</p>
<p>持久化相关，推拉，启动reload</p>
<p>共识机制</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;概述常见的服务状态形式，&lt;/p&gt;
&lt;p&gt;无状态的演进过程 好处 及 劣势&lt;/p&gt;
&lt;p&gt;为何要有状态&lt;/p&gt;
&lt;p&gt;状态的核心之道&lt;/p&gt;
&lt;p&gt;状态与一致性（分片与sequence进度追赶，水位）&lt;/p&gt;
&lt;p&gt;wal机制&lt;/p&gt;
&lt;p&gt;异步化 无锁化 disruptor
    
    </summary>
    
      <category term="专题-分布式" scheme="http://wuwenliang.net/categories/%E4%B8%93%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="专题-分布式" scheme="http://wuwenliang.net/tags/%E4%B8%93%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>推与拉，RocketMQ消息消费的那些姿势</title>
    <link href="http://wuwenliang.net/2022/05/11/%E6%8E%A8%E4%B8%8E%E6%8B%89%EF%BC%8CRocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E9%82%A3%E4%BA%9B%E5%A7%BF%E5%8A%BF/"/>
    <id>http://wuwenliang.net/2022/05/11/推与拉，RocketMQ消息消费的那些姿势/</id>
    <published>2022-05-11T13:44:12.000Z</published>
    <updated>2022-07-20T09:06:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>消息消费方式，一般来说有两种姿势，我们往往称之“推”模式（Push）以及“拉”模式（Pull），如图所示。<br>​<br><img src="/2022/05/11/推与拉，RocketMQ消息消费的那些姿势/pullpush.png" alt="pullpush.png"></p>
<a id="more"></a>
<p>“推”模式，从模型上来说，消费者订阅了消息中间件中的Topic（主题），当该主题有接收到生产者发送的消息之后，消息中间件会主动将消息推送（push）至订阅了该主题的消费者。这种由消息中间件推送到消费者的方式，称为“推”模式。</p>
<p>“拉”模式，从模型上来说，消费者向消息中间件发起消息拉取请求，消息中间件接收到拉取请求之后，将消息进行打包之后返回给消费者。这种方式下，消息是消费者主动向消息中间件进行拉取的，这种由消费者主动向消息中间件拉取的方式，称为“拉”模式。</p>
<blockquote>
<p>这里需要注意的是，我们要明白实现完全的推模式，对于MQ的broker而言需要付出较多的性能，由于broker需要主动与消费者进程建立连接并且需要主动探查消费者进程的健康状态，相当于broker对消费者进程构成了反向依赖，这便很大程度上增加了broker实现复杂度。</p>
<p>简单提一句，对于RocketMQ而言，推方式消费消息其本质实现其实是长轮询的拉，相关文档可以自行查找资料或者翻看本公众号的历史文章。</p>
</blockquote>
<h3 id="基于“推”模式消费消息"><a href="#基于“推”模式消费消息" class="headerlink" title="基于“推”模式消费消息"></a>基于“推”模式消费消息</h3><p>首先介绍“推”模式下是如何消费消息的，以RocketMQ为例，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class PushConsumerDemo &#123;</div><div class="line"></div><div class="line">  public static void main(String[] args) throws InterruptedException, MQClientException &#123;</div><div class="line"></div><div class="line">    DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;push_consumer_group&quot;);</div><div class="line">    </div><div class="line">    consumer.setNamesrvAddr(&quot;192.168.1.106&quot;);</div><div class="line">    </div><div class="line">    consumer.subscribe(&quot;PUSH_TOPIC&quot;, &quot;*&quot;);</div><div class="line">    </div><div class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</div><div class="line">    </div><div class="line">    consumer.setConsumeTimestamp(new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).format(new Date()));</div><div class="line">    </div><div class="line">    consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</div><div class="line">    </div><div class="line">        System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs);</div><div class="line">    </div><div class="line">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</div><div class="line">    </div><div class="line">      &#125;</div><div class="line">    </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    consumer.start();</div><div class="line">    </div><div class="line">    System.out.printf(&quot;Consumer Started.%n&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RocketMQ中通过DefaultMQPushConsumer实现“推”模式的消息消费，这种方式的特点在于实时性好，只要MQ服务端有消息到来，就会实时性的推送给消费者进行消费。</p>
<p>从章节开始的介绍中我们得知，在“推”模式下，服务端需要感知与它建立链接的客户端，这意味着服务端主动推送消息的过程中，需要对消息做额外的处理，以便能够及时将消息分发给客户端。这些计算逻辑会为消息中间件的服务端带来额外的负担，因此RocketMQ通过“长轮询”的方式，巧妙的解决了这个问题。</p>
<p>长轮询本质上仍旧是轮询，它与轮询不同之处在于，当服务端接收到客户端的请求后服务端不会立即将数据返回给客户端，而是会先将这个请求hold住，判断服务器端数据是否有更新。如果有更新，则对客户端进行响应，如果一直没有数据，则它会在长轮询超时时间之前一直hold住请求并检测是否有数据更新，直到有数据或者超时后才返回。</p>
<p>“长轮询”的效果基本上与服务端实时推送相似，兼顾了实时性，降低了纯“推”模式实现的复杂度。</p>
<h3 id="基于“拉”模式消费消息"><a href="#基于“拉”模式消费消息" class="headerlink" title="基于“拉”模式消费消息"></a>基于“拉”模式消费消息</h3><p>接着介绍“拉”模式下是如何消费消息的，还是以RocektMQ为例，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">public class PullConsumerDemo &#123;</div><div class="line"></div><div class="line">  private static final Map&lt;MessageQueue, Long&gt; OFFSE_TABLE = new HashMap&lt;MessageQueue, Long&gt;();</div><div class="line"></div><div class="line">  public static void main(String[] args) throws MQClientException &#123;</div><div class="line"></div><div class="line">​    DefaultMQPullConsumer consumer = new DefaultMQPullConsumer(&quot;PULL_CONSUMER_GROUP&quot;);</div><div class="line"></div><div class="line">​    consumer.setNamesrvAddr(&quot;127.0.0.1:9876&quot;);</div><div class="line"></div><div class="line">​    consumer.start();</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">​    Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(&quot;PULL-TOPIC&quot;);</div><div class="line"></div><div class="line">​    for (MessageQueue mq : mqs) &#123;</div><div class="line"></div><div class="line">​      System.out.printf(&quot;Consume from the queue: %s%n&quot;, mq);</div><div class="line"></div><div class="line">​      SINGLE_MQ:</div><div class="line"></div><div class="line">​      while (true) &#123;</div><div class="line"></div><div class="line">​        try &#123;</div><div class="line"></div><div class="line">​          PullResult pullResult =</div><div class="line"></div><div class="line">​            consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);</div><div class="line"></div><div class="line">​          System.out.printf(&quot;%s%n&quot;, pullResult);</div><div class="line"></div><div class="line">​          putMessageQueueOffset(mq, pullResult.getNextBeginOffset());</div><div class="line"></div><div class="line">​          switch (pullResult.getPullStatus()) &#123;</div><div class="line"></div><div class="line">​            case FOUND:</div><div class="line"></div><div class="line">​              break;</div><div class="line"></div><div class="line">​             case NO_MATCHED_MSG:</div><div class="line"></div><div class="line">​              break;</div><div class="line"></div><div class="line">​            case NO_NEW_MSG:</div><div class="line"></div><div class="line">​              break SINGLE_MQ;</div><div class="line"></div><div class="line">​            case OFFSET_ILLEGAL:</div><div class="line"></div><div class="line">​              break;</div><div class="line"></div><div class="line">​            default:</div><div class="line"></div><div class="line">​              break;</div><div class="line"></div><div class="line">​          &#125;</div><div class="line"></div><div class="line">​        &#125; catch (Exception e) &#123;</div><div class="line"></div><div class="line">​          e.printStackTrace();</div><div class="line"></div><div class="line">​        &#125;</div><div class="line"></div><div class="line">​      &#125;</div><div class="line"></div><div class="line">​    &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">​    consumer.shutdown();</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  private static long getMessageQueueOffset(MessageQueue mq) &#123;</div><div class="line"></div><div class="line">​    Long offset = OFFSE_TABLE.get(mq);</div><div class="line"></div><div class="line">​    if (offset != null) &#123;</div><div class="line"></div><div class="line">​      return offset;</div><div class="line"></div><div class="line">​    &#125;</div><div class="line"></div><div class="line">​    return 0;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">  private static void putMessageQueueOffset(MessageQueue mq,long offset)&#123;</div><div class="line"></div><div class="line">​    OFFSE_TABLE.put(mq, offset);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RocketMQ通过DefaultMQPullConsumer实现了“拉”模式的消息消费。</p>
<ul>
<li><p>（1）需要定义消费者组，实例化一个DefaultMQPullConsumer消费者对象，并指定消费者组； </p>
</li>
<li><p>（2）接着为消费者设置NameServer地址，保证消费者客户端能够从NameServer获取到broker地址，从而执行消息消费流程；</p>
</li>
<li><p>（3）通过consumer.fetchSubscribeMessageQueues(TOPIC)方法获取指定TOPIC下的所有队列，默认有4个；</p>
</li>
<li><p>（4）接着需要对获取到MessageQueue集合进行遍历，拉取数据并执行具体的消费过程；</p>
</li>
<li><p>（5）通过while(true) 不间断地从队列中拉取数据，默认情况下每次拉取32条，这里需要显式地传入拉取开始的offset，通过getMessageQueueOffset(mq)方法获取到开始拉取的offset，从持久化设施中得到对应MessageQueue的拉取进度(可以认为是消费进度)；</p>
<ul>
<li>拉取结束后，在持久化设施(这里是一个Map)中保存下次拉取开始时的offset，也就是本次拉取结束的下一个offset（通过pullResult.getNextBeginOffset()获取）；</li>
</ul>
</li>
<li><p>（6）需要注意的是，每次拉取成功之后都需要显式调用putMessageQueueOffset()方法，刷新对应队列MessageQueue的拉取进度。</p>
</li>
</ul>
<p>总结来说，RocketMQ中的“拉”模式消费方式需要开发者显式维护消费进度，每次消费成功之后都需要更新消费进度，并进行存储，比如这里的案例就是通过Map存储了队列的消费进度（offset）。</p>
<p>假如由于开发者的疏忽忘记保存offset，则每次都会从第一条消进行拉取，这样很容易造成消息的重复消费。如果是生产环境没有做幂等则后果除了会造成大量业务逻辑的重复执行还会造成业务的积压从而导致线上业务的卡顿甚至雪崩。</p>
<p>另外还需要通过额外的存储手段对offset进行保存（推荐使用MySQL或者Redis进行存储），并且需要保证存储设施的稳定可靠，否则还是会引起重复消费的问题。</p>
<h2 id="推-拉模式的对比与使用建议"><a href="#推-拉模式的对比与使用建议" class="headerlink" title="推/拉模式的对比与使用建议"></a>推/拉模式的对比与使用建议</h2><p>基于“推”模式消费消息，实时性好，只要消息进入消息中间件就可以即时被消费者感知并进行消费；缺点在于“推”模式需要消息中间件进行额外的计算和消费者的维护工作，因此可能引起消息中间件服务端的机器CPU负载升高；</p>
<p>而“拉”模式消费消息，消费者能够自主控制拉取的频率，拉取的数量，因此对消息中间件的机器而言，负载较低；但是“拉”模式由于是定时发起的消息拉取请求，因此实时性较弱。而且“拉”模式下还需要消费者自行维护消费进度，相比而言“推”模式的消息消费方式则不需要客户端主动维护消费进度（广播消费模式除外）。</p>
<p>因此对推/拉模式的使用建议如下：</p>
<ul>
<li><p>（1）如果追求消息消费的实时性，则推荐使用“推”模式消费消息，但是要注意尽量提高消息中间件服务器的配置，并添加必要的监控以感知服务器的性能指标变化；</p>
</li>
<li><p>（2）如果想要灵活控制消费频率，消息拉取数量，则推荐使用“拉”模式消费消息。</p>
</li>
</ul>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息消费方式，一般来说有两种姿势，我们往往称之“推”模式（Push）以及“拉”模式（Pull），如图所示。&lt;br&gt;​&lt;br&gt;&lt;img src=&quot;/2022/05/11/推与拉，RocketMQ消息消费的那些姿势/pullpush.png&quot; alt=&quot;pullpush.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="跟我学RocketMQ" scheme="http://wuwenliang.net/categories/%E8%B7%9F%E6%88%91%E5%AD%A6RocketMQ/"/>
    
    
      <category term="跟我学RocketMQ" scheme="http://wuwenliang.net/tags/%E8%B7%9F%E6%88%91%E5%AD%A6RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>还在卷八股文？来和我卷MIT6.824吧</title>
    <link href="http://wuwenliang.net/2022/03/20/%E8%BF%98%E5%9C%A8%E5%8D%B7%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%9F%E6%9D%A5%E5%92%8C%E6%88%91%E5%8D%B7MIT6-824%E5%90%A7/"/>
    <id>http://wuwenliang.net/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/</id>
    <published>2022-03-20T09:40:14.000Z</published>
    <updated>2022-03-20T10:33:05.650Z</updated>
    
    <content type="html"><![CDATA[<p>有没有想过，有这么一门课程。他不是简单的念PPT，他的老师是计算机史上五大黑客之一的罗伯特·塔潘-莫里斯(RobertTappanMorris)；</p>
<p>有没有想过，有这么一门课程，他会带你阅读GFS、Map Reduce、RAFT、Big Table论文；</p>
<p>来看看他的四个实验作业题：</p>
<ul>
<li>基于论文思路，实现一个简单的 MapReduce 框架。这个作业的实现前提是你得了解 Unix Domain socket，知道goalng plugin（也就是<a href="https://www.zhihu.com/search?q=动态链接&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1524420907}" target="_blank" rel="external">动态链接</a>）。</li>
<li>实现一个完整的Raft协议。这部分拆成了三个部分，它会分别让你实现 Leader Election、AppendEntry RPC 和 Raft persist。<ul>
<li>在这一部分里，我们将使用提供的类库 labrpc 来完成完整的Raft。其中， labrpc 是一个模拟网络环境的 rpc 框架，它是基于 UDP实现的（注意这一点）。</li>
</ul>
</li>
<li>根据自己实现的Raft，写一个KV数据库。同时实现 Raft 协议的 Snapshot RPC。</li>
<li>在之前的作业基础上，为KV数据库实现Sharding分片功能，同时实现 multi Raft功能。</li>
</ul>
<blockquote>
<p>笔者在看到这部分的时候，惊为天人。这课程，硬核！</p>
</blockquote>
<h2 id="这门课就是MIT6-824，由罗伯特·塔潘-莫里斯教授教学。"><a href="#这门课就是MIT6-824，由罗伯特·塔潘-莫里斯教授教学。" class="headerlink" title="这门课就是MIT6.824，由罗伯特·塔潘-莫里斯教授教学。"></a>这门课就是MIT6.824，由罗伯特·塔潘-莫里斯教授教学。</h2><blockquote>
<p>MIT 6.824 是一门讲解分布式系统的课程。</p>
<p>课程内容包括Golang的学习、分布式系统研究动机、<a href="https://www.zhihu.com/search?q=一致性协议算法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1524420907}" target="_blank" rel="external">一致性协议算法</a>、著名分布式系统软件论文讲解和<a href="https://www.zhihu.com/search?q=一致性算法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A1524420907}" target="_blank" rel="external">一致性算法</a> （Raft算法）的实现机制及实验。</p>
<p>是一门不可多得的实践性质比较强的课程。</p>
</blockquote>
<p>虽说这门课程受众主要是MIT研究生，但是笔者认为该课程对有一定工作经验的工程师有着更多的指导意义和参考价值。</p>
<p>他可以帮助工程师对自己的知识体系有一个系统性的整理，如果你恰巧是一个动手能力、自学能力强的人，那么这门课程一定适合你。</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>课程是纯英文的，因此对于大多数人而言可能是比较陡峭的门槛，幸运的是，已经有无私的翻译者提供了人工翻译的版本。</p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/1.png" alt="人工翻译版本"></p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/gif.gif" alt=""></p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1x7411M7Sf?p=5" target="_blank" rel="external">B站地址：MIT 6.824 Distributed Systems Spring 2020 分布式系统 中文翻译版合集</a></p>
</blockquote>
<p>除此之外，官方课件的地址在着这里，包括了上文提到的四个实验：</p>
<blockquote>
<p><a href="https://pdos.csail.mit.edu/6.824/schedule.html" target="_blank" rel="external">6.824 Schedule:Spring 2022</a></p>
</blockquote>
<p>Raft作业难度高？不要怕，这里已经网友贡献的学生作业指南：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/200903182" target="_blank" rel="external">Raft学生指南：一</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/203279804" target="_blank" rel="external">Raft学生指南：二</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/205315037" target="_blank" rel="external">Raft学生指南：三</a></p>
</blockquote>
<p>Raft算法不好理解，不够直观？我想这两个可视化呈现Raft算法的网站是你想要的：</p>
<blockquote>
<p><a href="https://raft.github.io/" target="_blank" rel="external">https://raft.github.io/</a>  在该页面的Raft Visualization部分，提供了一个可交互的Raft集群，你可以与该Raft集群进行交互以理解算法。</p>
<p><a href="http://thesecretlivesofdata.com/raft/#intro" target="_blank" rel="external">动画呈现Raft算法的主要细节与设计思想</a></p>
<p><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="external">Raft论文中文版：寻找一种易于理解的一致性算法</a></p>
</blockquote>
<p>除了课程本身外，如果你还觉得卷地不够爽，那么推荐一本书，可以搭配这门课程一起看，那就是经典的：《DDIA》，全名是《Design Data-Intensive Application》，中文翻译版本名为：<strong>《数据密集型应用系统设计》</strong>。</p>
<p>笔者曾经在工作早期看过几页，奈何功力不够，且内容硬核，遂放弃。现在笔者准备捡起来，努力往后看。</p>
<p>如果确实没有很多时间看视频，也没有关系，已经有大佬把视频内容用文字+图片方式整理出来，以gitbook方式分享了出来。</p>
<blockquote>
<p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/" target="_blank" rel="external">MIT 6.824 文字+图片整理版本</a></p>
</blockquote>
<p>作者将每一节课拆分成若干小节翻译并整理出来，在翻译的同时还加入了自己的理解，可以说是相当诚意的作品了。</p>
<p>上几张图简单感受一下：</p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/2.png" alt=""></p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/3.png" alt=""></p>
<p><img src="/2022/03/20/还在卷八股文？来和我卷MIT6-824吧/4.png" alt=""></p>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><p>简单说一下学习建议。</p>
<p>论文是一定得读的！论文是一定得读的！论文是一定得读的！</p>
<p>重要的话说三遍，因为课堂上，莫里斯教授是以思路讲解和答疑为主的，这都是建立在提前阅读了相关论文资料的前提上开展的，如果压根没有读过相关的论文，那么我相信基本上就是在听天书了。</p>
<p>论文的英文版PDF都能够在课程官网下载到，相关的中译版本也都能通过搜索找到，这里笔者就不提供了，相信有能力的读者都能够自己解决。</p>
<p>课程的schedule页面在   <a href="https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.824/schedule.html" target="_blank" rel="external">https://pdos.csail.mit.edu/6.824/schedule.html</a>，该页面上提供了所有必须的课程资料链接、论文pdf，以及lab作业的资料，甚至是课程视频，都有链接，读者可以按需求下载。</p>
<h2 id="关于LAB作业"><a href="#关于LAB作业" class="headerlink" title="关于LAB作业"></a>关于LAB作业</h2><p>关于如何完成作业，及视频中提到的LAB，笔者简单提供几点建议。</p>
<p>笔者看的版本为2020版本，它的开发语言为<code>Golang</code>，需要学习者提前学习一些go的语法和必须的概念知识。因此开发环境一定需要安装go。莫里斯教授在课堂上也对go语言的设计思想进行了讲解，可以作为参考。</p>
<p>快速学习上手go语言，可以使用以下线上学习指南，你可以在页面上直接写代码并看到直观的运行效果。</p>
<blockquote>
<p><a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="external">https://tour.go-zh.org/welcome/1</a>\</p>
</blockquote>
<p>操作系统建议使用类<code>Unix</code>环境（linux、mac均可），使用<code>Windows</code>需要你做额外的工作以去除环境相关的依赖，既繁琐又不一定保证成功。</p>
<p>建议使用<code>Goland</code>作为<code>IDE</code>开发环境，笔者是坚定的JetBrains粉。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>题目本身是一种调侃，卷八股文也没什么坏处，尤其是对于换工作的同学而言。</p>
<p>但是从长期看，我们还是需要整理一下自己的知识体系，通过学习一些优秀的论文、课程，做一些有代表性的练习来夯实基础。我想，这应当是破除程序员中年诅咒的方式之一吧。</p>
<p>废话不多说，让我们以梦为马，不负韶华。</p>
<p>学就对了！</p>
<p>(后续笔者也会不定时的发表MIT6.824相关的学习笔记和心得，同时欢迎公众号读者积极投稿，共同交流成长。)</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有没有想过，有这么一门课程。他不是简单的念PPT，他的老师是计算机史上五大黑客之一的罗伯特·塔潘-莫里斯(RobertTappanMorris)；&lt;/p&gt;
&lt;p&gt;有没有想过，有这么一门课程，他会带你阅读GFS、Map Reduce、RAFT、Big Table论文；&lt;/p&gt;
    
    </summary>
    
      <category term="MIT" scheme="http://wuwenliang.net/categories/MIT/"/>
    
    
      <category term="MIT" scheme="http://wuwenliang.net/tags/MIT/"/>
    
  </entry>
  
  <entry>
    <title>gRPC从入门到放弃之好家伙，双向流!</title>
    <link href="http://wuwenliang.net/2022/03/17/gRPC%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E4%B9%8B%E5%A5%BD%E5%AE%B6%E4%BC%99%EF%BC%8C%E5%8F%8C%E5%90%91%E6%B5%81/"/>
    <id>http://wuwenliang.net/2022/03/17/gRPC从入门到放弃之好家伙，双向流/</id>
    <published>2022-03-17T14:47:37.000Z</published>
    <updated>2022-03-17T15:55:59.139Z</updated>
    
    <content type="html"><![CDATA[<p>今天来实战一下gRPC的特性，双向流。</p>
<p>首先认识一下，什么是双向流？</p>
<blockquote>
<p>所谓双向流式 RPC ，是由客户端调用方法来初始化，而服务端接收到客户端的元数据，方法名和截止时间。</p>
<p>并且服务端可以选择发送回它的初始元数据或等待客户端发送请求的一种通信方式。</p>
<p>双向流，特点在于双向，也就是请求响应如何起作用是完全取决于应用怎么处理，因为客户端和服务端能在任意顺序上读写 ，也就是说这些流的操作是完全独立的。</p>
<p>例如服务端可以一直等待，直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像”乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。</p>
</blockquote>
<p>通俗地说，客户端发送了 N 个请求，服务端返回 N 个或者 M 个响应，该特性能够充分利用 HTTP/2.0 的多路复用功能。</p>
<p>某个时刻，HTTP/2.0 链路上可以既有请求也有响应，实现了全双工通信（对比单行道和双向车道），双向流式RPC通信用一个简单的图表示如下：</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之好家伙，双向流/grpc双向流.png" alt="grpc双向流.png"></p>
<a id="more"></a>
<h2 id="如何定义双向流呢？"><a href="#如何定义双向流呢？" class="headerlink" title="如何定义双向流呢？"></a>如何定义双向流呢？</h2><blockquote>
<p>一个 <em>双向流式 RPC</em> 是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器 可以以任意喜欢的顺序读写：</p>
<p>比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替 的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。开发者可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</p>
</blockquote>
<p>我们可以在服务的IDL定义文件proto中按照如下方式声明双向流式RPC接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Accepts a stream of RouteNotes sent while a route is being traversed,</div><div class="line">// while receiving other RouteNotes (e.g. from other users).</div><div class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</div></pre></td></tr></table></figure>
<p>声明方式为在请求和响应之前都添加关键字 <code>stream</code>。</p>
<h2 id="实操一把"><a href="#实操一把" class="headerlink" title="实操一把"></a>实操一把</h2><p>有了基本的概念，我们还是直接上手实操一下。</p>
<h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h3><blockquote>
<p>本案例为一个简单的应答接口，客户端向服务端发送问候语，服务端接受问候并返回服务端的问候。</p>
<p>由于是双向流，所以我们可以在一次接口调用中，发送多次问候。</p>
<p>运行的效果就是客户端与服务端的日志是交替打印的，也就是说服务端在客户端调用接口的过程中就可以逐步发送响应结果给客户端，而不是像阻塞式请求一样，等待客户端请求发送完毕，再统一一次性返回接口。</p>
</blockquote>
<p>这种双向流的接口处理模式的好处是显而易见的：</p>
<ul>
<li>如果传输的数据包过大，客户端可以将请求包拆分为多个小包发送至服务端。服务端依次处理小包，发送过程与处理过程互不干扰，互不依赖。</li>
<li>服务端不需要等待客户端包全部发送，才能处理以及响应。</li>
</ul>
<h3 id="服务IDL定义"><a href="#服务IDL定义" class="headerlink" title="服务IDL定义"></a>服务IDL定义</h3><blockquote>
<p>首先还是需要编写定义proto接口定义</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">syntax = &quot;proto3&quot;;</div><div class="line"></div><div class="line">option java_multiple_files = true;</div><div class="line">option java_package = &quot;com.snowalker.grpc.sdk.stream&quot;;</div><div class="line">option java_outer_classname = &quot;DoubleStreamProto&quot;;</div><div class="line"></div><div class="line">// 服务IDL定义</div><div class="line">service DoubleStreamService &#123;</div><div class="line">  rpc chat (stream ChatRequest) returns (stream ChatResponse) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 请求</div><div class="line">message ChatRequest &#123;</div><div class="line">  int32 userId = 1;</div><div class="line">  string msg = 2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 响应</div><div class="line">message ChatResponse &#123;</div><div class="line">  int32 userId = 1;</div><div class="line">  string msg = 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点关注chat接口定义，同时声明请求与响应为stream类型，标记这是一个双向流RPC。</p>
<p>对该proto文件进行编译，所在工程grpc-demo-sdk根路径下执行：</p>
<blockquote>
<p>mvn clean compile -DskipTests</p>
</blockquote>
<h3 id="编写服务端–实现服务逻辑"><a href="#编写服务端–实现服务逻辑" class="headerlink" title="编写服务端–实现服务逻辑"></a>编写服务端–实现服务逻辑</h3><p>服务端编写与普通的RPC接口相同，也是需要继承gRPC生成的XXXXGrpc.XXXXXImplBase，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public class DoubleStreamServiceImpl extends DoubleStreamServiceGrpc.DoubleStreamServiceImplBase &#123;</div></pre></td></tr></table></figure>
<p>重写chat方法，实现服务端逻辑，可以看到，业务逻辑同阻塞式接口不同，这里将业务逻辑写在了onNext回调方法中，因此我们可以知道这是一种异步回调机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * @param responseObserver</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public StreamObserver&lt;ChatRequest&gt; chat(StreamObserver&lt;ChatResponse&gt; responseObserver) &#123;</div><div class="line">	return new StreamObserver&lt;ChatRequest&gt;() &#123;</div><div class="line">		@Override</div><div class="line">		public void onNext(ChatRequest chatRequest) &#123;</div><div class="line"></div><div class="line">			int userId = chatRequest.getUserId();</div><div class="line">			String msg = chatRequest.getMsg();</div><div class="line"></div><div class="line">			logger.info(&quot;[DoubleStreamServiceImpl] 服务端处理开始....&quot;);</div><div class="line">			logger.info(&quot;[DoubleStreamServiceImpl] 客户端说: [&quot; + msg + &quot;]&quot;);</div><div class="line"></div><div class="line">			responseObserver.onNext(ChatResponse.newBuilder()</div><div class="line">					.setUserId(chatRequest.getUserId())</div><div class="line">					.setMsg(&quot;这是一条来自[服务端]的消息: 你好，收到了-&quot; + userId + &quot; 的消息. &quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ssSSS&quot;).format(new Date()) + &quot;\n&quot;)</div><div class="line">					.build());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void onError(Throwable throwable) &#123;</div><div class="line">			logger.warning(&quot;[DoubleStreamServiceImpl] gRPC dealing error&quot;);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public void onCompleted() &#123;</div><div class="line">			responseObserver.onCompleted();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造 Streaming 响应对象 StreamObserver并实现 onNext 等接口，由于服务端也是 Streaming模式，因此响应是多个的，也就是说 onNext 会被调用多次。</p>
<p>在onNext方法中编写服务端业务逻辑，这里主要做的就是取出请求体ChatRequest中的userId，以及msg，打印输出，构造响应对象ChatResponse，并return。</p>
<p>实现 onCompleted 方法，调用 <strong>responseObserver.onCompleted()</strong> 将请求返回客户端。</p>
<h3 id="编写服务端–绑定服务实现类"><a href="#编写服务端–绑定服务实现类" class="headerlink" title="编写服务端–绑定服务实现类"></a>编写服务端–绑定服务实现类</h3><p>同一般的阻塞式RPC接口相同，想要使双向流式RPC生效，还需要注册服务实现类到服务端ServerBuilder中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@SneakyThrows</div><div class="line">private void startServer() &#123;</div><div class="line">	int serverPort = 10881;</div><div class="line">	server = ServerBuilder.forPort(serverPort)</div><div class="line">			// 上文中的报价服务实现类</div><div class="line">			.addService(new OrderServiceImpl())</div><div class="line">			// 添加双向流式RPC实现</div><div class="line">			.addService(new DoubleStreamServiceImpl())</div><div class="line">			.build();</div><div class="line">	server.start();</div><div class="line"></div><div class="line">	logger.info(&quot;OrderServerBoot started, listening on:&quot; + serverPort);</div><div class="line"></div><div class="line">	// 优雅停机</div><div class="line">	addGracefulShowdownHook();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="编写客户端–实现客户端逻辑"><a href="#编写客户端–实现客户端逻辑" class="headerlink" title="编写客户端–实现客户端逻辑"></a>编写客户端–实现客户端逻辑</h3><blockquote>
<p>接着编写客户端逻辑。</p>
</blockquote>
<p>双向流式RPC的客户端实现方式与传统阻塞式客户端也是不同的。</p>
<blockquote>
<p>首先定义接口ExtendResponseObserver，继承StreamObserver，用于返回文本格式的响应体，方便观察。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ExtendResponseObserver&lt;T&gt; extends StreamObserver&lt;T&gt; &#123;</div><div class="line">    String getExtra();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>接着编写客户端逻辑。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * @author snowalker</div><div class="line"> * @version 1.0</div><div class="line"> * @date 2022/3/16 23:49</div><div class="line"> * @className</div><div class="line"> * @desc</div><div class="line"> */</div><div class="line">public class DoubleStreamClient &#123;</div><div class="line"></div><div class="line">	private static final Logger logger = Logger.getLogger(DoubleStreamClient.class.getName());</div><div class="line"></div><div class="line">	private final DoubleStreamServiceGrpc.DoubleStreamServiceStub doubleStreamServiceStub;</div><div class="line"></div><div class="line">	public DoubleStreamClient(ManagedChannel channel) &#123;</div><div class="line">		doubleStreamServiceStub = DoubleStreamServiceGrpc.newStub(channel);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public String chat(String msg, int user, int count) &#123;</div><div class="line">		ExtendResponseObserver&lt;ChatResponse&gt; chatResponseStreamObserver = new ExtendResponseObserver&lt;ChatResponse&gt;() &#123;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public String getExtra() &#123;</div><div class="line">				return stringBuilder.toString();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			// 用stringBuilder保存所有来自服务端的响应</div><div class="line">			private StringBuilder stringBuilder = new StringBuilder();</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void onNext(ChatResponse chatResponse) &#123;</div><div class="line">				logger.info(&quot;[DoubleStreamClient] onNext.....&quot;);</div><div class="line">				// 放入匿名类的成员变量中</div><div class="line">				System.out.println(chatResponse.getMsg());</div><div class="line">				stringBuilder.append(String.format(&quot;服务端响应:%s&lt;br&gt;, 用户:%d&quot; , chatResponse.getMsg(), chatResponse.getUserId()));</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void onError(Throwable throwable) &#123;</div><div class="line">				logger.warning(&quot;[DoubleStreamClient] gRPC request error&quot;);</div><div class="line">				stringBuilder.append(&quot;[DoubleStreamClient]chat gRPC error, &quot; + throwable.getMessage());</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public void onCompleted() &#123;</div><div class="line">				logger.info(&quot;[DoubleStreamClient] onCompleted&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		// 重点！！！！ RPC调用发起</div><div class="line">		StreamObserver&lt;ChatRequest&gt; chatRequestStreamObserver = doubleStreamServiceStub.chat(chatResponseStreamObserver);</div><div class="line"></div><div class="line">		for(int i = 0; i &lt; count; i++) &#123;</div><div class="line">			// 每次执行onNext都会发送一笔数据到服务端，</div><div class="line">			// 服务端的onNext方法都会被执行一次</div><div class="line">			ChatRequest chatRequest = ChatRequest.newBuilder()</div><div class="line">					.setUserId(user)</div><div class="line">					.setMsg(&quot;这是一条来自客户端的消息: 你好，&quot; + user + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ssSSS&quot;).format(new Date()))</div><div class="line">					.buildPartial();</div><div class="line">			LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(100));</div><div class="line">			chatRequestStreamObserver.onNext(chatRequest);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// 客户端告诉服务端：数据已经发完了</div><div class="line">		chatRequestStreamObserver.onCompleted();</div><div class="line"></div><div class="line">		logger.info(&quot;service finish&quot;);</div><div class="line"></div><div class="line">		return chatResponseStreamObserver.getExtra();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释下代码：</p>
<ul>
<li><p>客户端首先定义ExtendResponseObserver实例，并实现onNext、onError、onCompleted、getExtra等回调方法，用于处理服务端响应、异常情况、请求完成、返回字符形式的响应；</p>
</li>
<li><p>客户端通过在循环中调用 requestObserver 的 onNext 方法，发送请求消息到服务端；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 重点！！！！ RPC调用发起</div><div class="line">StreamObserver&lt;ChatRequest&gt; chatRequestStreamObserver = doubleStreamServiceStub.chat(chatResponseStreamObserver);</div></pre></td></tr></table></figure>
</li>
<li><p>当RPC请求发送完成之后，通过调用 <strong>onCompleted()</strong> 通知服务端数据已经发送完成；</p>
</li>
<li><p><strong>需要特别注意</strong>，客户端发送请求的stub为流式stub为<strong>DoubleStreamServiceGrpc.newStub(channel);</strong> 而非newBlockingStub。</p>
</li>
</ul>
<h3 id="案例运行"><a href="#案例运行" class="headerlink" title="案例运行"></a>案例运行</h3><p>案例运行完毕，我们运行看看效果。</p>
<p>本文开始，运行案例相关展示尝试通过gif动态展示：</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之好家伙，双向流/run.gif" alt="run.gif"></p>
<ul>
<li>先后启动了服务端与客户端，</li>
<li>客户端在一次调用中循环发送chat请求到服务端</li>
<li>服务端边处理请求边响应给客户端</li>
<li>可以看到服务端请求日志在一次调用中是边处理边打印的，客户端日志也是逐步输出的</li>
<li>表明双向流式RPC是异步的、高效的、非阻塞的。</li>
</ul>
<h3 id="客户端流式RPC机理"><a href="#客户端流式RPC机理" class="headerlink" title="客户端流式RPC机理"></a>客户端流式RPC机理</h3><p>稍微翻看源码，可以发现，实际上客户端底层 onNext 方法调用了 ClientCall 的消息发送方法，代码如下（CallToStreamObserverAdapter 类）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private static class CallToStreamObserverAdapter&lt;T&gt; extends ClientCallStreamObserver&lt;T&gt; &#123;</div><div class="line">	 private boolean frozen;</div><div class="line"> 	 private final ClientCall&lt;T, ?&gt; call;</div><div class="line"> 	 private Runnable onReadyHandler;</div><div class="line"> 	 private boolean autoFlowControlEnabled = true;</div><div class="line"> </div><div class="line"> 	 public CallToStreamObserverAdapter(ClientCall&lt;T, ?&gt; call) &#123;</div><div class="line"> 		this.call = call;</div><div class="line"> 	 &#125;</div><div class="line"> </div><div class="line"> 	 private void freeze() &#123;</div><div class="line"> 	 	this.frozen = true;</div><div class="line"> 	 &#125;</div><div class="line"> </div><div class="line"> 	 @Override</div><div class="line">  	 public void onNext(T value) &#123;</div><div class="line"> 		call.sendMessage(value);</div><div class="line"> 	 &#125;</div></pre></td></tr></table></figure>
<p>特别注意的是，对于双向 Streaming 模式，只支持异步调用方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文我们主要了解了gRPC的双向流式调用，对于这种流模式调用，可以充分利用 HTTP/2.0 协议的多路复用功能，实现在在一条 HTTP 链路上并行双向传输数据（全双工），它可以有效解决 HTTP/1.X 的数据单向传输问题，在大幅减少 HTTP 连接的情况下充分利用单条链路的性能，其性能可以媲美传统的 RPC 私有长连接协议：即通过更少的链路，实现更高的性能。</p>
<p>下篇文章，我们将为我们的grpc通信加入基于Nacos的服务注册发现能力，不见不散。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来实战一下gRPC的特性，双向流。&lt;/p&gt;
&lt;p&gt;首先认识一下，什么是双向流？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所谓双向流式 RPC ，是由客户端调用方法来初始化，而服务端接收到客户端的元数据，方法名和截止时间。&lt;/p&gt;
&lt;p&gt;并且服务端可以选择发送回它的初始元数据或等待客户端发送请求的一种通信方式。&lt;/p&gt;
&lt;p&gt;双向流，特点在于双向，也就是请求响应如何起作用是完全取决于应用怎么处理，因为客户端和服务端能在任意顺序上读写 ，也就是说这些流的操作是完全独立的。&lt;/p&gt;
&lt;p&gt;例如服务端可以一直等待，直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像”乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通俗地说，客户端发送了 N 个请求，服务端返回 N 个或者 M 个响应，该特性能够充分利用 HTTP/2.0 的多路复用功能。&lt;/p&gt;
&lt;p&gt;某个时刻，HTTP/2.0 链路上可以既有请求也有响应，实现了全双工通信（对比单行道和双向车道），双向流式RPC通信用一个简单的图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/17/gRPC从入门到放弃之好家伙，双向流/grpc双向流.png&quot; alt=&quot;grpc双向流.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://wuwenliang.net/categories/gRPC/"/>
    
    
      <category term="gRPC" scheme="http://wuwenliang.net/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC从入门到放弃之为gRPC添加服务发现</title>
    <link href="http://wuwenliang.net/2022/03/17/gRPC%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E4%B9%8B%E4%B8%BAgRPC%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    <id>http://wuwenliang.net/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/</id>
    <published>2022-03-17T14:47:22.000Z</published>
    <updated>2022-03-21T03:29:24.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文案例代码地址 ： <a href="https://github.com/TaXueWWL/grpc-demo" target="_blank" rel="external">https://github.com/TaXueWWL/grpc-demo</a></p>
</blockquote>
<p>有了前面的铺垫，我们已经对gRPC的java实现机制，代码编写手法、阻塞RPC以及双向流等内容有了全面、直观地了解。</p>
<p>本文我们继续本系列，为我们的gRPC添加服务注册发现。</p>
<h2 id="什么是服务注册发现？"><a href="#什么是服务注册发现？" class="headerlink" title="什么是服务注册发现？"></a>什么是服务注册发现？</h2><p>在RPC调用流程中，服务调用方需要知道服务提供方的地址和端口，才能发起RPC调用。</p>
<p>如果是直连式调用，则服务提供方需要提前配置服务提供方的地址和端口，也就是大白话说的 <code>写死</code>。</p>
<p>这种硬编码配置方式应对变化的能力很差，如果服务提供方宕机，服务消费者无法及时更换调用的目标，即便服务提供方存在冗余的机器，消费者也需要修改配置文件，重启服务才能调用至新的服务提供方节点。</p>
<p>通俗地说就是，这种方式将服务提供方与服务消费方耦合在了一起，不够灵活。</p>
<p>因此就需要有服务注册发现机制。如下图所示：</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/registry.png" alt="registry.png"></p>
<p>这里引用了dubbo框架的简易架构图。图中，服务提供方（provider）启动后会向注册中心（Registry）发起服务注册，将自己的ip、端口、其他元数据信息发送给注册中心。</p>
<p>注册中心维护了一个注册表，对上报的服务注册信息进行记录。</p>
<p>服务消费者（consumer）启动后会向注册中心（Registry）拉取服务提供方列表，也就是图中的 <strong>subscribe</strong> ，即：服务发现过程。</p>
<p>注意看，<strong>3.notify</strong> 是一条虚线，这里的含义是指，一旦服务提供方的注册信息发生变更，如现有节点下线（有可能是正常的关机，如版本发布；也有可能是意外宕机，都会导致服务下线。）或者新节点上线，都会造成注册中心中记录的服务注册信息发生变更，此时注册中心会通知服务消费者存在注册表信息变更，此时需要对最新的服务注册信息进行变更，一般有几种方式：</p>
<ol>
<li>注册中心通过push方式主动推送给消费者，这种方式往往通过消费者向注册中心注册监听器方式实现；</li>
<li>消费者定时通过pull方式从注册中心拉取注册表信息并在本地进行更新；</li>
<li>消费者通过长轮询方式从注册中心拉取注册表信息（推拉结合）。</li>
</ol>
<a id="more"></a>
<h2 id="有了服务注册发现机制之后，如何进行RPC调用？"><a href="#有了服务注册发现机制之后，如何进行RPC调用？" class="headerlink" title="有了服务注册发现机制之后，如何进行RPC调用？"></a>有了服务注册发现机制之后，如何进行RPC调用？</h2><p>那么，有了服务注册发现机制之后的RPC调用过程是怎样的？</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/select-provider.png" alt="select-provider.png"></p>
<p>如上图，实际上有了服务注册发现机制之后，服务消费者就不需要事先硬编码服务提供方的机器列表。</p>
<p>而是在运行时选择一台机器进行调用，这就是所谓的负载均衡策略，一般来说负载均衡有随机、轮询、加权随机、一致性哈希等方式。</p>
<p>图中使用的为轮询策略，则先选择192.168.21.1，下次选择192.168.21.2，然后重复这个过程。</p>
<p>如果服务提供方中某台机器下线，如192.168.21.1下线，则服务A的消费者能够感知到这个过程，拉取到全新的注册表信息后，下次调用就不会再去调用已下线的机器。</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/select-provider-2.png" alt="select-provider-2.png"></p>
<p>图中，提供者1离线，消费者拉取到最新的注册表信息，选择了健康状态的提供者2，发起RPC调用。</p>
<blockquote>
<p>毫不夸张地说，服务注册发现机制为RPC调用提供了运行时自愈的能力。</p>
</blockquote>
<h2 id="实战：为gRPC添加服务注册发现"><a href="#实战：为gRPC添加服务注册发现" class="headerlink" title="实战：为gRPC添加服务注册发现"></a>实战：为gRPC添加服务注册发现</h2><blockquote>
<p>有了前面的铺垫，那么我们就通过实战案例来讲解，如何为gRPC添加服务注册发现。</p>
</blockquote>
<p>本文使用Nacos作为服务注册中心选型。</p>
<blockquote>
<p>事实上，除了Nacos外，Zookeeper、Etcd、Redis等都可以作为服务注册中心。</p>
<p>之所以选择了Nacos，一方面是因为它足够成熟，Nacos起源于淘宝五彩石项目，支撑了双十一的海量流量；</p>
<p>成长于阿里云的ACM，开源后作为SpringCloudAlibaba默认的服务注册与配置中心，且它与CloudNative深度整合，是面向未来的一款工业级产品。</p>
<p>Nacos具备高可用能力，且拥有不错的可视化能力，因此我们选择它作为服务注册中心的选型。</p>
</blockquote>
<h2 id="实战：为服务提供方添加服务注册"><a href="#实战：为服务提供方添加服务注册" class="headerlink" title="实战：为服务提供方添加服务注册"></a>实战：为服务提供方添加服务注册</h2><blockquote>
<p>首先为服务提供方添加服务注册能力。</p>
</blockquote>
<p>定义服务注册配置类NacosRegistryConfig.java，封装服务提供方的ip、端口、服务名等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class NacosRegistryConfig &#123;</div><div class="line"></div><div class="line">   private static final Logger logger = Logger.getLogger(NacosRegistryConfig.class.getName());</div><div class="line"></div><div class="line">   /**Nacos服务单地址*/</div><div class="line">   private String serverAddr;</div><div class="line">   /**注册端口，一般就是服务暴露端口*/</div><div class="line">   private int port;</div><div class="line">   /**权重*/</div><div class="line">   private double weight = 1.0;</div><div class="line">   /**服务名*/</div><div class="line">   private String serviceName;</div><div class="line">   /**当前服务ip*/</div><div class="line">   private String ip;</div></pre></td></tr></table></figure>
<p>通过有参构造方法，在配置类创建期间获取到当前服务所处网络ip。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public NacosRegistryConfig(String serverAddr, int port, double weight, String serviceName) &#123;</div><div class="line">   this.serverAddr = serverAddr;</div><div class="line">   this.port = port;</div><div class="line">   this.weight = weight;</div><div class="line">   this.serviceName = serviceName;</div><div class="line"></div><div class="line">   try &#123;</div><div class="line">      InetAddress inetAddress = InetAddress.getLocalHost();</div><div class="line">      this.ip = inetAddress.getHostAddress();</div><div class="line">   &#125; catch (UnknownHostException e) &#123;</div><div class="line">      throw new RuntimeException(&quot;NacosRegistryConfig.getLocalHost failed.&quot;, e);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   logger.info(&quot;NacosRegistryConfig construct done. serverAddr=[&quot; + serverAddr +</div><div class="line">         &quot;],serviceName=&quot; + serviceName +</div><div class="line">         &quot;],ip=[&quot; + ip +</div><div class="line">         &quot;],port=[&quot; + port +</div><div class="line">         &quot;],weight=[&quot; + weight + &quot;]&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写服务注册核心方法，用于在服务提供方启动时向Nacos注册服务信息。注意：<strong>服务注册一定要在服务提供方服务发布之前！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">    public void register() &#123;</div><div class="line">      try &#123;</div><div class="line"></div><div class="line">         NamingService namingService = NamingFactory.createNamingService(serverAddr);</div><div class="line">         // 创建一个服务实例</div><div class="line">         Instance instance = new Instance();</div><div class="line">         instance.setIp(ip);</div><div class="line">         instance.setPort(port);</div><div class="line">         instance.setHealthy(false);</div><div class="line">         instance.setWeight(weight);</div><div class="line">         instance.setInstanceId(serviceName + &quot;-instance&quot;);</div><div class="line"></div><div class="line">         // 自定义服务元数据</div><div class="line">         Map&lt;String, String&gt; instanceMeta = new HashMap&lt;&gt;();</div><div class="line">         instanceMeta.put(&quot;language&quot;, &quot;java&quot;);</div><div class="line">         instanceMeta.put(&quot;rpc-framework&quot;, &quot;gRPC&quot;);</div><div class="line">         instance.setMetadata(instanceMeta);</div><div class="line">         </div><div class="line">         // 声明一个集群</div><div class="line">         Cluster cluster = new Cluster();</div><div class="line">         cluster.setName(&quot;DEFAULT-CLUSTER&quot;);</div><div class="line">         </div><div class="line">         // 为集群添加元数据</div><div class="line">         Map&lt;String, String&gt; clusterMeta = new HashMap&lt;&gt;();</div><div class="line">         clusterMeta.put(&quot;name&quot;, cluster.getName());</div><div class="line">         cluster.setMetadata(clusterMeta);</div><div class="line">		</div><div class="line">		// 为实例添加集群名称</div><div class="line">         instance.setClusterName(&quot;DEFAULT-CLUSTER&quot;);</div><div class="line">         </div><div class="line">         // 注册服务实例</div><div class="line">         namingService.registerInstance(serviceName, instance);</div><div class="line">		</div><div class="line">         namingService.subscribe(serviceName, new EventListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onEvent(Event event) &#123;</div><div class="line">               System.out.println(((NamingEvent)event).getServiceName());</div><div class="line">               System.out.println(((NamingEvent)event).getInstances());</div><div class="line">            &#125;</div><div class="line">         &#125;);</div><div class="line">      &#125; catch (NacosException e) &#123;</div><div class="line">         throw new RuntimeException(&quot;Register Services To Nacos Failed.&quot;, e);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法通过声明并创建NamingService，并为其添加了实例信息，设置了ip、端口、元信息、集群名称等属性，并通过<strong>namingService.registerInstance</strong> 完成服务的注册操作。</p>
<p>重点看一下registerInstance方法实现。</p>
<p>方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * register a instance to service with specified instance properties</div><div class="line"> *</div><div class="line"> * @param serviceName name of service</div><div class="line"> * @param instance    instance to register</div><div class="line"> * @throws NacosException</div><div class="line"> */</div><div class="line">void registerInstance(String serviceName, Instance instance) throws NacosException;</div></pre></td></tr></table></figure>
<p>接口方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void registerInstance(String serviceName, String groupName, Instance instance) throws NacosException &#123;</div><div class="line"></div><div class="line">    if (instance.isEphemeral()) &#123;</div><div class="line">        BeatInfo beatInfo = new BeatInfo();</div><div class="line">        beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));</div><div class="line">        beatInfo.setIp(instance.getIp());</div><div class="line">        beatInfo.setPort(instance.getPort());</div><div class="line">        beatInfo.setCluster(instance.getClusterName());</div><div class="line">        beatInfo.setWeight(instance.getWeight());</div><div class="line">        beatInfo.setMetadata(instance.getMetadata());</div><div class="line">        beatInfo.setScheduled(false);</div><div class="line">        long instanceInterval = instance.getInstanceHeartBeatInterval();</div><div class="line">        beatInfo.setPeriod(instanceInterval == 0 ? DEFAULT_HEART_BEAT_INTERVAL : instanceInterval);</div><div class="line"></div><div class="line">        beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，Nacos实际上是将服务注册信息封装到了BeatInfo对象中，在启动阶段，服务提供方主动上报服务注册信息。</p>
<p>在运行时，服务提供方通过心跳与Nacos服务端进行通信，并通过心跳来传递服务注册信息。一旦客户端发生变更，服务端可以在下次心跳感知到该变更，并做相应地修改。</p>
<p>这个设计是比较巧妙的。</p>
<h3 id="添加服务注册逻辑"><a href="#添加服务注册逻辑" class="headerlink" title="添加服务注册逻辑"></a>添加服务注册逻辑</h3><p>接着我们需要在服务提供者启动逻辑中，添加服务注册逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class OrderServerBoot &#123;</div><div class="line"></div><div class="line">   private static final Logger logger = Logger.getLogger(OrderServerBoot.class.getName());</div><div class="line"></div><div class="line">   private Server server;</div><div class="line"></div><div class="line">   // Nacos服务端地址</div><div class="line">   private static final String NACOS_SERVER_ADDR = &quot;nacos-server:8848&quot;;</div><div class="line"></div><div class="line">   @SneakyThrows</div><div class="line">   private void startServer() &#123;</div><div class="line">      int serverPort = 10881;</div><div class="line">      server = ServerBuilder.forPort(serverPort)</div><div class="line">            .addService(new OrderServiceImpl())</div><div class="line">            .addService(new DoubleStreamServiceImpl())</div><div class="line">            .build();</div><div class="line">            </div><div class="line">      // 服务注册</div><div class="line">      NacosRegistryConfig nacosRegistryConfig = new NacosRegistryConfig(NACOS_SERVER_ADDR, serverPort, 1.0, &quot;grpc-server-demo&quot;);</div><div class="line">      nacosRegistryConfig.register();       </div><div class="line">            </div><div class="line">      server.start();</div><div class="line"></div><div class="line">      logger.info(&quot;OrderServerBoot started, listening on:&quot; + serverPort);</div><div class="line"></div><div class="line">      // 优雅停机</div><div class="line">      addGracefulShowdownHook();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>重点看如下代码：</p>
<pre><code>// 服务注册
NacosRegistryConfig nacosRegistryConfig = new NacosRegistryConfig(NACOS_SERVER_ADDR, serverPort, 1.0, &quot;grpc-server-demo&quot;);
nacosRegistryConfig.register();       
</code></pre><p>在gRPC服务提供方的startServer方法中，通过该方法调用，向Nacos注册了服务提供者的信息（serverName为<strong>grpc-server-demo</strong>，该名称将唯一标识一个服务），然后再执行服务端启动逻辑，发布服务。</p>
<p>运行服务提供方的启动方法，观察Nacos管理平台的服务注册信息如下：</p>
<p><img src="/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/1.png" alt="1.png"></p>
<p><img src="/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/2.png" alt="2.png"></p>
<p>从管理平台能够看到我们的服务已经成功注册到了Nacos中，并且成功上报了元信息。</p>
<h2 id="实战：为服务消费者提供服务发现"><a href="#实战：为服务消费者提供服务发现" class="headerlink" title="实战：为服务消费者提供服务发现"></a>实战：为服务消费者提供服务发现</h2><p>继续给服务消费者添加服务发现能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class NacosRegistryConfig &#123;</div><div class="line"></div><div class="line">   private static final Logger logger = Logger.getLogger(NacosRegistryConfig.class.getName());</div><div class="line"></div><div class="line">   /**Nacos服务单地址*/</div><div class="line">   private String serverAddr;</div><div class="line">   /**服务名*/</div><div class="line">   private String providerServiceName;</div><div class="line">   /**提供者ip*/</div><div class="line">   private String providerIp;</div><div class="line">   /**提供者端口*/</div><div class="line">   private int providerPort;</div><div class="line"></div><div class="line">   public NacosRegistryConfig(String serverAddr, String providerServiceName) &#123;</div><div class="line">      this.serverAddr = serverAddr;</div><div class="line">      this.providerServiceName = providerServiceName;</div><div class="line">      // 服务发现</div><div class="line">      findServerList();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>与服务提供者类似，消费者也有一个NacosRegistryConfig服务发现配置类。</p>
<p>在构造方法中，构造注入Nacos服务端地址、服务提供方的服务名称，即上文中服务提供方注册到Nacos的 <code>grpc-server-demo</code> 。</p>
<p>构造方法中，完成服务发现，调用方法  <code>findServerList()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">private void findServerList() &#123;</div><div class="line">   try &#123;</div><div class="line">      // 连接Nacos-server</div><div class="line">      NamingService namingService = NamingFactory.createNamingService(serverAddr);</div><div class="line">      // 获取服务提供者实例信息</div><div class="line">      List&lt;Instance&gt; instances = namingService.getAllInstances(providerServiceName);</div><div class="line"></div><div class="line">      // 随机策略  TODO 改为基于取模粘滞请求，基于userId取模</div><div class="line">      int serverSize = instances.size();</div><div class="line">      Random random = new Random();</div><div class="line">      int index = random.nextInt(serverSize);</div><div class="line">      System.out.println(&quot;serverSize:&quot; + serverSize + &quot;选择的机器：&quot; + index);</div><div class="line">      Instance instance = instances.get(index);</div><div class="line">      // 获取ip 端口</div><div class="line">      this.providerIp = instance.getIp();</div><div class="line">      this.providerPort = instance.getPort();</div><div class="line"></div><div class="line">      // TODO还需要考虑对服务列表变更的处理</div><div class="line">      namingService.subscribe(providerServiceName, new EventListener() &#123;</div><div class="line">         @Override</div><div class="line">         public void onEvent(Event event) &#123;</div><div class="line">            System.out.println(((NamingEvent)event).getServiceName());</div><div class="line">            System.out.println(((NamingEvent)event).getInstances());</div><div class="line">         &#125;</div><div class="line">      &#125;);</div><div class="line">   &#125; catch (NacosException e) &#123;</div><div class="line">      throw new RuntimeException(&quot;Register Services To Nacos Failed.&quot;, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释下逻辑：</p>
<ul>
<li>首先建立到Nacos服务端的链接</li>
<li>构造NamingService实例，通过<code>NamingService.getAllInstances(String serviceName)</code> 方法获取到服务端所有以serviceName命名的实例列表（serviceName为服务端注册的属性）</li>
<li>这里使用随机策略从实例中随机获取一台服务端实例ip及端口（均为提供方注册好的）</li>
<li>添加一个服务变更监听</li>
</ul>
<blockquote>
<p>当逻辑执行完成，便会为NacosRegistryConfig的providerIp、providerPort赋值。</p>
<p>提供get方法以方便外部快速获取到提供者的ip与端口。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public String getProviderIp() &#123;</div><div class="line">   return providerIp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int getProviderPort() &#123;</div><div class="line">   return providerPort;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="发起服务调用"><a href="#发起服务调用" class="headerlink" title="发起服务调用"></a>发起服务调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 端口及ip</div><div class="line">int port = nacosRegistryConfig.getProviderPort();</div><div class="line">String providerIp = nacosRegistryConfig.getProviderIp();</div><div class="line">OrderClientAgent orderClientAgent = new OrderClientAgent(providerIp, port);</div></pre></td></tr></table></figure>
<p>接着只需要替换原先的获取服务提供方ip、端口的逻辑，改为从nacosRegistryConfig中获取，其余逻辑保持不变即可。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>先后启动服务提供方、服务消费方，查看控制台日志输出。</p>
<blockquote>
<p>提供方</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">三月 21, 2022 10:57:50 上午 OrderServerBoot startServer</div><div class="line">信息: OrderServerBoot started, listening on:10881</div><div class="line">三月 21, 2022 10:57:50 上午 registry.NacosRegistryConfig &lt;init&gt;</div><div class="line">信息: NacosRegistryConfig construct done. serverAddr=[nacos-server:8848],serviceName=grpc-server-demo],ip=[169.254.19.253],port=[10881],weight=[1.0]</div></pre></td></tr></table></figure>
<blockquote>
<p>消费方</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">三月 21, 2022 10:58:30 上午 OrderClientBoot doPlaceOrder</div><div class="line">信息: client placeOrder end. response:userId: 10086</div><div class="line">,resultCode:SUCCESS</div><div class="line">三月 21, 2022 10:58:30 上午 agent.OrderClientAgent queryOrders</div><div class="line">信息: client queryOrders start. request:userId: 10086</div><div class="line"></div><div class="line">三月 21, 2022 10:58:30 上午 OrderClientBoot doQueryOrder</div><div class="line">信息: client queryOrders end. response:userId: 10086</div><div class="line">totalPrice: &quot;207.5000&quot;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 2095135383</div><div class="line">  orderPrice: &quot;12.50&quot;</div><div class="line">  orderAmount: &quot;15.00&quot;</div><div class="line">  productId: 1</div><div class="line">&#125;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 2095135383</div><div class="line">  orderPrice: &quot;10.00&quot;</div><div class="line">  orderAmount: &quot;2.00&quot;</div><div class="line">  productId: 2</div><div class="line">&#125;</div><div class="line">......</div></pre></td></tr></table></figure>
<p>可以看到，我们仍旧能够成功发起服务调用。</p>
<blockquote>
<p>这里提个问题，假设我们部署多个服务提供方，不修改消费者逻辑，是否仍然能够成功发起RPC调用？</p>
</blockquote>
<p>答案是肯定的。由于服务注册发现的存在，消费者能够及时获取到提供方的服务变更信息，在运行期能够根据我们指定的策略，选择健康的提供者实例并发起RPC调用。</p>
<p>感兴趣的读者可以自行实验，本文的代码已上传github，地址：<a href="https://github.com/TaXueWWL/grpc-demo。读者需要自己安装nacos实例。" target="_blank" rel="external">https://github.com/TaXueWWL/grpc-demo。读者需要自己安装nacos实例。</a></p>
<p>如果有linux环境且安装了docker，则可以通过docker方式启动一个Nacos实例。</p>
<h3 id="附录：docker方式安装Nacos-Server"><a href="#附录：docker方式安装Nacos-Server" class="headerlink" title="附录：docker方式安装Nacos-Server"></a>附录：docker方式安装Nacos-Server</h3><blockquote>
<p>以下操作，笔者是在centos7实现的。</p>
</blockquote>
<p>安装docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install docker</div></pre></td></tr></table></figure>
<p>设置开机启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl enable docker</div></pre></td></tr></table></figure>
<p>启动docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start docker</div></pre></td></tr></table></figure>
<p>查看docker当前版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker version</div></pre></td></tr></table></figure>
<blockquote>
<p>接着安装Nacos-Server</p>
</blockquote>
<p>Nacos-server镜像地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://hub.docker.com/r/nacos/nacos-server</div></pre></td></tr></table></figure>
<p>docker方式安装并启动Nacos-server（版本1.1.4，具体版本可以自行指定）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name nacos -e MODE=standalone -p 8848:8848 -d nacos/nacos-server:1.1.4</div></pre></td></tr></table></figure>
<p>访问Nacos-server：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://ip:8848/nacos/</div><div class="line">默认用户名：nacos</div><div class="line">默认密码：nacos</div></pre></td></tr></table></figure>
<p><img src="/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/3.png" alt=""></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文重点介绍了服务注册发现的作用及意义，并实战了如何为gRPC添加了服务注册发现能力。</p>
<p>在后面的文章中，我们将继续探究gRPC的深层原理，并且会对Nacos的服务注册发现、配置管理等内容进行源码级别的学习与研究，敬请期待。</p>
<blockquote>
<p>本文案例代码地址：<a href="https://github.com/TaXueWWL/grpc-demo" target="_blank" rel="external">https://github.com/TaXueWWL/grpc-demo</a></p>
</blockquote>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文案例代码地址 ： &lt;a href=&quot;https://github.com/TaXueWWL/grpc-demo&quot;&gt;https://github.com/TaXueWWL/grpc-demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了前面的铺垫，我们已经对gRPC的java实现机制，代码编写手法、阻塞RPC以及双向流等内容有了全面、直观地了解。&lt;/p&gt;
&lt;p&gt;本文我们继续本系列，为我们的gRPC添加服务注册发现。&lt;/p&gt;
&lt;h2 id=&quot;什么是服务注册发现？&quot;&gt;&lt;a href=&quot;#什么是服务注册发现？&quot; class=&quot;headerlink&quot; title=&quot;什么是服务注册发现？&quot;&gt;&lt;/a&gt;什么是服务注册发现？&lt;/h2&gt;&lt;p&gt;在RPC调用流程中，服务调用方需要知道服务提供方的地址和端口，才能发起RPC调用。&lt;/p&gt;
&lt;p&gt;如果是直连式调用，则服务提供方需要提前配置服务提供方的地址和端口，也就是大白话说的 &lt;code&gt;写死&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这种硬编码配置方式应对变化的能力很差，如果服务提供方宕机，服务消费者无法及时更换调用的目标，即便服务提供方存在冗余的机器，消费者也需要修改配置文件，重启服务才能调用至新的服务提供方节点。&lt;/p&gt;
&lt;p&gt;通俗地说就是，这种方式将服务提供方与服务消费方耦合在了一起，不够灵活。&lt;/p&gt;
&lt;p&gt;因此就需要有服务注册发现机制。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/17/gRPC从入门到放弃之为gRPC添加服务发现/registry.png&quot; alt=&quot;registry.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里引用了dubbo框架的简易架构图。图中，服务提供方（provider）启动后会向注册中心（Registry）发起服务注册，将自己的ip、端口、其他元数据信息发送给注册中心。&lt;/p&gt;
&lt;p&gt;注册中心维护了一个注册表，对上报的服务注册信息进行记录。&lt;/p&gt;
&lt;p&gt;服务消费者（consumer）启动后会向注册中心（Registry）拉取服务提供方列表，也就是图中的 &lt;strong&gt;subscribe&lt;/strong&gt; ，即：服务发现过程。&lt;/p&gt;
&lt;p&gt;注意看，&lt;strong&gt;3.notify&lt;/strong&gt; 是一条虚线，这里的含义是指，一旦服务提供方的注册信息发生变更，如现有节点下线（有可能是正常的关机，如版本发布；也有可能是意外宕机，都会导致服务下线。）或者新节点上线，都会造成注册中心中记录的服务注册信息发生变更，此时注册中心会通知服务消费者存在注册表信息变更，此时需要对最新的服务注册信息进行变更，一般有几种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册中心通过push方式主动推送给消费者，这种方式往往通过消费者向注册中心注册监听器方式实现；&lt;/li&gt;
&lt;li&gt;消费者定时通过pull方式从注册中心拉取注册表信息并在本地进行更新；&lt;/li&gt;
&lt;li&gt;消费者通过长轮询方式从注册中心拉取注册表信息（推拉结合）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://wuwenliang.net/categories/gRPC/"/>
    
    
      <category term="gRPC" scheme="http://wuwenliang.net/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>学点儿gRPC-从入门到放弃</title>
    <link href="http://wuwenliang.net/2022/03/12/%E5%AD%A6%E7%82%B9%E5%84%BFgRPC-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>http://wuwenliang.net/2022/03/12/学点儿gRPC-从入门到放弃/</id>
    <published>2022-03-12T13:31:45.000Z</published>
    <updated>2022-03-13T04:35:29.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微服务如火如荼的当下，各种服务框架层出不穷。Dubbo、SpringCloud在国内Java后端微服务领域目前占据大部分份额。</p>
<p>但是随着云原生愈发普及，具备跨语言、高性能特性的RPC通信框架横空出世，其中gRPC与Thrift是其中的佼佼者。</p>
</blockquote>
<p>本文我们将视角集中在gRPC这RPC框架。</p>
<blockquote>
<p>gRPC 是Google开源的高性能、通用的RPC框架。客户端与服务端约定接口调用， 可以在各种环境中运行，具有跨语言特性， 适合构建分布式、微服务应用。</p>
</blockquote>
<p>个人认为，gRPC最为杀手锏的特性就是“跨语言”，其次才是高性能。</p>
<p>它的跨语言特性体现在，通过定义IDL（接口定义语言），隔离了不同编程语言之间的差异，对IDL进行编译后，生成对应编程语言的nativeCode，让开发者能够集中注意在实现业务需求上，而不需要花费额外的精力在语言层面上。</p>
<blockquote>
<p>官网的一张图能够很好的体现这个特点</p>
</blockquote>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpc_server.png" alt="gRPC多语言"></p>
<a id="more"></a>
<h2 id="gRPC特性介绍"><a href="#gRPC特性介绍" class="headerlink" title="gRPC特性介绍"></a>gRPC特性介绍</h2><blockquote>
<p>gRPC具备以下特性</p>
</blockquote>
<ul>
<li><p>性能优异：</p>
<ol>
<li><p>它采用Proto Buffer作序列化传输媒介， 对比JSON与XML有数倍提升。</p>
</li>
<li><p>采用HTTP2协议， 对头部信息（header）压缩， 对连接进行复用，能够减少TCP连接次数。</p>
</li>
<li><p>针对Java语言，gRPC底层采用Netty作为NIO处理框架， 性能强劲。</p>
</li>
</ol>
</li>
<li>多语言支持，多客户端接入， 支持C++/GO/Ruby等语言。</li>
<li>支持负载均衡、跟踪、健康检查和认证。</li>
</ul>
<h2 id="gRPC的线程模型是怎样的？"><a href="#gRPC的线程模型是怎样的？" class="headerlink" title="gRPC的线程模型是怎样的？"></a>gRPC的线程模型是怎样的？</h2><blockquote>
<p>笔者主力语言为Java，因此我们讲解也集中在Java的实现上。</p>
</blockquote>
<p>gRPC的Java实现，服务端底层采用了Netty作为核心处理框架，因此其线程模型核心也是遵循了 Netty 的线程分工原则。</p>
<p>协议层消息的接收和编解码由 Netty 的 I/O(NioEventLoop) 线程负责, 应用层的处理由应用线程负责，防止由于应用处理耗时而阻塞 Netty 的 I/O 线程。</p>
<blockquote>
<p>Netty线程模型是基于NIO的Reactor模式。</p>
</blockquote>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpc-03-04.png" alt="gRPC-Java线程模型"></p>
<blockquote>
<p>Netty是基于NIO构建的通信框架。</p>
</blockquote>
<p>在 Java NIO 中最重要的概念就是多路复用器 Selector，它是 Java NIO 编程的基础。Selector提供了选择已经就绪的任务的能力。</p>
<blockquote>
<p>简单来讲，Selector 会不断地轮询注册在其上的 Channel，如果某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I/O 操作。</p>
</blockquote>
<p>一般来说，一个 I/O 线程会聚合一个 Selector，一个 Selector 可以同时注册 N 个 Channel, 这样单个</p>
<p>I/O 线程就可以同时并发处理多个客户端连接。</p>
<p>又由于 I/O 操作是非阻塞的，因此也不会受限于网络速度和对方端点的处理时延，可靠性和效率都得到了很大提升。</p>
<h2 id="gRPC客户端如何请求服务端"><a href="#gRPC客户端如何请求服务端" class="headerlink" title="gRPC客户端如何请求服务端?"></a>gRPC客户端如何请求服务端?</h2><blockquote>
<p>作为RPC框架，至少有客户端和服务端两个角色，对于gRPC而言，客户端请求服务端的调用过程如图所示。</p>
</blockquote>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpc_client_flow.png" alt="客户端请求服务端"></p>
<p>具体过程：</p>
<ul>
<li>【Stub生成】客户端生成Stub ，通过Stub发起 RPC远程服务调用 ；</li>
<li>【负载均衡】客户端获取服务端的地址信息（列表），使用默认的 LoadBalancer 策略，选择一个具体的 gRPC 服务端进行调用；</li>
<li>【建立链接】如果客户端与服务端之间没有可用的连接，则创建 NettyClientTransport 和 NettyClientHandler，建立 HTTP/2 连接；</li>
<li>【客户端请求序列化】对请求使用 PB（Protobuf）序列化，并通过 HTTP/2 Stream 发送给 gRPC 服务端；</li>
<li>【服务端反序列化】服务端接收到响应之后，使用 PB（Protobuf）做反序列化。</li>
<li>【请求响应】回调 GrpcFuture 的 set(Response) 方法，唤醒阻塞的客户端调用线程，获取 RPC 响应数据。</li>
</ul>
<h2 id="gRPC性能到底有多强？"><a href="#gRPC性能到底有多强？" class="headerlink" title="gRPC性能到底有多强？"></a>gRPC性能到底有多强？</h2><blockquote>
<p>没有对比就没有发言权。</p>
</blockquote>
<p>在不同的操作系统，不同请求数量下，对gRPC与Rest请求进行对比的结论如下：</p>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/grpcvsrest.png" alt=""></p>
<blockquote>
<p>官网也给出了权威性的比对，具体比对gRPC+ProtoBuf与Http+JSON方式请求的差异。</p>
</blockquote>
<p><a href="https://github.com/plutov/benchmark-grpc-protobuf-vs-http-json" target="_blank" rel="external">官方性能比对结果</a></p>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/image-20200207140210335.png" alt=""></p>
<p><strong>实测结果显示GRpc的通讯方案, 性能有32%的提升, 资源占用降低30%左右。</strong></p>
<h2 id="gRPC-Java-服务调用实战"><a href="#gRPC-Java-服务调用实战" class="headerlink" title="gRPC-Java 服务调用实战"></a>gRPC-Java 服务调用实战</h2><blockquote>
<p>按照惯例，我们提供一个简单的订单案例展示gRPC在实际开发中如何使用。</p>
<p>该案例在实际中的意义为：提供一个报价服务，客户端发送下单请求到服务端进行报价，服务端对用户报价单进行汇总计算，并提供查询接口供客户端查询。</p>
<p>主要提供批量下单及查询用户订单能力。</p>
</blockquote>
<p>流程图大致如下：</p>
<p><img src="/2022/03/12/学点儿gRPC-从入门到放弃/demo.png" alt="流程图"></p>
<p>工程结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">|==&gt; grpc-demo			   父级工程， 管理依赖相关</div><div class="line">     |==&gt;grpc-demo-sdk     通用jar依赖，生成protobuf对象与gRPC Service，供提供方与调用方使用</div><div class="line">     |==&gt;grpc-server-demo  服务端，提供下单及订单查询服务</div><div class="line">     |==&gt;grpc-client-demo  客户端，负责调用gRPC服务</div></pre></td></tr></table></figure>
<h2 id="grpc-demo父工程"><a href="#grpc-demo父工程" class="headerlink" title="grpc-demo父工程"></a>grpc-demo父工程</h2><blockquote>
<p>父工程相对比较简单，管理了子工程及依赖版本。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>grpc-server-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>grpc-client-demo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">module</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">grpc-version</span>&gt;</span>1.44.1<span class="tag">&lt;/<span class="name">grpc-version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="grpc-demo-sdk"><a href="#grpc-demo-sdk" class="headerlink" title="grpc-demo-sdk"></a>grpc-demo-sdk</h2><blockquote>
<p>grpc-demo-sdk是较为关键的公共依赖，主要基于proto对服务进行定义，生成java代码并打包供服务提供方与消费方使用。</p>
</blockquote>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><blockquote>
<p>sdk的pom文件如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/proto<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>proto<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.19.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.43.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>重点关注一下plugin，我们使用protobuf-maven-plugin作为protobuf的编译工具，有了该插件，我们在执行mvn clean compile命令时便可以实现将proto编译为java代码的目的。</p>
<p>同样，执行mvn clean package命令可以实现将proto编译为java代码并打包为jar包的目的。</p>
<p>可以说是极为方便了。</p>
</blockquote>
<h3 id="编写proto文件，定义服务接口"><a href="#编写proto文件，定义服务接口" class="headerlink" title="编写proto文件，定义服务接口"></a>编写proto文件，定义服务接口</h3><blockquote>
<p>编写OrderService.proto，定义服务接口，主要定义了查询用户订单，批量下单接口，及对应的各种实体和枚举。</p>
</blockquote>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">syntax = <span class="string">"proto3"</span>;</div><div class="line"></div><div class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</div><div class="line"><span class="keyword">option</span> java_package = <span class="string">"com.snowalker.grpc.sdk"</span>;</div><div class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"OrderServiceProto"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 订单服务IDL定义</span></div><div class="line"><span class="class"><span class="keyword">service</span> <span class="title">OrderService</span> </span>&#123;</div><div class="line">  <span class="comment">// 查询用户订单列表</span></div><div class="line">  <span class="function"><span class="keyword">rpc</span> queryUserOrders (QueryUserOrderRequest) <span class="keyword">returns</span> (QueryUserOrderResponse) &#123;</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 下单</div><div class="line">  <span class="keyword">rpc</span> placeOrder(PlaceOrderRequest) <span class="keyword">returns</span> (PlaceOrderRequestResponse) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 查询订单请求</div><div class="line">message QueryUserOrderRequest &#123;</div><div class="line">  int32 userId = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 查询订单响应</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">QueryUserOrderResponse</span> </span>&#123;</div><div class="line">  <span class="built_in">int32</span> userId = <span class="number">1</span>;</div><div class="line">  <span class="built_in">string</span> totalPrice = <span class="number">2</span>;</div><div class="line">  <span class="keyword">repeated</span> UserOrder userOrder = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 批量下单请求</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">PlaceOrderRequest</span> </span>&#123;</div><div class="line">  <span class="built_in">int32</span> userId = <span class="number">1</span>;</div><div class="line">  <span class="keyword">repeated</span> PlaceUserOrderParam placeUserOrderParam = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 批量下单响应</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">PlaceOrderRequestResponse</span> </span>&#123;</div><div class="line">  <span class="built_in">int32</span> userId = <span class="number">1</span>;</div><div class="line">  ResultCode resultCode = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 订单查询详情</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserOrder</span> </span>&#123;</div><div class="line">  <span class="built_in">int64</span> orderId = <span class="number">1</span>;</div><div class="line">  <span class="built_in">string</span> orderPrice = <span class="number">2</span>;</div><div class="line">  <span class="built_in">string</span> orderAmount = <span class="number">3</span>;</div><div class="line">  <span class="built_in">int32</span> productId = <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 下单请求详情</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">PlaceUserOrderParam</span> </span>&#123;</div><div class="line">  <span class="built_in">string</span> orderPrice = <span class="number">1</span>;    <span class="comment">// 单价</span></div><div class="line">  <span class="built_in">string</span> orderAmount = <span class="number">2</span>;   <span class="comment">// 数量</span></div><div class="line">  <span class="built_in">int32</span> productId = <span class="number">3</span>;      <span class="comment">// 商品id</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 结果枚举：成功/失败</span></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ResultCode</span> </span>&#123;</div><div class="line">  SUCCESS = <span class="number">0</span>;</div><div class="line">  FAILURE = <span class="number">1</span>;</div><div class="line">  UNKNOWN = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如下为protobuf与java、c++对应关系，</p>
<p>更多protobuf的使用，请参考官网文档：<a href="https://developers.google.com/protocol-buffers/docs/javatutorial" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/javatutorial</a></p>
</blockquote>
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td style="vertical-align:top;"> <p><strong>protobuf</strong><strong>属性</strong></p> </td><td style="vertical-align:top;"> <p><strong>C++</strong><strong>属性</strong></p> </td><td style="vertical-align:top;"> <p><strong>java</strong><strong>属性</strong></p> </td><td style="vertical-align:top;"> <p><strong>备注</strong></p> </td></tr><tr><td style="vertical-align:top;"> <p>double</p> </td><td style="vertical-align:top;"> <p>double</p> </td><td style="vertical-align:top;"> <p>double</p> </td><td style="vertical-align:top;"> <p>固定8个字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>float</p> </td><td style="vertical-align:top;"> <p>float</p> </td><td style="vertical-align:top;"> <p>float</p> </td><td style="vertical-align:top;"> <p>固定4个字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>使用变长编码，对于负数编码效率较低，如果经常使用负数，建议使用sint32</p> </td></tr><tr><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>使用变长编码，对于负数编码效率较低，如果经常使用负数，建议使用sint64</p> </td></tr><tr><td style="vertical-align:top;"> <p>uint32</p> </td><td style="vertical-align:top;"> <p>uint32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>使用变长编码</p> </td></tr><tr><td style="vertical-align:top;"> <p>uint64</p> </td><td style="vertical-align:top;"> <p>uint64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>使用变长编码</p> </td></tr><tr><td style="vertical-align:top;"> <p>sint32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>采用zigzag压缩，对负数编码效率比int32高</p> </td></tr><tr><td style="vertical-align:top;"> <p>sint64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>采用zigzag压缩，对负数编码效率比int64高</p> </td></tr><tr><td style="vertical-align:top;"> <p>fixed32</p> </td><td style="vertical-align:top;"> <p>uint32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>总是4字节，如果数据&gt;2^28，编码效率高于unit32</p> </td></tr><tr><td style="vertical-align:top;"> <p>fixed64</p> </td><td style="vertical-align:top;"> <p>uint64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>总是8字节，如果数据&gt;2^56，编码效率高于unit32</p> </td></tr><tr><td style="vertical-align:top;"> <p>sfixed32</p> </td><td style="vertical-align:top;"> <p>int32</p> </td><td style="vertical-align:top;"> <p>int</p> </td><td style="vertical-align:top;"> <p>总是4字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>sfixed64</p> </td><td style="vertical-align:top;"> <p>int64</p> </td><td style="vertical-align:top;"> <p>long</p> </td><td style="vertical-align:top;"> <p>总是8字节</p> </td></tr><tr><td style="vertical-align:top;"> <p>bool</p> </td><td style="vertical-align:top;"> <p>bool</p> </td><td style="vertical-align:top;"> <p>boolean</p> </td><td style="vertical-align:top;"> <p>&nbsp;</p> </td></tr><tr><td style="vertical-align:top;"> <p>string</p> </td><td style="vertical-align:top;"> <p>string</p> </td><td style="vertical-align:top;"> <p>String</p> </td><td style="vertical-align:top;"> <p>一个字符串必须是utf-8编码或者7-bit的ascii编码的文本</p> </td></tr><tr><td style="vertical-align:top;"> <p>bytes</p> </td><td style="vertical-align:top;"> <p>string</p> </td><td style="vertical-align:top;"> <p>ByteString</p> </td><td style="vertical-align:top;"> <p>可能包含任意顺序的字节数据</p> </td></tr></tbody></table>

<h3 id="编译打包grpc-demo-sdk工程"><a href="#编译打包grpc-demo-sdk工程" class="headerlink" title="编译打包grpc-demo-sdk工程"></a>编译打包grpc-demo-sdk工程</h3><blockquote>
<p>编写完proto文件后，对grpc-demo-sdk工程执行打包编译</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -DskipTests</div></pre></td></tr></table></figure>
<h2 id="编写服务端grpc-server-demo"><a href="#编写服务端grpc-server-demo" class="headerlink" title="编写服务端grpc-server-demo"></a>编写服务端grpc-server-demo</h2><blockquote>
<p>接着编写服务端</p>
</blockquote>
<h3 id="pom-xml-1"><a href="#pom-xml-1" class="headerlink" title="pom.xml"></a>pom.xml</h3><blockquote>
<p>服务端pom内容如下</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-server-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>除了lombok外，其余的依赖由grpc-demo-sdk间接引入。</p>
<h3 id="编写OrderServiceImpl实现核心业务逻辑"><a href="#编写OrderServiceImpl实现核心业务逻辑" class="headerlink" title="编写OrderServiceImpl实现核心业务逻辑"></a>编写OrderServiceImpl实现核心业务逻辑</h3><blockquote>
<p>首先编写OrderServiceImpl，实现核心的下单与查订单业务逻辑。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> snowalker</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span> 2022/3/12 23:47</div><div class="line"> * <span class="doctag">@className</span></div><div class="line"> * <span class="doctag">@desc</span></div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">extends</span> <span class="title">OrderServiceGrpc</span>.<span class="title">OrderServiceImplBase</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderServiceImpl.class.getName());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, LinkedList&lt;UserOrder&gt;&gt; USER_MEMORY_ORDER_BOOK = Maps.newConcurrentMap();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * &lt;pre&gt;</div><div class="line">	 * 查询用户订单列表</div><div class="line">	 * &lt;/pre&gt;</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 * <span class="doctag">@param</span> responseObserver</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryUserOrders</span><span class="params">(QueryUserOrderRequest request, StreamObserver&lt;QueryUserOrderResponse&gt; responseObserver)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> userId = request.getUserId();</div><div class="line">		<span class="comment">// 查询订单</span></div><div class="line">		List&lt;UserOrder&gt; orders = USER_MEMORY_ORDER_BOOK.getOrDefault(userId, Lists.newLinkedList());</div><div class="line"></div><div class="line">		<span class="comment">// 计算总价</span></div><div class="line">		String totalPrice = calculateTotalPrice(orders);</div><div class="line"></div><div class="line">		<span class="comment">// 组装response</span></div><div class="line">		QueryUserOrderResponse queryUserOrderResponse = QueryUserOrderResponse.newBuilder()</div><div class="line">				.setUserId(userId)</div><div class="line">				.addAllUserOrder(orders)</div><div class="line">				.setTotalPrice(totalPrice)</div><div class="line">				.build();</div><div class="line"></div><div class="line">		logger.info(<span class="string">"[Server] queryUserOrders, request:"</span> + request.toString() + <span class="string">"\n"</span> + <span class="string">"response:"</span> + queryUserOrderResponse.toString());</div><div class="line"></div><div class="line">		<span class="comment">// 响应</span></div><div class="line">		responseObserver.onNext(queryUserOrderResponse);</div><div class="line">		responseObserver.onCompleted();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">calculateTotalPrice</span><span class="params">(List&lt;UserOrder&gt; orders)</span> </span>&#123;</div><div class="line">		Optional&lt;BigDecimal&gt; count = orders.stream()</div><div class="line">				.map(order -&gt; <span class="keyword">new</span> BigDecimal(order.getOrderAmount()).multiply(<span class="keyword">new</span> BigDecimal(order.getOrderPrice())))</div><div class="line">				.reduce(BigDecimal::add);</div><div class="line">		<span class="keyword">return</span> count.orElseGet(() -&gt; BigDecimal.ZERO).toPlainString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * &lt;pre&gt;</div><div class="line">	 * 下单</div><div class="line">	 * &lt;/pre&gt;</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 * <span class="doctag">@param</span> responseObserver</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(PlaceOrderRequest request, StreamObserver&lt;PlaceOrderRequestResponse&gt; responseObserver)</span> </span>&#123;</div><div class="line"></div><div class="line">		ThreadLocalRandom orderIdGenerator = ThreadLocalRandom.current();</div><div class="line"></div><div class="line">		PlaceOrderRequestResponse.Builder placeOrderRequestResponse = PlaceOrderRequestResponse.newBuilder();</div><div class="line"></div><div class="line">		<span class="keyword">int</span> userId = request.getUserId();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (request.getPlaceUserOrderParamCount() &lt;= <span class="number">0</span>) &#123;</div><div class="line">			placeOrderRequestResponse.setUserId(userId).setResultCode(ResultCode.FAILURE).build();</div><div class="line">			responseObserver.onNext(placeOrderRequestResponse.build());</div><div class="line">			responseObserver.onCompleted();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 获取用户订单列表</span></div><div class="line">		LinkedList&lt;UserOrder&gt; userOrderList = USER_MEMORY_ORDER_BOOK.getOrDefault(userId, Lists.newLinkedList());</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (userOrderList.size() == <span class="number">0</span>) &#123;</div><div class="line">			USER_MEMORY_ORDER_BOOK.put(userId, Lists.newLinkedList());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> orderId = getOrderId(orderIdGenerator);</div><div class="line"></div><div class="line">		<span class="comment">// 本次订单</span></div><div class="line">		List&lt;UserOrder&gt; userOrders = request.getPlaceUserOrderParamList().stream().map(</div><div class="line">				param -&gt; UserOrder.newBuilder()</div><div class="line">						.setOrderId(orderId)</div><div class="line">						.setOrderAmount(param.getOrderAmount())</div><div class="line">						.setOrderPrice(param.getOrderPrice())</div><div class="line">						.setProductId(param.getProductId())</div><div class="line">						.build()).collect(Collectors.toList());</div><div class="line"></div><div class="line">		<span class="comment">// 追加订单列表</span></div><div class="line">		userOrderList.addAll(userOrders);</div><div class="line"></div><div class="line">		USER_MEMORY_ORDER_BOOK.put(userId, userOrderList);</div><div class="line"></div><div class="line">		<span class="comment">// 响应</span></div><div class="line">		responseObserver.onNext(placeOrderRequestResponse.setUserId(userId).setResultCode(ResultCode.SUCCESS).build());</div><div class="line">		responseObserver.onCompleted();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getOrderId</span><span class="params">(ThreadLocalRandom orderIdGenerator)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> orderId = orderIdGenerator.nextInt();</div><div class="line">		<span class="keyword">if</span> (orderId &lt; <span class="number">0</span>) &#123;</div><div class="line">			orderId *= -<span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> orderId;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的代码是完整的代码，读者可以自行复制并直接使用，简单解释下代码：</p>
<ol>
<li>placeOrder为下单服务，核心逻辑就是解析用户下单请求PlaceOrderRequest，将用户订单增量添加到内存订单簿USER_MEMORY_ORDER_BOOK中。<ol>
<li>核心的数据结构为：<em>Map<integer, linkedlist<userorder="">&gt;</integer,></em>，在实战中，通用会持久化订单到redis、MySQL、RocksDB等存储设施中；</li>
</ol>
</li>
<li>queryUserOrders为查询订单服务，核心逻辑为解析用户查询订单请求QueryUserOrderRequest，取出用户id（userId），并在订单簿中匹配当前用户的订单列表。</li>
</ol>
<h3 id="服务端启动类OrderServerBoot"><a href="#服务端启动类OrderServerBoot" class="headerlink" title="服务端启动类OrderServerBoot"></a>服务端启动类OrderServerBoot</h3><blockquote>
<p>有了服务端业务代码之后，重点关注一下服务端启动类的编写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> snowalker</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span> 2022/3/12 23:46</div><div class="line"> * <span class="doctag">@desc</span> 服务端启动类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServerBoot</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderServerBoot.class.getName());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Server server;</div><div class="line"></div><div class="line">	<span class="meta">@SneakyThrows</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> serverPort = <span class="number">10880</span>;</div><div class="line">		server = ServerBuilder.forPort(serverPort)</div><div class="line">				.addService(<span class="keyword">new</span> OrderServiceImpl())</div><div class="line">				.build();</div><div class="line">		server.start();</div><div class="line"></div><div class="line">		logger.info(<span class="string">"OrderServerBoot started, listening on:"</span> + serverPort);</div><div class="line"></div><div class="line">		<span class="comment">// 优雅停机</span></div><div class="line">		addGracefulShowdownHook();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addGracefulShowdownHook</span><span class="params">()</span> </span>&#123;</div><div class="line">		Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">			<span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></div><div class="line">			System.err.println(<span class="string">"*** shutting down gRPC server since JVM is shutting down"</span>);</div><div class="line">			OrderServerBoot.<span class="keyword">this</span>.stop();</div><div class="line">			System.err.println(<span class="string">"*** server shut down"</span>);</div><div class="line">		&#125;));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 服务关闭</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</div><div class="line">			server.shutdown();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 由于 grpc 库使用守护线程，因此在主线程上等待终止。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</div><div class="line">			server.awaitTermination();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@SneakyThrows</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		OrderServerBoot boot = <span class="keyword">new</span> OrderServerBoot();</div><div class="line">		<span class="comment">// 启动服务</span></div><div class="line">		boot.startServer();</div><div class="line">		<span class="comment">// 主线程等待终止</span></div><div class="line">		boot.blockUntilShutdown();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释下代码：</p>
<ul>
<li>核心逻辑为main方法，首先定义OrderServerBoot，通过startServer()启动服务，并通过blockUntilShutdown()让主线程等待终止。</li>
<li><strong>startServer()</strong> 方法核心逻辑，启动一个服务端进程并绑定到对应的端口，这里使用10880，并添加优雅停机钩子；</li>
<li><strong>stop()</strong> 逻辑为服务关闭逻辑；</li>
<li><strong>blockUntilShutdown()</strong> ：由于grpc使用守护线程，因此需要在主线程上等待终止。</li>
</ul>
<h2 id="编写客户端grpc-client-demo"><a href="#编写客户端grpc-client-demo" class="headerlink" title="编写客户端grpc-client-demo"></a>编写客户端grpc-client-demo</h2><blockquote>
<p>有了服务端，我们接着看下客户端工程的编写。</p>
</blockquote>
<h3 id="pom-xml-2"><a href="#pom-xml-2" class="headerlink" title="pom.xml"></a>pom.xml</h3><blockquote>
<p>客户端pom如下</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-client-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-demo-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.snowalker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>与服务端相同，除了lombok外，其余的依赖由grpc-demo-sdk间接引入。</p>
<h3 id="编写客户端服务调用代理OrderClientAgent"><a href="#编写客户端服务调用代理OrderClientAgent" class="headerlink" title="编写客户端服务调用代理OrderClientAgent"></a>编写客户端服务调用代理OrderClientAgent</h3><blockquote>
<p>客户端调用远程服务，需要借助proto生成的stub桩，作为客户端而言，常常会对该stub进行包装，这里我们通过一个OrderClientAgent作为stub的包装类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClientAgent</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderClientAgent.class.getName());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ManagedChannel channel;</div><div class="line"></div><div class="line">	<span class="comment">// 客户端请求服务端的桩</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> OrderServiceGrpc.OrderServiceBlockingStub orderServiceBlockingStub;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OrderClientAgent</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>(ManagedChannelBuilder.forAddress(host, port)</div><div class="line">				<span class="comment">//使用非安全机制传输,默认情况下，通道是安全的（通过SSLTLS）</span></div><div class="line">				.usePlaintext()</div><div class="line">				.build());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	OrderClientAgent(ManagedChannel channel) &#123;</div><div class="line">		<span class="keyword">this</span>.channel = channel;</div><div class="line">		orderServiceBlockingStub = OrderServiceGrpc.newBlockingStub(channel);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		channel.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 下单</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> PlaceOrderRequestResponse <span class="title">placeOrder</span><span class="params">(PlaceOrderRequest request)</span> </span>&#123;</div><div class="line">		logger.info(<span class="string">"client placeOrder start. request:"</span> + request.toString());</div><div class="line">		PlaceOrderRequestResponse placeOrderRequestResponse;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			placeOrderRequestResponse = orderServiceBlockingStub.placeOrder(request);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> placeOrderRequestResponse;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 订单查询</div><div class="line">	 * <span class="doctag">@param</span> request</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> QueryUserOrderResponse <span class="title">queryOrders</span><span class="params">(QueryUserOrderRequest request)</span> </span>&#123;</div><div class="line">		logger.info(<span class="string">"client queryOrders start. request:"</span> + request.toString());</div><div class="line">		QueryUserOrderResponse queryUserOrderResponse;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			queryUserOrderResponse = orderServiceBlockingStub.queryUserOrders(request);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> queryUserOrderResponse;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单解释下代码：</p>
<ul>
<li>通过构造方法传入主机名，服务端端口，构造客户端与服务端间的链接通过ManagedChannel</li>
<li>通过OrderServiceGrpc.newBlockingStub(channel)生成客户端访问的stub实例，这里使用的是阻塞型Stub，即同步等待服务端返回所有结果；</li>
<li>placeOrder方法通过stub访问服务端的下单服务；</li>
<li>queryOrders方法通过stub访问服务端的查询订单服务。</li>
</ul>
<h3 id="编写客户端启动类"><a href="#编写客户端启动类" class="headerlink" title="编写客户端启动类"></a>编写客户端启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> snowalker</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> * <span class="doctag">@date</span> 2022/3/12 23:56</div><div class="line"> * <span class="doctag">@desc</span> 客户端启动类</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderClientBoot</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(OrderClientBoot.class.getName());</div><div class="line"></div><div class="line">   <span class="meta">@SneakyThrows</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> port = <span class="number">10880</span>;</div><div class="line">      OrderClientAgent orderClientAgent = <span class="keyword">new</span> OrderClientAgent(<span class="string">"127.0.0.1"</span>, port);</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">int</span> userId = <span class="number">10086</span>;</div><div class="line"></div><div class="line">         <span class="comment">// 下单</span></div><div class="line">         doPlaceOrder(orderClientAgent, userId);</div><div class="line"></div><div class="line">         <span class="comment">// 查订单</span></div><div class="line">         doQueryOrder(orderClientAgent, userId);</div><div class="line"></div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         orderClientAgent.shutdown();</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doQueryOrder</span><span class="params">(OrderClientAgent orderClientAgent, <span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line">      QueryUserOrderRequest queryUserOrderRequest = QueryUserOrderRequest.newBuilder()</div><div class="line">            .setUserId(userId)</div><div class="line">            .buildPartial();</div><div class="line">      QueryUserOrderResponse queryUserOrderResponse = orderClientAgent.queryOrders(queryUserOrderRequest);</div><div class="line">      logger.info(<span class="string">"client queryOrders end. response:"</span> + queryUserOrderResponse.toString());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPlaceOrder</span><span class="params">(OrderClientAgent orderClientAgent, <span class="keyword">int</span> userId)</span> </span>&#123;</div><div class="line"></div><div class="line">      PlaceUserOrderParam orderParam0 = PlaceUserOrderParam.newBuilder()</div><div class="line">            .setProductId(<span class="number">1</span>)</div><div class="line">            .setOrderAmount(<span class="string">"15.00"</span>)</div><div class="line">            .setOrderPrice(<span class="string">"12.50"</span>)</div><div class="line">            .build();</div><div class="line"></div><div class="line">      PlaceUserOrderParam orderParam1 = PlaceUserOrderParam.newBuilder()</div><div class="line">            .setProductId(<span class="number">2</span>)</div><div class="line">            .setOrderAmount(<span class="string">"2.00"</span>)</div><div class="line">            .setOrderPrice(<span class="string">"10.00"</span>)</div><div class="line">            .build();</div><div class="line"></div><div class="line">      PlaceOrderRequest placeOrderRequest = PlaceOrderRequest.newBuilder()</div><div class="line">            .setUserId(userId)</div><div class="line">            .addAllPlaceUserOrderParam(Lists.newArrayList(orderParam0, orderParam1))</div><div class="line">            .buildPartial();</div><div class="line"></div><div class="line">      PlaceOrderRequestResponse placeOrderRequestResponse = orderClientAgent.placeOrder(placeOrderRequest);</div><div class="line">      logger.info(<span class="string">"client placeOrder end. response:"</span> + placeOrderRequestResponse.toString() + <span class="string">",resultCode:"</span> + placeOrderRequestResponse.getResultCode());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重点关注main方法：</p>
<ul>
<li>声明服务端端口，这里注意务必与服务端暴露服务端口保持一致；</li>
<li>通过构造方法创建客户端访问服务端的agent实例，即上面提到的OrderClientAgent；</li>
<li>通过实例化的OrderClientAgent执行下单、查询订单操作</li>
<li>调用完成后，关闭OrderClientAgent，关闭客户端与服务端之间的链接。</li>
<li><strong>实际生产中，客户端往往会与服务端保持链接开启，而不会频繁创建、关闭服务。</strong></li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>sdk、客户端、服务端均编写完毕，我们启动服务进行测试。</p>
</blockquote>
<h3 id="首先编译打包sdk"><a href="#首先编译打包sdk" class="headerlink" title="首先编译打包sdk"></a>首先编译打包sdk</h3><p>在grpc-demo-sdk根目录下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -DskipTests</div></pre></td></tr></table></figure>
<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><p>运行OrderServerBoot的main方法，日志打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 10:50:29 上午 OrderServerBoot startServer</div><div class="line">信息: OrderServerBoot started, listening on:10880</div></pre></td></tr></table></figure>
<h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3><p>运行OrderClientBoot的main方法，启动客户端并发起服务调用</p>
<blockquote>
<p>首先进行下单：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 10:54:57 上午 agent.OrderClientAgent placeOrder</div><div class="line">信息: client placeOrder start. request:userId: 10086</div><div class="line">placeUserOrderParam &#123;</div><div class="line">  orderPrice: &quot;12.50&quot;</div><div class="line">  orderAmount: &quot;15.00&quot;</div><div class="line">  productId: 1</div><div class="line">&#125;</div><div class="line">placeUserOrderParam &#123;</div><div class="line">  orderPrice: &quot;10.00&quot;</div><div class="line">  orderAmount: &quot;2.00&quot;</div><div class="line">  productId: 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">三月 13, 2022 10:54:58 上午 OrderClientBoot doPlaceOrder</div><div class="line">信息: client placeOrder end. response:userId: 10086</div><div class="line">,resultCode:SUCCESS</div></pre></td></tr></table></figure>
<p>下单成功，接着发起查询订单操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 12:20:55 下午 agent.OrderClientAgent queryOrders</div><div class="line">信息: client queryOrders start. request:userId: 10086</div><div class="line"></div><div class="line">三月 13, 2022 12:20:55 下午 OrderClientBoot doQueryOrder</div><div class="line">信息: client queryOrders end. response:userId: 10086</div><div class="line">totalPrice: &quot;207.5000&quot;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;12.50&quot;</div><div class="line">  orderAmount: &quot;15.00&quot;</div><div class="line">  productId: 1</div><div class="line">&#125;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;10.00&quot;</div><div class="line">  orderAmount: &quot;2.00&quot;</div><div class="line">  productId: 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，下单成功，且通过查询订单调用，将用户10086下的两个订单获取到了。</p>
<h3 id="观察服务端日志"><a href="#观察服务端日志" class="headerlink" title="观察服务端日志"></a>观察服务端日志</h3><blockquote>
<p>服务端日志打印如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">三月 13, 2022 12:20:55 下午 service.OrderServiceImpl queryUserOrders</div><div class="line">信息: [Server] queryUserOrders, request:userId: 10086</div><div class="line"></div><div class="line">response:userId: 10086</div><div class="line">totalPrice: &quot;207.5000&quot;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;12.50&quot;</div><div class="line">  orderAmount: &quot;15.00&quot;</div><div class="line">  productId: 1</div><div class="line">&#125;</div><div class="line">userOrder &#123;</div><div class="line">  orderId: 510807688</div><div class="line">  orderPrice: &quot;10.00&quot;</div><div class="line">  orderAmount: &quot;2.00&quot;</div><div class="line">  productId: 2</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务端完成下单之后，对用户订单总价值进行计算</p>
<blockquote>
<p>totalPrice = 12.5<em>15 + 10 </em>2 = 207.5</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们对gRPC进行了如下介绍：</p>
<ul>
<li>gRPC特性介绍</li>
<li>gRPC-java线程模型</li>
<li>gRPC客户端请求服务端方式</li>
<li>gRPC与REST性能比对</li>
</ul>
<p>并通过一个完整的demo展示了基于gRPC实现的报价服务，全景展示了gRPC在实战中如何进行使用。</p>
<p>到此我们对gRPC应当有了大致的了解和认知，后续我们将继续从入门到放弃的学习之路。</p>
<p>预告：接下来将对gRPC的底层机制进行讲解，并会为我们的报价服务添加服务发现能力，整合Nacos提供服务注册与发现，降低客户端与服务端之间的耦合，敬请期待。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微服务如火如荼的当下，各种服务框架层出不穷。Dubbo、SpringCloud在国内Java后端微服务领域目前占据大部分份额。&lt;/p&gt;
&lt;p&gt;但是随着云原生愈发普及，具备跨语言、高性能特性的RPC通信框架横空出世，其中gRPC与Thrift是其中的佼佼者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文我们将视角集中在gRPC这RPC框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gRPC 是Google开源的高性能、通用的RPC框架。客户端与服务端约定接口调用， 可以在各种环境中运行，具有跨语言特性， 适合构建分布式、微服务应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人认为，gRPC最为杀手锏的特性就是“跨语言”，其次才是高性能。&lt;/p&gt;
&lt;p&gt;它的跨语言特性体现在，通过定义IDL（接口定义语言），隔离了不同编程语言之间的差异，对IDL进行编译后，生成对应编程语言的nativeCode，让开发者能够集中注意在实现业务需求上，而不需要花费额外的精力在语言层面上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官网的一张图能够很好的体现这个特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2022/03/12/学点儿gRPC-从入门到放弃/grpc_server.png&quot; alt=&quot;gRPC多语言&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="gRPC" scheme="http://wuwenliang.net/categories/gRPC/"/>
    
    
      <category term="gRPC" scheme="http://wuwenliang.net/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>学点儿金融知识-撮合交易那些事儿</title>
    <link href="http://wuwenliang.net/2022/03/10/%E5%AD%A6%E7%82%B9%E5%84%BF%E9%87%91%E8%9E%8D%E7%9F%A5%E8%AF%86-%E6%92%AE%E5%90%88%E4%BA%A4%E6%98%93%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://wuwenliang.net/2022/03/10/学点儿金融知识-撮合交易那些事儿/</id>
    <published>2022-03-10T14:07:30.000Z</published>
    <updated>2022-03-10T14:38:29.178Z</updated>
    
    <content type="html"><![CDATA[<p>今天的文章，继续学点儿金融知识。重点来了解下金融领域的撮合交易机制。</p>
<blockquote>
<p>本文主要介绍撮合交易的概念，委托单相关的知识，以及撮合交易集合竞价与连续竞价相关的要点。</p>
<p>最后讲解撤单相关的知识及止盈止损相关的知识点。</p>
</blockquote>
<h3 id="什么是撮合交易？"><a href="#什么是撮合交易？" class="headerlink" title="什么是撮合交易？"></a>什么是撮合交易？</h3><blockquote>
<p>撮合交易指的是 <strong>买方</strong> 在交易所下委托买单买入标的，如一手股票，<strong>卖方</strong> 在交易所下委托卖单卖出标的，如一手股票。</p>
<p>交易所按照价格优先、时间优先原则确定双方成交价格，对符合交易规则的订单进行撮合成交，按交易定单指定的标的物进行交割的交易方式。</p>
</blockquote>
<h3 id="撮合是如何成交的？"><a href="#撮合是如何成交的？" class="headerlink" title="撮合是如何成交的？"></a>撮合是如何成交的？</h3><p>一般来说，买入和卖出价格是确定的，这种订单叫做限价单，即下单时就指定确定的价格。</p>
<p>买入限价，指的是至多（小于等于）通过该价格成交，买入一定数量的股票。如限价$10, 则可以买入&lt;=$10的股票。</p>
<p>卖出限价，指的至少（大于等于）要通过该价格成交，卖出一定数量的股票，如限价$10，则对手方至少要付出$10买入股票。</p>
<a id="more"></a>
<p><strong>针对卖出限价打个比方：</strong></p>
<blockquote>
<p>我们去市场买菜，老板吆喝，一斤白菜2块5。</p>
<p>我：2块3卖不卖？</p>
<p>老板：不卖。</p>
<p>我：行，那来两斤</p>
<p>于是我花了2.5 * 2买入了2斤白菜。老板卖出限价就是2.5元。</p>
</blockquote>
<p>针对买入限价打个比方：</p>
<blockquote>
<p>我们去市场采购蔬菜，老板吆喝，蔬菜打折卖了！</p>
<p>我：2块3卖不卖？</p>
<p>老板：2块4就卖。</p>
<p>我：就2块3，多了不买。</p>
<p>天色已晚，老板想了想，一跺脚，好，卖了！ </p>
<p>于是我花了2.3买入了白菜。我的买入限价就是2.3元。</p>
</blockquote>
<h4 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h4><p>股票市场中可以有多个买价和卖价， 其中买方价格由高到低排列， 而卖方价格由低到高排列， 这就是我们通常看到多个挡位行情， 也就是盘口信息，或者叫作深度。</p>
<p>一般盘口会显示五个挡位，对于更高级的行情源， 可以显示十个或更多挡位。</p>
<p>当一个挡位的数量不足以交易时， 由下一个挡位进行匹配成交， 就形成了深度成交。</p>
<p>通俗的说法，通过匹配深度成交，叫做吃了深度，或者专业的说法叫做 ： <strong>吃单（Taker）</strong>。</p>
<p>而深度中的单子，则被吃掉了，专业的说法叫做：<strong>挂单（Maker）</strong>。</p>
<h3 id="什么是股票委托？"><a href="#什么是股票委托？" class="headerlink" title="什么是股票委托？"></a>什么是股票委托？</h3><blockquote>
<p>股票委托是指依据买卖双方各自提出的条件（股票代码， 价格和成交量等），代其买卖股票的交易活动。</p>
<p>代理买卖的经纪人充当股票买卖双方的中介者， 比如券商。 </p>
</blockquote>
<p>一般来说，股票委托形式有两种：市价委托和限价委托。</p>
<h4 id="市价委托和限价委托"><a href="#市价委托和限价委托" class="headerlink" title="市价委托和限价委托"></a>市价委托和限价委托</h4><ul>
<li><p>市价委托：就是按市场价格买进或卖出股票。</p>
</li>
<li><p>限价委托：就是按委托人提出的价格条件买进或卖出股票。</p>
</li>
</ul>
<p>对于限价委托而言，输入的委托价格不得高于该股票当日涨停价或低于当日的跌停价。</p>
<p><img src="/2022/03/10/学点儿金融知识-撮合交易那些事儿/image.png" alt=""></p>
<p>假设买方选择限价委托方式进行申报， 委托价格为25.06， 申报手数为10手， 那么该笔申报的成交情况为暂时无成交， 若投资者不撤单， 则剩余委托仍在撮合成交系统内， 等待其他投资者主动卖出， 撮合成交， 成交价为25.06； 实际成交数量，根据交易系统撮合的数量确定。</p>
<p>如果当日交易结束仍有部分委托未成交, 则系统自动撤单, 下一交易日需重新申报委托。</p>
<blockquote>
<p>在股票市场规定中， 交易分为两类， 集合竞价与连续竞价交易。 </p>
</blockquote>
<p>下面， 我们以实例讲解推演。</p>
<h3 id="集合竞价"><a href="#集合竞价" class="headerlink" title="集合竞价"></a>集合竞价</h3><p>沪深开放式集合竞价时间为9点15分至9点25分，14点57分至15点00分， 除此之外的交易时间为连续竞价交易时段。</p>
<blockquote>
<p>假设某只股票在开盘前分别有5笔买入和6笔卖出委托， 根据价格优先原则， 按买入价格由高至低和卖出价格由低至高的顺序将其分别排列如下：</p>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3.80</td>
<td>2</td>
<td>1</td>
<td>3.52</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>按不高于申买价和不低于申卖价的原则，首先可成交第一笔，即3．80元买入委托和3．52元的卖出委托， 这对委托成交后其它的委托排序如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>3.52</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>序号1的买入委托2手全部成交， 序号1的卖出委托还剩余3手。</p>
<p>第二笔成交情况：序号2的买入委托价格为3．76元，数量为6手。 在卖出委托中，序号1—3的委托卖出价格符合条件, 且数量正好为6手，进行撮合成交， 其成交价格在3．60元—3．76元的范围内，成交数量为6手。 第二笔成交后剩下的委托情况为：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第三笔成交情况：序号3的买入委托其价格要求不超过3．65元，而卖出委托序号4的委托价格符合要求，这样序号3的买入委托与序号4的卖出委托就正好配对成交，其价格为3．65元，因卖出委托数量大于买入委托，故序号4的卖出委托仅只成交了4手。第三笔成交后的委托情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td>3.65</td>
<td><strong>2</strong></td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>完成以上三笔委托后，因最高买入价为3．60元，而最低卖出价为3．65，买入价与卖出价之间再没有相交部分，所以这一次的集合竟价就已完成，最后一笔的成交价就为集合竟价的平均价格。剩下的其他委托将自动进入开盘后的 <strong>连续竟价</strong> 。</p>
<h3 id="连续竞价"><a href="#连续竞价" class="headerlink" title="连续竞价"></a>连续竞价</h3><blockquote>
<p>连续竟价的成交方式与集合竟价有很大的区别，它是在买入的最高价与卖出的最低价的委托中一对一对地成交， 其成交价为申买与申卖的平均价。</p>
</blockquote>
<p>仍以某只股票为例， 委托报价的排列情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>3.80</td>
<td>2</td>
<td>1</td>
<td>3.52</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>委托买入的最高价为序号1的3．80元，卖出最低价为序号1的3．52元，这一对优先成交，其价格为两者的平均价, 与成交数量无关, 计算公式为: (3．80＋3．52）/2，故产生的价格为3．66元。交易所发布的即时行情为：成交价3．66元，数量2手。剩余的委托报价排序情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>3.52</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>2</td>
<td>3.76</td>
<td>6</td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第二笔，序号1的卖出价为3．52元，序号2的买入价为3．76元，这一对可以成交，成交价格为两者的平均值，价格为3．64元，数量为3手。该次成交后的委托情况为： </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3.76</td>
<td><strong>3</strong></td>
<td>2</td>
<td>3.57</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第三笔，序号2的卖出委托与序号2的买入委托可以成交，成交均价为3．67元，成交量1手。成交后剩下的委托情况如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>3.76</td>
<td><strong>2</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3.65</td>
<td>4</td>
<td>3</td>
<td>3.60</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>第四笔，序号2的买入委托3.76与序号3的卖出委托3.60成交2手， 序号2的买入委托与序号3的卖出委托消失；</p>
<p>第五笔， 序号4的卖出委托3.65与序号3的买入委托3.65撮合成交4手， 接下来没有匹配的价格无法进行撮合交易。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>委托买入价格</th>
<th>数量</th>
<th>序号</th>
<th>委托卖出价格</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>3.60</td>
<td>7</td>
<td>4</td>
<td>3.65</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>3.54</td>
<td>6</td>
<td>5</td>
<td>3.70</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>6</td>
<td>3.75</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>以上就是撮合交易机制的处理流程。</p>
<h3 id="撤单是个啥流程？"><a href="#撤单是个啥流程？" class="headerlink" title="撤单是个啥流程？"></a>撤单是个啥流程？</h3><p>简单的说，有挂单，就有撤单。</p>
<blockquote>
<p>撤单就是投资者通过股票委托进行买卖操作，按照投资者的要求撤回操作的过程。</p>
</blockquote>
<p>如果投资者在当天要动用被锁定的资金(在委托买入时，想改变买入价格或不想买入)或股票(在委托卖出时，想改变卖出价格或不想卖出)，就必须通过撤单撤消该委托。</p>
<blockquote>
<p>简单的说，如果投资者委托下单后，订单没有成交，进入了深度，投资者此时持有该挂单。</p>
<p>挂单本身会冻结响应的资金，如果投资者觉得价格不合适或者改变主意不想买卖了，就可以通过撤单来讲该委托挂单取消。</p>
</blockquote>
<p>国内A股撤单有效时间规定：</p>
<ul>
<li><p>9：15-9：20，可撤单;9：15前的撤单请求也从9：15开始受理。</p>
</li>
<li><p>9：20-9：25，不接受撤单申报。</p>
</li>
<li><p>9：30-11：30，可撤单。</p>
</li>
<li><p>11：30-13：00，可申报撤单，但证交所尚不受理，处于“已报待撤”状态，13：00后开始受理，按时间顺序先受理买卖委托，如已成交，再受理撤单请求时，则不会撤单成功。</p>
</li>
<li><p>13：00-15：00可撤单，两市最后3分钟14：57-15：00为集合竞价，不能撤单。</p>
</li>
<li><p>15：00 收盘以后，没有成交的委托自动作废，无需撤单。但必须要等待清算结束后，资金才会解冻回到账户上来。</p>
</li>
</ul>
<h3 id="止盈止损又是啥？"><a href="#止盈止损又是啥？" class="headerlink" title="止盈止损又是啥？"></a>止盈止损又是啥？</h3><blockquote>
<p>事实上，止盈止损是三件事情的统称，止盈，止损，止盈And止损。</p>
</blockquote>
<h4 id="啥是止盈？"><a href="#啥是止盈？" class="headerlink" title="啥是止盈？"></a>啥是止盈？</h4><blockquote>
<p>止盈（Stop-Profit/Stop Profit），也称停利、止赚 。 当股票到达一定的价格，而且出现利润，打算离场平仓了，在目标价位挂单卖出就是止盈。</p>
</blockquote>
<p>止盈的设置方式主要有两种:</p>
<p>第一，设比例。假设10元买的股票，而后它上涨到12元，可以设定股票在回调10%位置时出仓。即，假如股票从12元回调到10.8元，就出来。如果没有回调到位，就一直拿着，然后，稳步修正止盈点(一定要严格遵守)，使自身利润接近最大化。</p>
<p>第二，设价位。比如，10元买的股票，而后它上涨到12元，设定如果跌破11元就出仓，如果它没有跌到此价位而是继续上涨到了13元，那么，就设定如果跌破12元就出仓……这样逐级抬高标准，锁住自己的利润，也不至于因提前出仓后悔。</p>
<h4 id="啥是止损？"><a href="#啥是止损？" class="headerlink" title="啥是止损？"></a>啥是止损？</h4><blockquote>
<p>止损俗称“割肉”，是指当某一投资出现的亏损达到预定数额时，及时斩仓出局，以避免形成更大的亏损。目的就在于投资失误时把损失限定在较小的范围内。</p>
</blockquote>
<p>止损方法与止盈类似， 主要存在两种， 根据比例和价位， 采用定额方式进行止损。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>撮合交易是金融场景最为核心的逻辑，是学习了解金融市场运作极为关键的因素；</li>
<li>撮合交易核心在于集合竞价与连续竞价的交易机制；</li>
<li>委托下单、 撤单、止盈止损等概念是撮合交易中不可或缺的环节，需要我们了解并掌握其概念及场景。</li>
</ul>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的文章，继续学点儿金融知识。重点来了解下金融领域的撮合交易机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要介绍撮合交易的概念，委托单相关的知识，以及撮合交易集合竞价与连续竞价相关的要点。&lt;/p&gt;
&lt;p&gt;最后讲解撤单相关的知识及止盈止损相关的知识点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是撮合交易？&quot;&gt;&lt;a href=&quot;#什么是撮合交易？&quot; class=&quot;headerlink&quot; title=&quot;什么是撮合交易？&quot;&gt;&lt;/a&gt;什么是撮合交易？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;撮合交易指的是 &lt;strong&gt;买方&lt;/strong&gt; 在交易所下委托买单买入标的，如一手股票，&lt;strong&gt;卖方&lt;/strong&gt; 在交易所下委托卖单卖出标的，如一手股票。&lt;/p&gt;
&lt;p&gt;交易所按照价格优先、时间优先原则确定双方成交价格，对符合交易规则的订单进行撮合成交，按交易定单指定的标的物进行交割的交易方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;撮合是如何成交的？&quot;&gt;&lt;a href=&quot;#撮合是如何成交的？&quot; class=&quot;headerlink&quot; title=&quot;撮合是如何成交的？&quot;&gt;&lt;/a&gt;撮合是如何成交的？&lt;/h3&gt;&lt;p&gt;一般来说，买入和卖出价格是确定的，这种订单叫做限价单，即下单时就指定确定的价格。&lt;/p&gt;
&lt;p&gt;买入限价，指的是至多（小于等于）通过该价格成交，买入一定数量的股票。如限价$10, 则可以买入&amp;lt;=$10的股票。&lt;/p&gt;
&lt;p&gt;卖出限价，指的至少（大于等于）要通过该价格成交，卖出一定数量的股票，如限价$10，则对手方至少要付出$10买入股票。&lt;/p&gt;
    
    </summary>
    
      <category term="金融系统" scheme="http://wuwenliang.net/categories/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="金融系统" scheme="http://wuwenliang.net/tags/%E9%87%91%E8%9E%8D%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor学习资料汇总</title>
    <link href="http://wuwenliang.net/2022/03/03/Disruptor%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://wuwenliang.net/2022/03/03/Disruptor学习资料汇总/</id>
    <published>2022-03-02T17:07:47.000Z</published>
    <updated>2022-03-02T17:13:14.569Z</updated>
    
    <content type="html"><![CDATA[<p>到此，Disruptor高性能之道系列就先告一段落，关于Disruptor的实战使用将会在后续的撮合实战案例中讲解。</p>
<blockquote>
<p>本文推荐一些学习Disruptor的资料，感兴趣的读者可以根据这些资料进一步学习。</p>
</blockquote>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p>官网是第一手资料，<strong>建议通读</strong></p>
<blockquote>
<p><a href="https://lmax-exchange.github.io/disruptor/user-guide/index.html#_using_the_disruptor" target="_blank" rel="external">https://lmax-exchange.github.io/disruptor/user-guide/index.html#_using_the_disruptor</a></p>
</blockquote>
<h2 id="并发编程网：disruptor译文"><a href="#并发编程网：disruptor译文" class="headerlink" title="并发编程网：disruptor译文"></a>并发编程网：disruptor译文</h2><p>虽然有些过时，但是思想是值得参考的。<strong>建议通读</strong></p>
<blockquote>
<p><a href="http://ifeve.com/disruptor/" target="_blank" rel="external">http://ifeve.com/disruptor/</a></p>
</blockquote>
<p><img src="/2022/03/03/Disruptor学习资料汇总/ifeve.PNG" alt="ifeve.PNG"></p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到此，Disruptor高性能之道系列就先告一段落，关于Disruptor的实战使用将会在后续的撮合实战案例中讲解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文推荐一些学习Disruptor的资料，感兴趣的读者可以根据这些资料进一步学习。&lt;/p&gt;
&lt;/blockquote
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor实战-多生产者多消费者</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E5%AE%9E%E6%88%98-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor实战-多生产者多消费者/</id>
    <published>2022-02-28T10:15:59.000Z</published>
    <updated>2022-02-28T10:15:59.190Z</updated>
    
    <content type="html"><![CDATA[<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;hr&gt;&lt;br&gt;版权声明：&lt;br&gt;&lt;br&gt;原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。&lt;br&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Disruptor实战-单生产者多消费者</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E5%AE%9E%E6%88%98-%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor实战-单生产者多消费者/</id>
    <published>2022-02-28T10:15:52.000Z</published>
    <updated>2022-02-28T10:15:52.230Z</updated>
    
    <content type="html"><![CDATA[<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;hr&gt;&lt;br&gt;版权声明：&lt;br&gt;&lt;br&gt;原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。&lt;br&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Disruptor实战-单生产者单消费者</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E5%AE%9E%E6%88%98-%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor实战-单生产者单消费者/</id>
    <published>2022-02-28T10:15:45.000Z</published>
    <updated>2022-02-28T10:15:45.726Z</updated>
    
    <content type="html"><![CDATA[<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;hr&gt;&lt;br&gt;版权声明：&lt;br&gt;&lt;br&gt;原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。&lt;br&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-等待策略</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E7%AD%89%E5%BE%85%E7%AD%96%E7%95%A5/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-等待策略/</id>
    <published>2022-02-28T10:10:34.000Z</published>
    <updated>2022-03-02T17:01:40.166Z</updated>
    
    <content type="html"><![CDATA[<p>我们接着介绍Disruptor高性能实现之道–等待策略。</p>
<blockquote>
<p>等待策略waitStrategy是一种决定一个消费者如何等待生产者将event对象放入Disruptor的方式/策略。</p>
<p>等待策略waitStrategy是一个接口，它的所有实现都是针对消费者生效的。</p>
</blockquote>
<a id="more"></a>
<h2 id="Disruptor中主要的等待策略有哪些？"><a href="#Disruptor中主要的等待策略有哪些？" class="headerlink" title="Disruptor中主要的等待策略有哪些？"></a>Disruptor中主要的等待策略有哪些？</h2><p>Disruptor中，等待策略waitStrategy有四个实现，分别是：</p>
<ul>
<li><p>BlockingWaitStrategy：使用锁和条件变量实现的阻塞策略。如果不是将吞吐量和低延迟放在首位，则可以使用该策略。一般来说，这个策略的表现是中规中矩比较稳定的，它不会使CPU的负载飙高。</p>
<blockquote>
<p>虽然客观上说， BlockingWaitStrategy是最低效的策略，但其也是CPU使用率最低和最稳定的策略。</p>
<p>在BlockingWaitStrategy内部维护了一个重入锁ReentrantLock和Condition；</p>
</blockquote>
</li>
<li><p>SleepingWaitStrategy：性能表现和com.lmax.disruptor.BlockingWaitStrategy差不多，对CPU的消耗也类似，但其对生产者线程的影响最小，适合用于异步日志类似的场景；</p>
<blockquote>
<p>SleepingWaitStrategy是一种无锁的方式，它的CPU使用率也比较低。具体的实现原理为：循环等待并且在循环中间调用LockSupport.parkNanos(1)来睡眠，（在Linux系统上面睡眠时间60µs）.</p>
<p>SleepingWaitStrategy优点在于生产线程只需要计数，而不执行任何指令。并且没有条件变量的消耗。但是，事件对象从生产者到消费者传递的延迟变大了。SleepingWaitStrategy最好用在不需要低延迟，而且事件发布对于生产者的影响比较小的情况下。比如异步日志功能。</p>
</blockquote>
</li>
<li><p>YieldingWaitStrategy：性能最好，适合用于低延迟的系统，在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中推荐使用此策略，例如CPU开启超线程的特性；</p>
<blockquote>
<p>虽然YieldingWaitStrategy性能最好，但是它的实现机制是让出cpu使用权，保证cpu不会空闲，从而使得cpu始终处于工作态，因此该策略会使用100%的CPU，因此建议慎用。</p>
</blockquote>
</li>
<li>BusySpinWaitStrategy：该策略原则上来说应当是性能最高的，它将线程绑定在特定的CPU内核，但是同时该策略也是部署过程中最为苛刻的策略。<blockquote>
<p>BusySpinWaitStrategy发挥高性能的前提是事件处理线程比物理内核数目还要小的场景。例如：在禁用超线程技术的时候。</p>
</blockquote>
</li>
</ul>
<h2 id="BlockingWaitStrategy"><a href="#BlockingWaitStrategy" class="headerlink" title="BlockingWaitStrategy"></a>BlockingWaitStrategy</h2><blockquote>
<p>BlockingWaitStrategy是Disruptor中唯一使用到锁的地方。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public final class BlockingWaitStrategy implements WaitStrategy</div><div class="line">&#123;</div><div class="line"></div><div class="line">    // 可重入锁</div><div class="line">    private final Lock lock = new ReentrantLock();</div><div class="line"></div><div class="line">    // 条件变量</div><div class="line">    private final Condition processorNotifyCondition = lock.newCondition();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSequence, SequenceBarrier barrier)</div><div class="line">        throws AlertException, InterruptedException</div><div class="line">    &#123;</div><div class="line">        long availableSequence;</div><div class="line">        if (cursorSequence.get() &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            lock.lock();</div><div class="line">            try</div><div class="line">            &#123;</div><div class="line">                while (cursorSequence.get() &lt; sequence)</div><div class="line">                &#123;</div><div class="line">                    barrier.checkAlert();</div><div class="line">                    processorNotifyCondition.await();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            finally</div><div class="line">            &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 如果生产者新发布了事件，但是依赖的其他消费者还没处理完，则等待所依赖的消费者先处理</div><div class="line">        while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            barrier.checkAlert();</div><div class="line">            ThreadHints.onSpinWait();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return availableSequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void signalAllWhenBlocking()</div><div class="line">    &#123;</div><div class="line">        lock.lock();</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            processorNotifyCondition.signalAll();</div><div class="line">        &#125;</div><div class="line">        finally</div><div class="line">        &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>BlockingWaitStrategy的类长度不到100行，使用了Lock+Condition 实现了线程等待和唤醒操作。从而实现了生产者与消费者之间的同步。</p>
<p>消费者通过waitFor等待RingBuffer指定位置是否有可用数据，当存在可用数据，则消费者被唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @see Sequencer#publish(long)</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void publish(long sequence)</div><div class="line">&#123;</div><div class="line">    cursor.set(sequence);</div><div class="line">    waitStrategy.signalAllWhenBlocking();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果生产者新发布了事件，但是依赖的其他消费者还没处理完，则等待所依赖的消费者先处理</li>
<li>生产者新发布时间，会唤醒等待中的消费者。</li>
</ul>
<h2 id="SleepingWaitStrategy"><a href="#SleepingWaitStrategy" class="headerlink" title="SleepingWaitStrategy"></a>SleepingWaitStrategy</h2><p>SleepingWaitStrategy没有用到锁，这表明它无需调用signalAllWhenBlocking方法做唤醒处理。</p>
<blockquote>
<p>SleepingWaitStrategy核心是通过<strong>Thread.yield</strong> + <strong>LockSupport.parkNanos</strong>，实现生产者和消费者之间的同步。</p>
</blockquote>
<p>也就是说省去了生产线程的通知操作，官方源码注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* This strategy is a good compromise between performance and CPU resource.</div><div class="line">* Latency spikes can occur after quiet periods.  It will also reduce the impact</div><div class="line">* on the producing thread as it will not need signal any conditional variables</div><div class="line">* to wake up the event handling thread.</div></pre></td></tr></table></figure>
<p>大意是说，SleepingWaitStrategy策略在性能和CPU资源消耗之间取得了平衡，接下来去看看关键代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final int DEFAULT_RETRIES = 200;</div><div class="line">private static final long DEFAULT_SLEEP = 100;</div><div class="line"></div><div class="line">private final int retries;</div><div class="line">private final long sleepTimeNs;</div><div class="line"></div><div class="line">@Override</div><div class="line">public long waitFor(</div><div class="line">    final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)</div><div class="line">    throws AlertException</div><div class="line">&#123;</div><div class="line">    long availableSequence;</div><div class="line">    int counter = retries;    // 默认值为DEFAULT_RETRIES = 200;</div><div class="line"></div><div class="line">    while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">    &#123;</div><div class="line">        counter = applyWaitMethod(barrier, counter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return availableSequence;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void signalAllWhenBlocking()</div><div class="line">&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>waitFor 方法核心是while循环，我们可以看到，while循环没有任何的break操作，他就是个死循环。</p>
<p>counter默认值为200，自旋重试一定次数，如果在重试过程中，出现了可用sequence，也就是生产者往RingBuffer中生产了数据，则直接返回可用的序列号。</p>
<p>只要消费者没有等到可用的数据，就会一直循环，执行applyWaitMethod。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private int applyWaitMethod(final SequenceBarrier barrier, int counter)</div><div class="line">    throws AlertException</div><div class="line">&#123;</div><div class="line">    barrier.checkAlert();</div><div class="line"></div><div class="line">    if (counter &gt; 100)</div><div class="line">    &#123;</div><div class="line">        --counter;</div><div class="line">    &#125;</div><div class="line">    else if (counter &gt; 0)</div><div class="line">    &#123;</div><div class="line">        --counter;</div><div class="line">        Thread.yield();</div><div class="line">    &#125;</div><div class="line">    else</div><div class="line">    &#123;</div><div class="line">        LockSupport.parkNanos(sleepTimeNs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的核心就是counter计数器，完全是无锁的。</p>
<p>当计数器高于100时就执行减一的操作（最快响应），当计数器在100到0之间时每次都交出CPU执行时间（最省资源），其他时候就睡眠固定时间：</p>
<p>如果重试指定次数以后，还是没有可用序列号，则继续自旋重试：</p>
<ul>
<li>0-100：每重试一次，便调用Thread.yield方法，让渡CPU的使用权，让其它线程可以使用CPU。当该线程再次获取CPU使用权时，继续重试，如果还没有可用的序列号，则继续放弃CPU使用权等待。此循环最多100次。</li>
<li>加入在等待过程中还是没有可用的序列号，则调用LockSupport.parkNanos方法阻塞消费线程，阻塞时长通过SleepingWaitStrategy构造方法设置，一直阻塞到出现了可用的sequence（一直阻塞到生产者生产了数据）。</li>
<li>当LockSupport.parkNanos方法由于超时返回后，还没有可用的sequence序列号，则该线程获取CPU使用权以后，可能继续调用LockSupport.parkNanos方法阻塞线程。</li>
</ul>
<p>跟其它几种等待策略相比，它既没有直接使用锁，也没有直接自旋。属于一种在性能和CPU资源之间折中的方案。</p>
<h2 id="BusySpinWaitStrategy"><a href="#BusySpinWaitStrategy" class="headerlink" title="BusySpinWaitStrategy"></a>BusySpinWaitStrategy</h2><blockquote>
<p>BusySpinWaitStrategy的实现代码行数只有几十行，从它的注释可以看出: 该策略将线程绑定到了特定的CPU内核。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Busy Spin strategy that uses a busy spin loop for &#123;@link EventProcessor&#125;s waiting on a barrier.</div><div class="line"> * &lt;p&gt;</div><div class="line"> * This strategy will use CPU resource to avoid syscalls which can introduce latency jitter.  It is best</div><div class="line"> * used when threads can be bound to specific CPU cores.</div><div class="line"> */</div><div class="line">public final class BusySpinWaitStrategy implements WaitStrategy</div><div class="line">&#123;</div><div class="line">    @Override</div><div class="line">    public long waitFor(</div><div class="line">        final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)</div><div class="line">        throws AlertException, InterruptedException</div><div class="line">    &#123;</div><div class="line">        long availableSequence;</div><div class="line"></div><div class="line">        while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            barrier.checkAlert();</div><div class="line">            ThreadHints.onSpinWait();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return availableSequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void signalAllWhenBlocking()</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当没有可用sequence时，消费者会一直执行while循环，具体的逻辑为 <strong>ThreadHints.onSpinWait();</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static final MethodHandle ON_SPIN_WAIT_METHOD_HANDLE;</div><div class="line"></div><div class="line">public static void onSpinWait()</div><div class="line">&#123;</div><div class="line">    // Call java.lang.Thread.onSpinWait() on Java SE versions that support it. Do nothing otherwise.</div><div class="line">    // This should optimize away to either nothing or to an inlining of java.lang.Thread.onSpinWait()</div><div class="line">    if (null != ON_SPIN_WAIT_METHOD_HANDLE)</div><div class="line">    &#123;</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            ON_SPIN_WAIT_METHOD_HANDLE.invokeExact();</div><div class="line">        &#125;</div><div class="line">        catch (final Throwable ignore)</div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当ON_SPIN_WAIT_METHOD_HANDLE 不为空，则执行 ON_SPIN_WAIT_METHOD_HANDLE.invokeExact(); 底层是一个native方法。</p>
<p>那么我们可以猜想，如果ON_SPIN_WAIT_METHOD_HANDLE为空，那么这个外层的while循环就是一个纯粹的自旋操作，也就是说这个操作非常消耗CPU。</p>
<p>ON_SPIN_WAIT_METHOD_HANDLE为空是一个比较严重的场景，它的初始化逻辑为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># com.lmax.disruptor.util.ThreadHints</div><div class="line">static</div><div class="line">&#123;</div><div class="line">    final MethodHandles.Lookup lookup = MethodHandles.lookup();</div><div class="line"></div><div class="line">    MethodHandle methodHandle = null;</div><div class="line">    try</div><div class="line">    &#123;</div><div class="line">        methodHandle = lookup.findStatic(Thread.class, &quot;onSpinWait&quot;, methodType(void.class));</div><div class="line">    &#125;</div><div class="line">    catch (final Exception ignore)</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ON_SPIN_WAIT_METHOD_HANDLE = methodHandle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这里的methodHandle其实就是Thread类中的onSpinWait方法，</p>
<p>如果Thread类没有onSpinWait方法那么使用BusySpinWaitStrategy作为等待策略就在RingBuffer中没有数据时，消费线程就会执行自旋空转，这个操作很耗费CPU。</p>
<blockquote>
<p>那么问题就变成了，Thread类中是否存在<strong>onSpinWait</strong> 方法的问题了。</p>
</blockquote>
<p>有趣的是，onSpinWait方法在JDK1.9之后才添加到了Thread类中，也就是说，对于JDK1.8（包括1.8）之前的用户而言，使用BusySpinWaitStrategy就意味着，找不到Thread类的onSpinWait方法，而最终导致消费者阻塞在waitFor方法上，执行无意义的自旋操作，把CPU负载打满（就是一个while(true)死循环）。</p>
<blockquote>
<p>在jdk1.9及以上版本中，Thread.onSpinWait是有意义的。它会通知CPU当前线程处于循环查询的状态，CPU得知该状态后就会调度更多CPU资源给其他线程，从而缓解死循环对当前cpu核的压力。</p>
</blockquote>
<p>回过头来，BusySpinWaitStrategy的注释告诉我们：如果使用该策略，尽量绑定线程到固定的CPU核心。但是同样的，该策略与YieldingWaitStrategy策略相比，会出现当没有可用序列号时长期占用CPU而让出CPU使用权（死循环），导致其它线程无法获取CPU使用权。</p>
<h3 id="如何实现利用线程亲和性绑定线程到具体的CPU？"><a href="#如何实现利用线程亲和性绑定线程到具体的CPU？" class="headerlink" title="如何实现利用线程亲和性绑定线程到具体的CPU？"></a>如何实现利用线程亲和性绑定线程到具体的CPU？</h3><p>那么这个操作又该如何实现呢？</p>
<blockquote>
<p>通过使用net.openhft.affinity包，就可以实现线程亲和性，它会强制你的应用线程运行在特定的一个或多个cpu上。</p>
</blockquote>
<p>maven依赖为：</p>
<dependency><br>    <groupid>net.openhft</groupid><br>    <artifactid>affinity</artifactid><br>    <version>3.0.6</version><br></dependency>

<p>在初始化Disruptor实例时，ThreadFactory参数传入affinity线程亲和工厂。</p>
<blockquote>
<p>以Spring项目中实例化Disruptor为例：</p>
</blockquote>
<p><img src="/2022/02/28/Disruptor高性能之道-等待策略/disruptor-init.png" alt="disruptor-init.png"></p>
<hr>
<p><img src="/2022/02/28/Disruptor高性能之道-等待策略/openhft-affinity.png" alt="openhft-affinity.png"></p>
<h2 id="YieldingWaitStrategy"><a href="#YieldingWaitStrategy" class="headerlink" title="YieldingWaitStrategy"></a>YieldingWaitStrategy</h2><blockquote>
<p>YieldingWaitStrategy相比于SleepingWaitStrategy，实现机制就很激进，它完全基于Thread.yield出让cpu使用权，让CPU利用率保持在100%。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public final class YieldingWaitStrategy implements WaitStrategy</div><div class="line">&#123;</div><div class="line">    private static final int SPIN_TRIES = 100;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public long waitFor(</div><div class="line">        final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)</div><div class="line">        throws AlertException, InterruptedException</div><div class="line">    &#123;</div><div class="line">        long availableSequence;</div><div class="line">        int counter = SPIN_TRIES;</div><div class="line"></div><div class="line">        while ((availableSequence = dependentSequence.get()) &lt; sequence)</div><div class="line">        &#123;</div><div class="line">            counter = applyWaitMethod(barrier, counter);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return availableSequence;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void signalAllWhenBlocking()</div><div class="line">    &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>当消费者没有获取到可用的sequence，则循环执行applyWaitMethod。直到存在可用的sequence，就返回该sequence。</p>
<p>返回sequence之后就可以根据该sequence从RingBuffer中get出这个sequence对应的event，执行业务操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    private int applyWaitMethod(final SequenceBarrier barrier, int counter)</div><div class="line">        throws AlertException</div><div class="line">    &#123;</div><div class="line">        barrier.checkAlert();</div><div class="line"></div><div class="line">        // counter默认为100，在减小到0之前不会进入if分支</div><div class="line">        if (0 == counter)</div><div class="line">        &#123;</div><div class="line">            Thread.yield();</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            --counter;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return counter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先，counter默认为100，在减小到0之前不会进入if分支，直接进入else，执行减1操作。<blockquote>
<p>也就是说，首先会自旋重试100次（此值可设置，默认100次），如果在重试过程中，存在可用的序列号，则直接返回可用的序列号。</p>
</blockquote>
</li>
<li>如果自旋了100次，counter减到0了，还是没有得到可用的sequence序列号，那么就会调用Thread.yield方法，让渡CPU的使用权，让其它线程可以争抢到CPU使用权。当该线程再次获取CPU使用权时，继续该过程：如果没有可用的序列号，则继续放弃CPU使用权等待。</li>
</ul>
<blockquote>
<p>从分析我们可以看出，YieldingWaitStrategy基本上是在等待sequence期间，不断的通过Thread.yield出让CPU的使用权，因此这个策略会让CPU使用率保持在100%的满负荷，生产中强烈推荐 <strong>不要使用</strong> ！</p>
</blockquote>
<h2 id="盘点等待策略"><a href="#盘点等待策略" class="headerlink" title="盘点等待策略"></a>盘点等待策略</h2><ul>
<li>BlockingWaitStrategy：基于ReentrantLock的等待&amp;&amp;唤醒机制实现等待逻辑，该策略是Disruptor的默认策略，比较节省CPU，生产环境推荐使用；</li>
<li>BusySpinWaitStrategy：持续自旋，不推荐使用，会造成CPU负载100%；</li>
<li>DummyWaitStrategy：返回的Sequence值为0，正常情况下不使用</li>
<li>LiteBlockingWaitStrategy：基于BlockingWaitStrategy的轻量级等待策略，在没有锁竞争的时候会省去唤醒操作，但是作者说测试不充分，因此不建议使用</li>
<li>TimeoutBlockingWaitStrategy：带超时的等待策略，超时后会执行业务指定的处理逻辑</li>
<li>LiteTimeoutBlockingWaitStrategy：基于TimeoutBlockingWaitStrategy的策略，当没有锁竞争的时候会省去唤醒操作</li>
<li>SleepingWaitStrategy：三段式策略，第一阶段自旋，第二阶段执行Thread.yield让出CPU，第三阶段睡眠执行时间，反复的睡眠</li>
<li>YieldingWaitStrategy：二段式策略，第一阶段自旋，第二阶段执行Thread.yield交出CPU</li>
<li>PhasedBackoffWaitStrategy：四段式策略，第一阶段自旋指定次数，第二阶段自旋指定时间，第三阶段执行Thread.yield交出CPU，第四阶段调用成员变量的waitFor方法，该成员变量可以被设置为BlockingWaitStrategy、LiteBlockingWaitStrategy、SleepingWaitStrategy三个中的一个</li>
</ul>
<h2 id="扩展：单一写原则"><a href="#扩展：单一写原则" class="headerlink" title="扩展：单一写原则"></a>扩展：单一写原则</h2><p>在并发系统中提高性能最好的方式之一就是单一写原则，Disruptor中生产者就体现了这一原则。</p>
<p>如果在你的代码中仅仅有一个事件生产者，那么可以设置为单一生产者模式来提高系统的性能。</p>
<p>单一写的好处在于：完全不需要考虑同步多个写线程，写入操作没有上下文切换，并且是线程安全的（写入串行化）。</p>
<p>关于单一写原则，可以阅读： <a href="https://mechanical-sympathy.blogspot.com/2011/09/single-writer-principle.html" target="_blank" rel="external">https://mechanical-sympathy.blogspot.com/2011/09/single-writer-principle.html</a></p>
<p>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们接着介绍Disruptor高性能实现之道–等待策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;等待策略waitStrategy是一种决定一个消费者如何等待生产者将event对象放入Disruptor的方式/策略。&lt;/p&gt;
&lt;p&gt;等待策略waitStrategy是一个接口，它的所有实现都是针对消费者生效的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-环形数组RingBuffer</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84RingBuffer/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-环形数组RingBuffer/</id>
    <published>2022-02-28T10:10:16.000Z</published>
    <updated>2022-02-28T14:29:23.389Z</updated>
    
    <content type="html"><![CDATA[<p>Ringbuffer（环形缓冲区/环形数组）是Disruptor的核心底层数据结构。</p>
<p>它不同于传统的阻塞队列（如：ArrayBlockingQueue）是从某一端入队，另外一端出队，而是一种收尾相连的环形结构。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-环形数组RingBuffer/ringbuffer.png" alt="ringbuffer.png"></p>
<p>之所以叫它 buffer，我想大概是因为这个环形队列是作为不同线程（or上下文）之间传递数据媒介，类似于一个缓冲区。</p>
<p>RingBuffer拥有一个序号，指向数组中下一个可用的元素，需要注意的是Disruptor中的RingBuffer没有头尾指针，而只通过序号（sequence）就实现了生产者与消费者之间的进度协调。</p>
<h2 id="RingBuffer可以一直填充吗？"><a href="#RingBuffer可以一直填充吗？" class="headerlink" title="RingBuffer可以一直填充吗？"></a>RingBuffer可以一直填充吗？</h2><p>假如不断地填充RingBuffer，那么必然会发生sequence一直增加，直到绕过环，覆盖原有的内容。</p>
<p>Disruptor是通过barrier实现了是否要覆盖原有内容的判断，这部分内容后面会说到。</p>
<h2 id="如何定位RingBuffer中的元素呢？"><a href="#如何定位RingBuffer中的元素呢？" class="headerlink" title="如何定位RingBuffer中的元素呢？"></a>如何定位RingBuffer中的元素呢？</h2><p>正如我们在前面所说，RingBuffer本质上是个数组，那么必然可以通过数组的偏移量offset或者说index，定位到具体的元素。</p>
<p>在实际的开发中，我们常通过取模运算来获取元素在数组中的偏移量。也就是  <strong>序号 % 长度 == 索引</strong></p>
<p>假设有8个元素，那么元素序号为13的元素就位于：</p>
<blockquote>
<p>13 % 8 = 5</p>
</blockquote>
<p>对于Disruptor而言，它强制要求数组的size初始化为 2的N次方，如 1024 * 1024。</p>
<blockquote>
<p>设置为2的N次方有这样的好处：可以通过位运算更快速定位到元素位置。公式为：</p>
<p>seq &amp; (ringBufferSize - 1) == index</p>
</blockquote>
<p>在Disruptor中， ringBufferSize-1 成为mask，即掩码。</p>
<h2 id="RingBuffer中的数据是如何预热的？"><a href="#RingBuffer中的数据是如何预热的？" class="headerlink" title="RingBuffer中的数据是如何预热的？"></a>RingBuffer中的数据是如何预热的？</h2><p>RingBuffer通过预分配对象机制来降低GC的影响。在实际运行过程中，业务从RingBuffer中获取对应sequence位置的对象引用，对该引用指向的对象属性赋值，通过覆盖写方式而不是直接覆盖整个对象的方式，保证了对象引用在整个disruptor存活的周期内都存在，保证GCRoot始终存在，因此能够大幅降低GC的影响。</p>
<p>这也是Disruptor高性能保证的策略之一，由于Disruptor主要使用场景之一就是低延迟环境，因此必须减少运行时内存分配，从而减少垃圾回收导致的系统停顿（STW）。</p>
<blockquote>
<p>这种预加载机制在其他的中间件也有使用，如RocketMQ的commitLog也是在broker启动时就创建固定1G的文件，便于启动完成便可进行写入而不需要进行运行期创建。</p>
</blockquote>
<p>Disruptor的RingBuffer数据预热具体的实现，查看Disruptor源码：</p>
<p>Disruptor初始化过程中会初始化RingBuffer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RingBuffer( EventFactory&lt;E&gt; eventFactory,Sequencer sequencer)&#123;</div><div class="line">    super(eventFactory, sequencer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RingBuffer是RingBufferFields子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final class RingBuffer&lt;E&gt; extends RingBufferFields&lt;E&gt; implements Cursored, EventSequencer&lt;E&gt;, EventSink&lt;E&gt;</div></pre></td></tr></table></figure>
<p>初始化RingBuffer时会先调用父类构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">RingBufferFields(EventFactory&lt;E&gt; eventFactory, Sequencer sequencer) &#123;</div><div class="line">    this.sequencer = sequencer;</div><div class="line">    this.bufferSize = sequencer.getBufferSize();</div><div class="line"></div><div class="line">    if (bufferSize &lt; 1)</div><div class="line">    &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;bufferSize must not be less than 1&quot;);</div><div class="line">    &#125;</div><div class="line">    if (Integer.bitCount(bufferSize) != 1)</div><div class="line">    &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;bufferSize must be a power of 2&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 用于计算index的掩码，公式：seq &amp; (ringBufferSize - 1) == index</div><div class="line"></div><div class="line">    this.indexMask = bufferSize - 1;</div><div class="line"></div><div class="line">    // 初始化RingBuffer数组</div><div class="line"></div><div class="line">    this.entries = new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];</div><div class="line"></div><div class="line">    // 预填充RingBuffer数组</div><div class="line">    fill(eventFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用fill方法预填充数组，实现逻辑就是为数组的每个index填充一个对象实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void fill(EventFactory&lt;E&gt; eventFactory)&#123;</div><div class="line">    for (int i = 0; i &lt; bufferSize; i++)&#123;</div><div class="line">        entries[BUFFER_PAD + i] = eventFactory.newInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>填充操作通过用户定义的eventFactory实现，该工厂一般写法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class OrderEventFactory implements EventFactory&lt;OrderEvent&gt; &#123;</div><div class="line">    @Override</div><div class="line">    public OrderEvent newInstance() &#123;</div><div class="line">        // new 一个空的orderEvent对象即可</div><div class="line">        // 就是为了返回空的event对象</div><div class="line">        return new OrderEvent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ringbuffer（环形缓冲区/环形数组）是Disruptor的核心底层数据结构。&lt;/p&gt;
&lt;p&gt;它不同于传统的阻塞队列（如：ArrayBlockingQueue）是从某一端入队，另外一端出队，而是一种收尾相连的环形结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/0
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-缓存行填充</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A1%AB%E5%85%85/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-缓存行填充/</id>
    <published>2022-02-28T10:09:11.000Z</published>
    <updated>2022-02-28T15:52:06.696Z</updated>
    
    <content type="html"><![CDATA[<p>Disruptor高性能的另一个实现机制为 “缓存行填充”，它解决了CPU访问内存变量的“伪共享”问题。</p>
<h2 id="什么是伪共享？"><a href="#什么是伪共享？" class="headerlink" title="什么是伪共享？"></a>什么是伪共享？</h2><blockquote>
<p>在解释什么是伪共享之前，先了解下数据在缓存中是如何存储的。</p>
</blockquote>
<p>我们都知道，计算机为了解决CPU与主存之间速度差的问题，引入了多级缓存机制。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/cache-1.png" alt="cache-1.png"></p>
<p>事实上，数据在CPU缓存(多级cache)中并非是单独存储的，而是按行存储的。其中每一行成为一个缓存行。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/cache-2.png" alt="cache-2.png"></p>
<p>缓存行是CPU的Cache与主内存进行数据交换的基本单位，每个缓存行的大小一般为2的N次方字节。（<strong>在32位计算机中为32字节，64位计算机中为64字节。</strong>）可以想到，如果计算机为128位，则缓存行大小就是128字节。</p>
<p>在Java中，一个long型变量为8字节，也就是说在64位计算机中，每行可存放8个long型变量。</p>
<blockquote>
<p>当CPU访问某个变量的时，如果CPU Cache中存在该变量，则直接获取。若不存在则去主内存获取该变量。由于缓存行机制的存在，因此会将该变量所在内存区域为一个缓存行大小的内存复制到CPU Cache中。</p>
</blockquote>
<p>此时有可能会在一行缓存行中加载多个变量，如图中不同的颜色对应不同的long型变量。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/cache-3.png" alt="cache-3.png"></p>
<blockquote>
<p>试想，如果多个内核的线程都操作了同一缓存行的数据，如图所示。CPU1读取并修改了缓存行中的变量D，了解volatile的同学都知道，当CPU Cache中的变量发生变更，会通过缓存一致性协议通知其他CPU失效当前缓存行，重新从主内存中加载当前行的值。</p>
</blockquote>
<p><img src="/2022/02/28/Disruptor高性能之道-缓存行填充/expire.png" alt="expire.png"></p>
<p>图中，CPU1修改了缓存行中的变量D，CPU2也在读取该缓存行的值。根据缓存一致性协议，CPU2中的缓存行会失效，因为它操作的缓存行中的变量D的值已经不是最新值了。</p>
<p>这是因为CPU是以缓存行为单位进行数据的读写操作的。</p>
<p>这就是伪共享。</p>
<p>为什么是“伪”共享呢？ </p>
<blockquote>
<p>看起来CPU1 与 CPU2 共享了同一个缓存行，但是由于CPU以缓存行为单位进行读写操作，无论CPU1 与 CPU2中的任何一位修改了缓存行中的值，都需要通知其他CPU对失效该缓存行。也就是说当线程对缓存进行了写操作，则当前线程所在内核就需要失效其他内核的缓存行，并重新加载主内存。</p>
</blockquote>
<p>这是一种缓存未命中的情况，当发生这样的情况，缓存本身的意义就被削弱了，因为CPU始终需要从主内存加载数据，而根本命中不了CPU Cache中的缓存。</p>
<blockquote>
<p>所谓的“伪”共享，就可以理解成是一种 “错误”的共享，这种共享如果不发生，则多核CPU操作缓存行互不影响，每个核心都只关心自己操作的变量，而不会因为读写自己关心的变量而影响到其他CPU对变量的读写。</p>
</blockquote>
<h2 id="Disruptor是如何进行缓存行填充的？"><a href="#Disruptor是如何进行缓存行填充的？" class="headerlink" title="Disruptor是如何进行缓存行填充的？"></a>Disruptor是如何进行缓存行填充的？</h2><blockquote>
<p>Disruptor解决伪共享的方式为：使用缓存行填充。</p>
</blockquote>
<p>上文我们提到，由于多核CPU同时读写统一缓存行中的数据，导致了CPU Cache命中失败的伪共享问题。</p>
<p>那么只需要避免多核CPU同时操作统一缓存行，不就可以解决这个问题了么？</p>
<p>事实上，Disruptor正是这么做的。</p>
<blockquote>
<p>Disruptor为Sequence中的value（volatile修饰）进行了缓存行填充，保证每个sequence只在一个缓存行中存在，避免了其他的变量对sequence的干扰。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">class LhsPadding</div><div class="line">&#123;</div><div class="line">    protected long p1, p2, p3, p4, p5, p6, p7;  // 缓存行填充</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Value extends LhsPadding</div><div class="line">&#123;</div><div class="line">    protected volatile long value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class RhsPadding extends Value</div><div class="line">&#123;</div><div class="line">    protected long p9, p10, p11, p12, p13, p14, p15; // 缓存行填充</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * &lt;p&gt;Concurrent sequence class used for tracking the progress of</div><div class="line"> * the ring buffer and event processors.  Support a number</div><div class="line"> * of concurrent operations including CAS and order writes.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Also attempts to be more efficient with regards to false</div><div class="line"> * sharing by adding padding around the volatile field.</div><div class="line"> */</div><div class="line">public class Sequence extends RhsPadding</div><div class="line">&#123;</div><div class="line">    static final long INITIAL_VALUE = -1L;</div><div class="line">    private static final Unsafe UNSAFE;</div><div class="line">    private static final long VALUE_OFFSET;</div><div class="line"></div><div class="line">    static</div><div class="line">    &#123;</div><div class="line">        UNSAFE = Util.getUnsafe();</div><div class="line">        try</div><div class="line">        &#123;</div><div class="line">            VALUE_OFFSET = UNSAFE.objectFieldOffset(Value.class.getDeclaredField(&quot;value&quot;));</div><div class="line">        &#125;</div><div class="line">        catch (final Exception e)</div><div class="line">        &#123;</div><div class="line">            throw new RuntimeException(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="其他的缓存行填充机制"><a href="#其他的缓存行填充机制" class="headerlink" title="其他的缓存行填充机制"></a>其他的缓存行填充机制</h2><p>JDK1.8 提供了注解 <strong>@Contended</strong> 用于解决伪共享问题，需要注意的是，如果业务代码需要使用该注解，要添加JVM参数</p>
<blockquote>
<p>-XX:-RestrictContended。</p>
</blockquote>
<p>默认填充宽度为128，若需要自定义填充宽度，则设置 </p>
<blockquote>
<p>-XX:ContendedPaddingWidth</p>
</blockquote>
<p>具体的使用方式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@sun.misc.Contended</div><div class="line">public final static class Value &#123;</div><div class="line">  public volatile long value = 0L;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Java并发编程之美》</li>
<li>并发编程网：剖析Disruptor:为什么会这么快？（二）神奇的缓存行填充</li>
</ul>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Disruptor高性能的另一个实现机制为 “缓存行填充”，它解决了CPU访问内存变量的“伪共享”问题。&lt;/p&gt;
&lt;h2 id=&quot;什么是伪共享？&quot;&gt;&lt;a href=&quot;#什么是伪共享？&quot; class=&quot;headerlink&quot; title=&quot;什么是伪共享？&quot;&gt;&lt;/a&gt;什么是伪共
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
  <entry>
    <title>Disruptor高性能之道-无锁</title>
    <link href="http://wuwenliang.net/2022/02/28/Disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93-%E6%97%A0%E9%94%81/"/>
    <id>http://wuwenliang.net/2022/02/28/Disruptor高性能之道-无锁/</id>
    <published>2022-02-28T10:08:59.000Z</published>
    <updated>2022-03-01T16:35:45.282Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，我们讨论了Disruptor高性能实现机制中的：</p>
<ul>
<li>RingBuffer环形队列及内存预加载</li>
<li>缓存行填充避免伪共享</li>
</ul>
<p>本文开始之前先对之前没有讲到的细节进行补充。</p>
<h2 id="对于数组元素预加载的补充解释"><a href="#对于数组元素预加载的补充解释" class="headerlink" title="对于数组元素预加载的补充解释"></a>对于数组元素预加载的补充解释</h2><pre><code>private void fill(EventFactory&lt;E&gt; eventFactory)
{
    for (int i = 0; i &lt; bufferSize; i++)
    {
        entries[BUFFER_PAD + i] = eventFactory.newInstance();
    }
}
</code></pre><p>一次性填充慢整个数组，这样做是一个比较有技巧的做法，Disruptor通过填充慢数组，在运行时改变对象的值来达到防止Java垃圾回收（GC）产生的系统开销。</p>
<p>换句话说就是它不需要垃圾回收。<br><a id="more"></a></p>
<h2 id="Disruptor是如何通过位运算提升取模效率的？"><a href="#Disruptor是如何通过位运算提升取模效率的？" class="headerlink" title="Disruptor是如何通过位运算提升取模效率的？"></a>Disruptor是如何通过位运算提升取模效率的？</h2><p>我们已经知道，RingBufferSize为2的N次方时，可以通过位于运算提升取模效率，公式为：</p>
<blockquote>
<p>seq &amp; (ringBufferSize - 1) == index</p>
</blockquote>
<p>即：当前event的sequence与RingBufferSize-1的差进行位于运算，就等价于sequence Mod RingBufferSize，但是效率更高。</p>
<p>在Disruptor的源码中具体是如何利用该机制的？</p>
<pre><code>@Override
public E get(long sequence)
{
    return elementAt(sequence);
}
</code></pre><blockquote>
<p>Disruptor通过get(sequence)从RingBuffer中取出下一个可用的sequence位于RingBuffer中的下标，具体实现在elementAt方法中。</p>
</blockquote>
<pre><code>// com.lmax.disruptor.RingBufferFields#elementAt
protected final E elementAt(long sequence)
{
    return (E) UNSAFE.getObject(entries, REF_ARRAY_BASE + ((sequence &amp; indexMask) &lt;&lt; REF_ELEMENT_SHIFT));
}
</code></pre><blockquote>
<p>可以看到elementAt是通过UNSAFE直接调用底层方法getObject，通过递增序列号获取与序列号对应的数组元素。</p>
</blockquote>
<h2 id="缓存行填充与局部性原理"><a href="#缓存行填充与局部性原理" class="headerlink" title="缓存行填充与局部性原理"></a>缓存行填充与局部性原理</h2><p>我们知道Disruptor是通过缓存行填充避免了伪共享问题。</p>
<p>实际上这与 “局部性原理” 息息相关。</p>
<blockquote>
<p>解释下什么叫做：局部性原理。</p>
<p>程序的局部性原理指的是在一段时间内程序的执行会限定在一个局部范围内。<br>这里的“局部性”可以从两个方面来理解，一个是时间局部性，另一个是空间局部性。</p>
<p>时间局部性指的是程序中的某条指令一旦被执行，不久之后这条指令很可能再次被执行；如果某条数据被访问，不久之后这条数据很可能再次被访问。</p>
<p>而空间局部性是指某块内存一旦被访问，不久之后这块内存附近的内存也很可能被访问。</p>
</blockquote>
<p>CPU缓存读写就利用了局部性原理。</p>
<p>当CPU从主内存加载数据A时，它会将数据A缓存至CPU的高速缓存cache中。除了A会被缓存，A附近的数据也会被缓存。</p>
<p>根据局部性原理分析，由于A会被访问，那么A周围的其他数据也很有可能会被访问，如果一并加载则会提升程序的性能。</p>
<p>但是由于多核CPU同时修改同一缓存行，导致缓存行失效后重新加载主内存，因此出现了伪共享的问题。</p>
<h2 id="再次分析Disruptor对变量的缓存行填充原理"><a href="#再次分析Disruptor对变量的缓存行填充原理" class="headerlink" title="再次分析Disruptor对变量的缓存行填充原理"></a>再次分析Disruptor对变量的缓存行填充原理</h2><p>首先看一下Disruptor中对 INITIAL_CURSOR_VALUE 的特殊处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final class RingBuffer&lt;E&gt; extends RingBufferFields&lt;E&gt; implements Cursored, EventSequencer&lt;E&gt;, EventSink&lt;E&gt;</div><div class="line">&#123;</div><div class="line">    public static final long INITIAL_CURSOR_VALUE = Sequence.INITIAL_VALUE;</div><div class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</div></pre></td></tr></table></figure>
<p>RingBuffer继承于RingBufferField</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">abstract class RingBufferFields&lt;E&gt; extends RingBufferPad</div></pre></td></tr></table></figure>
<p>RingBufferFields继承于RingBufferPad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">abstract class RingBufferPad</div><div class="line">&#123;</div><div class="line">    protected long p1, p2, p3, p4, p5, p6, p7;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我们就知道，在INITIAL_CURSOR_VALUE前后各填充了7个long型变量。</p>
<p>前面的 7 个来自继承的 RingBufferPad 类，后面的 7 个则是直接定义在 RingBuffer 类里<br>面。</p>
<p><strong>这14个变量没有任何实际的用途。既不会去读也不会去写他们。</strong></p>
<p><img src="/2022/02/28/Disruptor高性能之道-无锁/padding.png" alt="padding.png"></p>
<p>可以看到，常量INITIAL_CURSOR_VALUE前后各填充了7个long型变量，无论CPU高速缓存如何加载缓存行（一个缓存行8个long型长度），整个缓存行都没有会发生变更的数据，这个8个long类型的缓存行无论如何加载上面的内存行，都能够读到常量，且不会加载除了常量的其他变量。</p>
<blockquote>
<p>而INITIAL_CURSOR_VALUE是一个常量，也不会进行修改。所以一旦它被加载到CPU Cache 之后，只要被频繁地读取访问，就不会再被换出 Cache 了。这也就意味着对于这个值的读取速度，会是<strong>一直是 CPU Cache 的访问速度，而不是内存的访问速度</strong>。</p>
</blockquote>
<p>这有效的解决了伪共享的问题。</p>
<h2 id="无锁的Disruptor"><a href="#无锁的Disruptor" class="headerlink" title="无锁的Disruptor"></a>无锁的Disruptor</h2><p>JUC中的队列BlockingQueue是通过加锁实现对生产者和消费者的协调。</p>
<p>加锁就意味着需要牺牲高性能，换来线程安全。</p>
<p>有没有办法既能高性能，还能线程安全？</p>
<p>Disruptor给出的答案是，“无锁”。</p>
<blockquote>
<p>无锁，并不是完全消除锁，而是指没有OS层面的锁。</p>
<p>Disruptor通过CAS（Compare And Swap）指令实现了无锁化。具体的指令是cmpxchg，本文会做简单讲解。感兴趣的读者可以自行搜索资料了解详细内容。</p>
</blockquote>
<p>简单解释下CAS具体干了什么事情。</p>
<blockquote>
<p>CAS, 比较并交换，Compare And Swap。顾名思义，就是通过比较值是否发生变化，决定是否要重新赋值。<br>如果在操作期间，值没有被其他线程操作，那么就将期望的值赋值给它，否则发现期望的值与旧值不等，说明值已经变更，则不执行操作，返回操作失败。</p>
</blockquote>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>比如说，旧值oldValue为1，期望的值expectValue为1，新值newValue为2。如果没有其他线程修改旧值，那么</p>
<ul>
<li>expectValue == oldValue</li>
<li>将newValue写入，当前值为2</li>
</ul>
<p>如果在操作过程中，oldValue被其他线程操作修改为2，那么当前线程的expectValue（1）与oldValue（2）比较就不等，写入失败。</p>
<h3 id="Disruptor如何进行CAS"><a href="#Disruptor如何进行CAS" class="headerlink" title="Disruptor如何进行CAS"></a>Disruptor如何进行CAS</h3><p>我们知道Disruptor核心数据结构为RingBuffer，Disruptor为RingBuffer分配了一个Sequence对象，用于标识RingBuffer的头和尾，这个标识不是通过指针实现的，而是通过序号。</p>
<blockquote>
<p>这个序号也就是Sequence。</p>
</blockquote>
<p>虽然逻辑上RingBuffer是一个环形数组，但是在内存中是以一个普通的数组形式存在的。</p>
<p>RingBuffer中通过对比序号的方式对生产者和消费者间的资源进行协调。</p>
<p>每当生产者要往队列中加入新数据，生产者都会将当前sequence + 准备加入队列的数据量，与消费者所在位置进行比较，以判断是否存在足够的空间放这些数据，而不至于覆盖掉消费者没有消费的数据。</p>
<p>用体育术语就叫“套圈”。</p>
<p>如图所示：ringBufferSize=16，生产者当前sequence指向20，消费者sequence指向27。</p>
<p><img src="/2022/02/28/Disruptor高性能之道-无锁/cas.png" alt="cas.png"></p>
<p>我们简单计算一下这个场景下，生产者能否继续写入4个元素。</p>
<ul>
<li>对于消费者而言，27 MOD 16 = 11</li>
<li>对于生产者而言，20 + 4 = 24（预计写入的最大序号），24 MOD 16 = 8</li>
<li>生产者若成功写入4个元素，则sequence指向数组的第8个位置，8 &lt; 11, 表明生产者没有覆盖消费者的进度。</li>
<li>生产者不需要等待消费者，直接生产数据即可。而且并不会覆盖消费者未处理完的数据。</li>
</ul>
<p><img src="/2022/02/28/Disruptor高性能之道-无锁/cas1.png" alt="cas1.png"></p>
<p>实际上，Disruptor的代码实现就是通过compareAndSet方法实现了CAS无锁化操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Atomically add the supplied value.</div><div class="line"> *</div><div class="line"> * @param increment The value to add to the sequence.</div><div class="line"> * @return The value after the increment.</div><div class="line"> */</div><div class="line">public long addAndGet(final long increment)</div><div class="line">&#123;</div><div class="line">    long currentValue;</div><div class="line">    long newValue;</div><div class="line"></div><div class="line">    do</div><div class="line">    &#123;</div><div class="line">        currentValue = get();</div><div class="line">        newValue = currentValue + increment;</div><div class="line">    &#125;</div><div class="line">    while (!compareAndSet(currentValue, newValue));</div><div class="line"></div><div class="line">    return newValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，这里通过while循环不断尝试CAS操作，如果CAS操作不成功就会自旋重试，这个操作并没有使用OS层面的锁，因此效率要大幅高于OS层面的锁机制（管程）。</p>
<p>addAndGet调用了compareAndSet方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Perform a compare and set operation on the sequence.</div><div class="line"> *</div><div class="line"> * @param expectedValue The expected current value.</div><div class="line"> * @param newValue The value to update to.</div><div class="line"> * @return true if the operation succeeds, false otherwise.</div><div class="line"> */</div><div class="line">public boolean compareAndSet(final long expectedValue, final long newValue)</div><div class="line">&#123;</div><div class="line">    return UNSAFE.compareAndSwapLong(this, VALUE_OFFSET, expectedValue, newValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到最终是调用了UNSAFE的compareAndSwapLong方法，该方法为native方法，在JVM层面调用了CAS指令。</p>
<h3 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h3><p>上文我们提到，Disruptor的CAS最终调用的是CPU层面的机器指令<strong>cmpxchg</strong>。</p>
<p>该指令的详细描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compxchg [ax] (隐式参数，EAX 累加器), </div><div class="line">         [bx] (源操作数地址), </div><div class="line">         [cx] (目标操作数地址)</div></pre></td></tr></table></figure>
<p>简单解释下：</p>
<ul>
<li>cmpxchg指令有三个操作数，操作数ax不在指令里面出现，是一个隐式的操作数，准确地说它是EAX累加寄存器里面的值。</li>
<li>操作数bx是源操作数，指令会对比这个操作数和上面的累加寄存器里面的值是否相等，如果相等<br>CPU 会把 ZF（也就是条件码寄存器里面零标志位的值）设置为 1，然后再把操作数cx（也就是目标操作数）设置到源操作数的地址上。</li>
<li>如果不相等的话，就把源操作数里面的值设置到累加器寄存器里面</li>
</ul>
<p>由于cmpxchg是cpu级别的指令，因此直接调用就可以保证cas操作的原子性。</p>
<p>由于去除了OS层面的锁，即便CAS存在比较操作与自旋操作，其本质也是无锁化操作，这种无锁化机制消除了上下文切换，对于CPU极为友好，因此运行效率很快。</p>
<p>事实上，在JUC包中，也提供了大量的CAS相关工作类方便我们操作，这些类一般以atomic开头，如果去研究其实现，我们同样会发现最终是通过UNSAFE调用了底层的CAS实现，实现无锁化操作，减少上下文切换，提升代码运行速率。</p>
<blockquote>
<p>加锁导致的上下文切换之所以会显著影响代码运行速度，主要原因在于获取锁的过程中，CPU需要等待OS层面的锁竞争结果，对于没有获取锁的线程需要进行挂起，此时就需要进行上下文切换。</p>
<p>上下文切换会把挂起线程的寄存器中的数据放到线程栈，该操作会导致加载到高速缓存中的数据也失效，进而导致程序运行速率比无锁更慢。</p>
</blockquote>
<h3 id="CAS就没有什么问题么？"><a href="#CAS就没有什么问题么？" class="headerlink" title="CAS就没有什么问题么？"></a>CAS就没有什么问题么？</h3><p>当然CAS操作同样也会存在缺点，那就是由于CAS操作本身需要进行对比，如果不相等则会一直自旋（busy-wait），这样的操作会使得cpu的负载升高，全功率满负荷运行。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，我们讨论了Disruptor高性能实现机制中的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RingBuffer环形队列及内存预加载&lt;/li&gt;
&lt;li&gt;缓存行填充避免伪共享&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文开始之前先对之前没有讲到的细节进行补充。&lt;/p&gt;
&lt;h2 id=&quot;对于数组元素预加载的补充解释&quot;&gt;&lt;a href=&quot;#对于数组元素预加载的补充解释&quot; class=&quot;headerlink&quot; title=&quot;对于数组元素预加载的补充解释&quot;&gt;&lt;/a&gt;对于数组元素预加载的补充解释&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;private void fill(EventFactory&amp;lt;E&amp;gt; eventFactory)
{
    for (int i = 0; i &amp;lt; bufferSize; i++)
    {
        entries[BUFFER_PAD + i] = eventFactory.newInstance();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一次性填充慢整个数组，这样做是一个比较有技巧的做法，Disruptor通过填充慢数组，在运行时改变对象的值来达到防止Java垃圾回收（GC）产生的系统开销。&lt;/p&gt;
&lt;p&gt;换句话说就是它不需要垃圾回收。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="disruptor" scheme="http://wuwenliang.net/categories/disruptor/"/>
    
    
      <category term="disruptor" scheme="http://wuwenliang.net/tags/disruptor/"/>
    
  </entry>
  
</feed>
