
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>源码级探究Mybatis原理-以查询为例 | 朝·闻·道</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="SnoWalker">
    

    <meta name="keywords" content="MyBatis">
    <meta name="description" content="作为一名Java后端开发者，尤其是国内开发者，从刚参加工作开始就与Mybatis打交道了。
用了这么久的Mybatis难免会心生疑问：

我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？
都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？
为什么在Spring中使用Mybatis，不用加@Reposito">
<meta property="og:type" content="article">
<meta property="og:title" content="源码级探究Mybatis原理-以查询为例">
<meta property="og:url" content="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/index.html">
<meta property="og:site_name" content="朝·闻·道">
<meta property="og:description" content="作为一名Java后端开发者，尤其是国内开发者，从刚参加工作开始就与Mybatis打交道了。
用了这么久的Mybatis难免会心生疑问：

我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？
都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？
为什么在Spring中使用Mybatis，不用加@Reposito">
<meta property="og:image" content="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/1.png">
<meta property="og:image" content="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/1.png">
<meta property="og:image" content="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/2.png">
<meta property="og:image" content="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/3.png">
<meta property="og:image" content="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/4.png">
<meta property="og:updated_time" content="2022-02-20T16:21:39.428Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="源码级探究Mybatis原理-以查询为例">
<meta name="twitter:description" content="作为一名Java后端开发者，尤其是国内开发者，从刚参加工作开始就与Mybatis打交道了。
用了这么久的Mybatis难免会心生疑问：

我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？
都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？
为什么在Spring中使用Mybatis，不用加@Reposito">
<meta name="twitter:image" content="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/1.png">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="朝·闻·道" title="朝·闻·道"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="朝·闻·道">朝·闻·道</a></h1>
				<h2 class="blog-motto">SnoWalker&#39;s Blog</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/index.html">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/old/index.html">旧版</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:wuwenliang.net">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/02/20/源码级探究Mybatis原理-以查询为例/" title="源码级探究Mybatis原理-以查询为例" itemprop="url">源码级探究Mybatis原理-以查询为例</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="SnoWalker" target="_blank" itemprop="author">SnoWalker</a>
		
  <p class="article-time">
    <time datetime="2022-02-20T14:03:15.000Z" itemprop="datePublished"> 发表于 2022-02-20</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、先看一个demo"><span class="toc-number">1.</span> <span class="toc-text">一、先看一个demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、一图总览全局"><span class="toc-number">2.</span> <span class="toc-text">二、一图总览全局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载并解析配置文件"><span class="toc-number">2.1.</span> <span class="toc-text">加载并解析配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取SqlSession对象作为与数据库交互的接口"><span class="toc-number">2.2.</span> <span class="toc-text">获取SqlSession对象作为与数据库交互的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过SqlSessionFactory获取SqlSession会话"><span class="toc-number">2.3.</span> <span class="toc-text">通过SqlSessionFactory获取SqlSession会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过Executor对象封装数据库操作，执行SQL操作"><span class="toc-number">2.4.</span> <span class="toc-text">通过Executor对象封装数据库操作，执行SQL操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、走进源码，一探究竟"><span class="toc-number">3.</span> <span class="toc-text">三、走进源码，一探究竟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-SqlSessionFactory的创建"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 SqlSessionFactory的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-SqlSession的创建"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 SqlSession的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理Mapper对象，执行SQL"><span class="toc-number">3.3.</span> <span class="toc-text">代理Mapper对象，执行SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapperProxy具体是如何创建的Mapper代理？"><span class="toc-number">3.4.</span> <span class="toc-text">MapperProxy具体是如何创建的Mapper代理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis执行sql语句的真正开端："><span class="toc-number">4.</span> <span class="toc-text">Mybatis执行sql语句的真正开端：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#看到jdbc了，胜利的曙光。"><span class="toc-number">4.1.</span> <span class="toc-text">看到jdbc了，胜利的曙光。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通过Statement去执行sql"><span class="toc-number">4.1.1.</span> <span class="toc-text">通过Statement去执行sql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过resultSetHandler处理结果集"><span class="toc-number">4.1.2.</span> <span class="toc-text">通过resultSetHandler处理结果集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？"><span class="toc-number">5.1.</span> <span class="toc-text">我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？"><span class="toc-number">5.2.</span> <span class="toc-text">都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在Spring中使用Mybatis，不用加-Repository-Component之类的注解，就可以随用随注入（如：-Autowired）"><span class="toc-number">5.3.</span> <span class="toc-text">为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?</span></a></li></ol></li></ol>
		
		</div>
		
		<p>作为一名Java后端开发者，尤其是国内开发者，从刚参加工作开始就与Mybatis打交道了。</p>
<p>用了这么久的Mybatis难免会心生疑问：</p>
<ul>
<li>我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？</li>
<li>都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？</li>
<li>为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?</li>
</ul>
<blockquote>
<p>硬核万字长文，点个再看，转发，多谢啦~</p>
</blockquote>
<a id="more"></a>
<p>随着工作经验越多，对这些问题的疑惑就会越发强烈。而读源码是解决这些疑问的根本方法。</p>
<p>那么就跟随笔者的脚步，试着用一篇文章，以一个查询为例，从源码角度一步一步揭开Mybatis的神秘面纱。</p>
<h2 id="一、先看一个demo"><a href="#一、先看一个demo" class="headerlink" title="一、先看一个demo"></a>一、先看一个demo</h2><pre><code>private SqlSessionFactory sqlSessionFactory;

@Before
public void prepare() throws IOException {
    String resource = &quot;mybatis-config.xml&quot;;
    InputStream inputStream = Resources.getResourceAsStream(resource);
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
}

/**
 * 通过 SqlSession.getMapper(XXXMapper.class)  接口方式
 * @throws IOException
 */
@Test
public void testSelect() throws IOException {
    SqlSession session = sqlSessionFactory.openSession(); // ExecutorType.BATCH
    try {
        BlogMapper mapper = session.getMapper(BlogMapper.class);
        Blog blog = mapper.selectBlogById(1);
        System.out.println(blog);
    } finally {
        session.close();
    }
}
</code></pre><p>这是一个非Spring项目的Test用例类，逻辑很直观，就是在测试通过id查询一行记录；在执行查询之间加载配置文件。</p>
<p>执行该测试用例，日志输出如下：</p>
<pre><code>Opening JDBC Connection
Created connection 1325808650.
Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@4f063c0a]
==&gt;  Preparing: select * from blog where bid = ? 
==&gt; Parameters: 1(Integer)
&lt;==    Columns: bid, name, author_id, type
&lt;==        Row: 1, RabbitMQ延时消息, 1001, 0
getNullableResult---1NORMAL
&lt;==      Total: 1
Blog(bid=1, name=RabbitMQ延时消息, authorId=1001, blogType=0)
</code></pre><p>我们就通过这个ById查询的案例，对Mybatis运行的过程抽丝剥茧，还原出一个完整的脉络。</p>
<h2 id="二、一图总览全局"><a href="#二、一图总览全局" class="headerlink" title="二、一图总览全局"></a>二、一图总览全局</h2><blockquote>
<p>按照惯例我们用一张简单概括的流程图引领全局，先建立一个宏观的印象。</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/1.png" alt="1.png"></p>
<p>从图中可以看到，Mybatis主要的工作流程分为以下几步：</p>
<ol>
<li>加载并解析配置文件</li>
<li>获取SqlSession对象作为与数据库交互的接口</li>
<li>通过Executor对象封装数据库操作，执行SQL操作</li>
<li>调用底层的JDBC接口，与数据库进行真正的交互</li>
<li>向数据库提交参数，并封装返回参数</li>
</ol>
<h3 id="加载并解析配置文件"><a href="#加载并解析配置文件" class="headerlink" title="加载并解析配置文件"></a>加载并解析配置文件</h3><p>在Mybatis启动的时候回去加载配置文件，一般来说文件包含全局配置文件（文件名为 <strong>mybatis-config.xml</strong>） ，以及映射器配置文件（也就是各种Mapper.xml文件）；</p>
<h3 id="获取SqlSession对象作为与数据库交互的接口"><a href="#获取SqlSession对象作为与数据库交互的接口" class="headerlink" title="获取SqlSession对象作为与数据库交互的接口"></a>获取SqlSession对象作为与数据库交互的接口</h3><p>Mybatis在加载完配置文件之后，会去获取SqlSession对象，这个对象是应用程序与数据库之间的桥梁，封装了程序与数据库之间的连接。</p>
<p>一般来说，一个SqlSession对象中包含了一个Connection，我们都知道Connection是线程不安全的，因此导致SqlSession对象也是线程不安全的。因此如果将SqlSession作为成员变量使用，存在风险。（应当使用SqlSessionTemplate，这部分后面再说）。</p>
<blockquote>
<p>注意：SqlSession是提供给应用层的一个访问数据库的接口，它并不是真正的SQL执行者，它内部封装了JDBC核心对象，如Statement，ResultSet等。</p>
</blockquote>
<h3 id="通过SqlSessionFactory获取SqlSession会话"><a href="#通过SqlSessionFactory获取SqlSession会话" class="headerlink" title="通过SqlSessionFactory获取SqlSession会话"></a>通过SqlSessionFactory获取SqlSession会话</h3><p>如果要获取一个SqlSession会话，就需要有会话工厂，即：SqlSessionFactory。它包含了所有的配置信息，而Factory又是通过Builder创建的，这部分后文代码分析中会说。</p>
<h3 id="通过Executor对象封装数据库操作，执行SQL操作"><a href="#通过Executor对象封装数据库操作，执行SQL操作" class="headerlink" title="通过Executor对象封装数据库操作，执行SQL操作"></a>通过Executor对象封装数据库操作，执行SQL操作</h3><p>SqlSession持有Executor对象，Executor在执行query、update、insert等操作时，会创建一系列的对象处理参数、处理结果集，核心的对象是StatementHandler，它本质上是对Statement的封装。</p>
<h2 id="三、走进源码，一探究竟"><a href="#三、走进源码，一探究竟" class="headerlink" title="三、走进源码，一探究竟"></a>三、走进源码，一探究竟</h2><h3 id="3-1-SqlSessionFactory的创建"><a href="#3-1-SqlSessionFactory的创建" class="headerlink" title="3.1 SqlSessionFactory的创建"></a>3.1 SqlSessionFactory的创建</h3><blockquote>
<p>首先是SqlSession的创建过程；SqlSession需要通过SqlSessionFactory创建，而SqlSessionFactory又是通过SqlSessionFactoryBuilder创建的。</p>
</blockquote>
<pre><code># org.apache.ibatis.session.SqlSessionFactoryBuilder#build
public SqlSessionFactory build(InputStream inputStream) {
  return build(inputStream, null, null);
}
</code></pre><p>事实上，inputStream就是配置文件的文件输入流，它传给了SqlSessionFactoryBuilder的build重载方法，我们看一下这个方法的实现。</p>
<pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    // 用于解析 mybatis-config.xml，同时创建了 Configuration 对象 &gt;&gt;
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    // 解析XML，最终返回一个 DefaultSqlSessionFactory &gt;&gt;
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}
</code></pre><p>可以看到，SqlSessionFactoryBuilder底层是通过xml解析方式，对配置文件进行解析，并基于解析的结果构建了SqlSessionFactory的实例，这里返回的是默认的SqlSessionFactory—&gt;DefaultSqlSessionFactory。</p>
<pre><code>public SqlSessionFactory build(Configuration config) {
  return new DefaultSqlSessionFactory(config);
}
</code></pre><p><strong>注意：此处就已经通过配置文件解析出了Configuration，并通过DefaultSqlSessionFactory构造方法创建了DefaultSqlSessionFactory实例。后文要用！</strong></p>
<blockquote>
<p>xml解析过程，感兴趣的读者可以自行研究，简单的说无非就是对xml文件的dom节点进行读取和匹配，获取属性加载到内存，Mybatis自己基于javax的xml操作api封装了一个工具类，<strong>org.apache.ibatis.parsing.XPathParser</strong> 。</p>
</blockquote>
<h3 id="3-2-SqlSession的创建"><a href="#3-2-SqlSession的创建" class="headerlink" title="3.2 SqlSession的创建"></a>3.2 SqlSession的创建</h3><p>在使用的demo中，我们通过SqlSessionFactory获取到一个SqlSession实例。</p>
<pre><code>SqlSession session = sqlSessionFactory.openSession();
</code></pre><p>进入 openSession 方法一探究竟。</p>
<pre><code># org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSession()
public SqlSession openSession() {
  return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
}
</code></pre><p>继续进入 openSessionFromDataSource 方法：</p>
<pre><code>private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
  Transaction tx = null;
  try {
    final Environment environment = configuration.getEnvironment();
    // 获取事务工厂
    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
    // 创建事务
    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
    // 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;
    final Executor executor = configuration.newExecutor(tx, execType);
    return new DefaultSqlSession(configuration, executor, autoCommit);
  } catch (Exception e) {
    closeTransaction(tx); // may have fetched a connection so lets call close()
    throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
</code></pre><p>这里的逻辑比较核心，主要做了几件事：</p>
<ol>
<li>获取到事务工厂；</li>
<li>通过事务工厂创建了事务，如果是使用Spring框架，则由Spring框架开启事务；</li>
<li>根据事务工厂和默认的执行器类型，创建执行器</li>
</ol>
<p>最后通过DefaultSqlSession的构造方法，创建出DefaultSqlSession实例，它是SqlSession接口的默认实现。</p>
<p>到此，我们就持有了一个SqlSession对象，并且它还持有了一个Executor执行器实例。</p>
<h3 id="代理Mapper对象，执行SQL"><a href="#代理Mapper对象，执行SQL" class="headerlink" title="代理Mapper对象，执行SQL"></a>代理Mapper对象，执行SQL</h3><p>回到我们的demo代码中：</p>
<pre><code>@Test
public void testSelect() throws IOException {
    SqlSession session = sqlSessionFactory.openSession(); // ExecutorType.BATCH
    try {
        // 重点看这行代码
        BlogMapper mapper = session.getMapper(BlogMapper.class);
        Blog blog = mapper.selectBlogById(1);
        System.out.println(blog);
    } finally {
        session.close();
    }
}
</code></pre><p>我们已经拿到了SqlSession，接着通过 <strong>session.getMapper(BlogMapper.class)</strong>; 获取到了BlogMapper接口的实现类。</p>
<p>注意，我说的并不是获取到了BlogMapper，因为大家使用过Mybatis框架都知道BlogMapper是个接口，那么此处拿到的，必然是BlogMapper的实例。</p>
<p>接口的实例，嗯，有点意思了，我们明明只写了个接口，并没有实现这个接口啊？</p>
<p>是不是想到了什么？对，就是动态代理。</p>
<p>此处获取到的Mapper实例，就是Mybatis框架帮我们创建出的代理对象。</p>
<blockquote>
<p>进入 DefaultSqlSession#getMapper 方法</p>
</blockquote>
<pre><code>@Override
public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
  return configuration.getMapper(type, this);
}
</code></pre><p>ok，继续往下看：</p>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre><p>这里，我们发现Mapper对象是通过 mapperRegistry 这个所谓的Mapper注册中心中获取到的，它的数据结构是一个HashMap:</p>
<pre><code># org.apache.ibatis.session.Configuration
protected final MapperRegistry mapperRegistry = new MapperRegistry(this);

# org.apache.ibatis.binding.MapperRegistry
public class MapperRegistry {
  private final Configuration config;
  private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();
</code></pre><p>既然我们能够通过Mapper接口类型get到接口的代理类，那它是多会儿put到Map里的?</p>
<p>仔细想一下应当能够想到，我们此时已经是在sql的执行期了，在这之前必然是配置文件的解析期间执行的put操作。具体代码如下：</p>
<pre><code>/**
* org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement
* Mapper解析
* @param parent
* @throws Exception
*/
private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    for (XNode child : parent.getChildren()) {
      // 不同的定义方式的扫描，最终都是调用 addMapper()方法
      // （添加到 MapperRegistry）。这个方法和 getMapper() 对应

      // package    包

      if (&quot;package&quot;.equals(child.getName())) {
        String mapperPackage = child.getStringAttribute(&quot;name&quot;);
        configuration.addMappers(mapperPackage);

      } else {
        String resource = child.getStringAttribute(&quot;resource&quot;);
        String url = child.getStringAttribute(&quot;url&quot;);
        String mapperClass = child.getStringAttribute(&quot;class&quot;);

        if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {

          // resource    相对路径

          ErrorContext.instance().resource(resource);
          InputStream inputStream = Resources.getResourceAsStream(resource);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          // 解析 Mapper.xml，总体上做了两件事情 &gt;&gt;
          mapperParser.parse();

        } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {

          // url    绝对路径

          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();

        } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
          // class     单个接口
          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
        }
      }
    }
  }
}
</code></pre><p>通过这段代码我们可以看到，无论是通过指定扫描包路径，还是resources相对路径，或者url绝对路径，或者单个Mapper添加的方式，Mybatis本质上都是通过 <strong>addMapper()方法添加到 MapperRegistry</strong>。</p>
<blockquote>
<p>继续回到Mapper代理对象创建过程中来。</p>
</blockquote>
<pre><code># org.apache.ibatis.session.Configuration#getMapper
public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre><p>继续看mapperRegistry.getMapper方法逻辑。</p>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
  }
  try {
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);
  }
}
</code></pre><p>我们发现，通过接口类型从HashMap中取到了一个 <strong>MapperProxyFactory</strong> Mapper代理工厂的实例。</p>
<blockquote>
<p>MapperProxyFactory实际上是对Mapper接口的包装，我们只需要看源码就知道了。</p>
</blockquote>
<pre><code>public class MapperProxyFactory&lt;T&gt; {

  private final Class&lt;T&gt; mapperInterface;
  private final Map&lt;Method, MapperMethodInvoker&gt; methodCache = new ConcurrentHashMap&lt;&gt;();
</code></pre><blockquote>
<p>构造方法接受一个Mapper的class类型，对其进行封装。</p>
</blockquote>
<pre><code>public MapperProxyFactory(Class&lt;T&gt; mapperInterface) {
  this.mapperInterface = mapperInterface;
}
</code></pre><p>获取到MapperProxyFactory实例之后，通过 <strong>mapperProxyFactory.newInstance(sqlSession)</strong> 就创建出了Mapper的代理对象。</p>
<pre><code>public T newInstance(SqlSession sqlSession) {
  final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
  return newInstance(mapperProxy);
}
</code></pre><p>这里通过SqlSession、Mapper接口、方法缓存（<strong>简单的说就是Mapper的那一堆方法，每次反射创建太耗费性能了，就缓存到一个Map里</strong>）创建出MapperProxy 对象，进一步调用的如下方法：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
  // 1：类加载器:2：被代理类实现的接口、3：实现了 InvocationHandler 的触发管理类
  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}
</code></pre><p>这里把创建代理对象的操作委托给了MapperProxy，<strong>我们发现，它的核心就是创建代理Mapper的代理对象 （h对象）。</strong></p>
<h3 id="MapperProxy具体是如何创建的Mapper代理？"><a href="#MapperProxy具体是如何创建的Mapper代理？" class="headerlink" title="MapperProxy具体是如何创建的Mapper代理？"></a>MapperProxy具体是如何创建的Mapper代理？</h3><p>我们都知道，动态代理在JDK中是通过实现InvocationHandler接口实现的，那么大胆猜想MapperProxy必然实现了InvocationHandler接口。</p>
<pre><code>public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {
</code></pre><p>果然如此。</p>
<p>我们来看它的invoke方法实现：</p>
<pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    // toString hashCode equals getClass等方法，无需走到执行SQL的流程
    if (Object.class.equals(method.getDeclaringClass())) {
      return method.invoke(this, args);
    } else {
      // 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的 invoke
      // 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke
      return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
    }
  } catch (Throwable t) {
    throw ExceptionUtil.unwrapThrowable(t);
  }
}
</code></pre><p>可以看到，如果是普通方法，直接执行，不需要特殊处理；</p>
<p>否则就获取匹配的缓存Mapper方法，执行数据库操作。</p>
<blockquote>
<p>重点看一下  cachedInvoker(method).invoke(proxy, method, args, sqlSession); 逻辑。</p>
</blockquote>
<pre><code>private MapperMethodInvoker cachedInvoker(Method method) throws Throwable {
  try {

    // Java8 中 Map 的方法，根据 key 获取值，如果值是 null，则把后面Object 的值赋给 key
    // 如果获取不到，就创建
    // 获取的是 MapperMethodInvoker（接口） 对象，只有一个invoke方法

    return methodCache.computeIfAbsent(method, m -&gt; {
      if (m.isDefault()) {

        // 接口的默认方法(Java8)，只要实现接口都会继承接口的默认方法，例如 List.sort()

        try {
          if (privateLookupInMethod == null) {
            return new DefaultMethodInvoker(getMethodHandleJava8(method));
          } else {
            return new DefaultMethodInvoker(getMethodHandleJava9(method));
          }
        } catch (IllegalAccessException | InstantiationException | InvocationTargetException
            | NoSuchMethodException e) {
          throw new RuntimeException(e);
        }

      } else {

        // 创建了一个 MapperMethod
        return new PlainMethodInvoker(new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));

      }
    });
  } catch (RuntimeException re) {
    Throwable cause = re.getCause();
    throw cause == null ? re : cause;
  }
}
</code></pre><p>这里针对Java8接口的默认方法做了些处理，这个地方不用特殊关注，我们重点看else逻辑：</p>
<pre><code>// 创建了一个 MapperMethod
return new PlainMethodInvoker(
    new MapperMethod(
      mapperInterface, 
      method,
      sqlSession.getConfiguration()));
</code></pre><h2 id="Mybatis执行sql语句的真正开端："><a href="#Mybatis执行sql语句的真正开端：" class="headerlink" title="Mybatis执行sql语句的真正开端："></a>Mybatis执行sql语句的真正开端：</h2><blockquote>
<p>上文中，我们费尽努力，获取到了 <strong>PlainMethodInvoker</strong> 实例，其实到这里，才是Mybatis执行SQL真正的起点。</p>
</blockquote>
<p>不要慌，继续跟上我的脚步，我们一鼓作气往后看。</p>
<p>上文中，我们知道Mapper对象实际上是Mapper接口的代理对象，而且是JDK的动态代理。</p>
<p>当执行Mapper的各种数据库操作方法时，实际上是调用的代理对象的方法，也就是invoke方法。</p>
<p>对于Mapper方法而言，其实就是调用的PlainMethodInvoker的invoke方法。</p>
<p>忘了？那么我们再复习一下这部分的代码：</p>
<pre><code>// org.apache.ibatis.binding.MapperProxy#invoke
// 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke
return cachedInvoker(method).invoke(proxy, method, args, sqlSession);
</code></pre><p>接着来看PlainMethodInvoker的invoke方法：</p>
<pre><code>@Override
public Object invoke(
                    Object proxy, 
                    Method method, 
                    Object[] args, 
                    SqlSession sqlSession) throws Throwable {
  // SQL执行的真正起点
  return mapperMethod.execute(sqlSession, args);
}
</code></pre><p>实际上这里的mapperMethod就是我们Mapper接口或者说XML文件中定义的方法名了。</p>
<blockquote>
<p>接着就是重头戏，MapperMethod#execute 方法，完整代码我贴这儿了。</p>
</blockquote>
<pre><code>// org.apache.ibatis.binding.MapperMethod#execute
public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        // 普通 select 语句的执行入口 &gt;&gt;
        result = sqlSession.selectOne(command.getName(), param);
        if (method.returnsOptional()
            &amp;&amp; (result == null || !method.getReturnType().equals(result.getClass()))) {
          result = Optional.ofNullable(result);
        }
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
  }
  if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) {
    throw new BindingException(&quot;Mapper method &apos;&quot; + command.getName()
        + &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;);
  }
  return result;
}
</code></pre><p>重点看那个switch case，不用注释一眼看过去基本上也能看个八九不离十，这里就是通过sql的类型去执行不同的jdbc操作。</p>
<blockquote>
<p>可以看到，熟悉的操作他来了，通过SqlSession完成一系列的数据库操作。</p>
</blockquote>
<p>我们的demo是一个查询操作，那么我们就挑select来看看。</p>
<p>普通select语句的入口如下：</p>
<pre><code>result = sqlSession.selectOne(command.getName(), param);
</code></pre><p>继续深入：</p>
<pre><code>// DefaultSqlSession#selectOne(java.lang.String, java.lang.Object)
@Override
public &lt;T&gt; T selectOne(String statement, Object parameter) {
  // 来到了 DefaultSqlSession
  // Popular vote was to return null on 0 results and throw exception on too many.
  List&lt;T&gt; list = this.selectList(statement, parameter);
  if (list.size() == 1) {
    return list.get(0);
  } else if (list.size() &gt; 1) {
    throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());
  } else {
    return null;
  }
}
</code></pre><p>可以看到是通过selectList来完成查询多个和单个。</p>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) {
  // 为了提供多种重载（简化方法使用），和默认值
  // 让参数少的调用参数多的方法，只实现一次
  return this.selectList(statement, parameter, RowBounds.DEFAULT);
}
</code></pre><p>继续看多参重载方法：</p>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  try {
    MappedStatement ms = configuration.getMappedStatement(statement);
    // 如果 cacheEnabled = true（默认），Executor会被 CachingExecutor装饰
    return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
</code></pre><p>核心代码就是executor.query，我们进去看看：</p>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
  BoundSql boundSql = ms.getBoundSql(parameter);
  // 一级缓存和二级缓存的CacheKey是同一个
  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);
  return query(ms, parameter, rowBounds, resultHandler, key, boundSql);
}
</code></pre><p>这里涉及到一级缓存和二级缓存，不是重点，我们就想看看最终是怎么执行的jdbc操作，那么就只需要继续看query重载。</p>
<pre><code>// org.apache.ibatis.executor.BaseExecutor#query
@Override
public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {

  // 异常体系之 ErrorContext
  ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());

  if (closed) {
    throw new ExecutorException(&quot;Executor was closed.&quot;);
  }

  if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) {
    // flushCache=&quot;true&quot;时，即使是查询，也清空一级缓存
    clearLocalCache();
  }

  List&lt;E&gt; list;
  try {

    // 防止递归查询重复处理缓存
    queryStack++;
    // 查询一级缓存
    // ResultHandler 和 ResultSetHandler的区别
    list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;

    if (list != null) {
      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
    } else {

      // 真正的查询流程
      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);

      ...省略N行代码...
</code></pre><p>涉及到缓存的，通通与我无关，只看真正的查询流程 <strong>queryFromDatabase</strong>。</p>
<pre><code>private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
  List&lt;E&gt; list;
  // 先占位
  localCache.putObject(key, EXECUTION_PLACEHOLDER);
  try {
    // 三种 Executor 的区别，看doUpdate
    // 默认Simple
    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
  } finally {
    // 移除占位符
    localCache.removeObject(key);
  }
  // 写入一级缓存
  localCache.putObject(key, list);
  if (ms.getStatementType() == StatementType.CALLABLE) {
    localOutputParameterCache.putObject(key, parameter);
  }
  return list;
}
</code></pre><h3 id="看到jdbc了，胜利的曙光。"><a href="#看到jdbc了，胜利的曙光。" class="headerlink" title="看到jdbc了，胜利的曙光。"></a>看到jdbc了，胜利的曙光。</h3><p>舒服，继续看doQuery方法，看到resultHandler了么，结果处理器，感觉离结果更近了。</p>
<pre><code>// org.apache.ibatis.executor.SimpleExecutor#doQuery
@Override
public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
  Statement stmt = null;
  try {
    Configuration configuration = ms.getConfiguration();
    // 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
    // 获取一个 Statement对象
    stmt = prepareStatement(handler, ms.getStatementLog());
    // 执行查询
    return handler.query(stmt, resultHandler);
  } finally {
    // 用完就关闭
    closeStatement(stmt);
  }
}
</code></pre><p>查询用的Exucutor就是默认的SimpleExecutor，看到了熟悉的prepareStatement获取流程，基本上就到底层jdbc了。那么我们就看看 <strong>prepareStatement(handler, ms.getStatementLog());</strong></p>
<pre><code>private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
  Statement stmt;
  Connection connection = getConnection(statementLog);
  // 获取 Statement 对象
  stmt = handler.prepare(connection, transaction.getTimeout());
  // 为 Statement 设置参数
  handler.parameterize(stmt);
  return stmt;
}
</code></pre><p>看到这里，就到jdbc层面了，我们看到了熟悉的Connection，获取到connection之后再获取Statement。</p>
<p>这里的Statement就是java.sql的statement接口。</p>
<blockquote>
<p>org.apache.ibatis.executor.statement.SimpleStatementHandler#query</p>
</blockquote>
<pre><code>@Override
public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
  String sql = boundSql.getSql();
  statement.execute(sql);
  return resultSetHandler.handleResultSets(statement);
}
</code></pre><p>已经获取到了sql，通过Statement去执行sql，在通过resultSetHandler处理结果集。</p>
<h4 id="通过Statement去执行sql"><a href="#通过Statement去执行sql" class="headerlink" title="通过Statement去执行sql"></a>通过Statement去执行sql</h4><pre><code>statement.execute(sql);
</code></pre><p>这里就已经是jdbc层面的操作了，通过与数据库建立的connection提交并执行sql。</p>
<h4 id="通过resultSetHandler处理结果集"><a href="#通过resultSetHandler处理结果集" class="headerlink" title="通过resultSetHandler处理结果集"></a>通过resultSetHandler处理结果集</h4><blockquote>
<p>都到最后了，我们也不慌了，那么就看看org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSets是如何处理结果集的。</p>
</blockquote>
<pre><code>@Override
public List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException {
  ErrorContext.instance().activity(&quot;handling results&quot;).object(mappedStatement.getId());

  final List&lt;Object&gt; multipleResults = new ArrayList&lt;&gt;();

  int resultSetCount = 0;
  ResultSetWrapper rsw = getFirstResultSet(stmt);

  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();
  int resultMapCount = resultMaps.size();
  validateResultMapsCount(rsw, resultMapCount);
  while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) {
    ResultMap resultMap = resultMaps.get(resultSetCount);
    handleResultSet(rsw, resultMap, multipleResults, null);
    rsw = getNextResultSet(stmt);
    cleanUpAfterHandlingResultSet();
    resultSetCount++;
  }

  String[] resultSets = mappedStatement.getResultSets();
  if (resultSets != null) {
    while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) {
      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
      if (parentMapping != null) {
        String nestedResultMapId = parentMapping.getNestedResultMapId();
        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
        // 在此处处理结果集
        handleResultSet(rsw, resultMap, null, parentMapping);
      }
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }
  }

  return collapseSingleResultList(multipleResults);
}
</code></pre><p>这么一坨代码，只需要重点看</p>
<pre><code>handleResultSet(rsw, resultMap, null, parentMapping);

private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException {
  try {
    if (parentMapping != null) {
      handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);
    } else {
      if (resultHandler == null) {
        DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);
        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);
        multipleResults.add(defaultResultHandler.getResultList());
      } else {
        handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);
      }
    }
  } finally {
    // issue #228 (close resultsets)
    closeResultSet(rsw.getResultSet());
  }
}
</code></pre><p>看看handleRowValues的逻辑 (有点心累)</p>
<p>最终，来到了这个地方：</p>
<pre><code>// org.apache.ibatis.executor.resultset.DefaultResultSetHandler
//         #handleRowValuesForSimpleResultMap
private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)
    throws SQLException {
  DefaultResultContext&lt;Object&gt; resultContext = new DefaultResultContext&lt;&gt;();

  // 看到了吧，没什么好说的，就是jdbc的结果集处理
  ResultSet resultSet = rsw.getResultSet();

  skipRows(resultSet, rowBounds);
  while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) {
    ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(resultSet, resultMap, null);
    Object rowValue = getRowValue(rsw, discriminatedResultMap, null);
    storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);
  }
}
</code></pre><p>看到了熟悉的ResultSet获取结果集的操作，Mybatis执行sql的流程基本就结束了。</p>
<p>底层还是熟悉的JDBC操作。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实写了这么多，也没啥想总结的，我们通过一个查询操作，完整的把Mybatis从解析文件到执行sql，再到结果集处理都从源码级别剖析了一遍。</p>
<p>那么我们回答一下开头的问题：</p>
<h3 id="我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？"><a href="#我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？" class="headerlink" title="我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？"></a>我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？</h3><p>其实我们获取到的Mapper对象，已经是Mybatis帮我们生成的代理对象了，这个代理对象拥有与jdbc交互的一切必要条件。</p>
<h3 id="都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？"><a href="#都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？" class="headerlink" title="都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？"></a>都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？</h3><p>稍微往上翻翻，我们刚讲了，实际上最底层就是封装的jdbc的接口。</p>
<p>我们看不到但是用到了，并且用起来还很爽，这就是封装的魅力啊。</p>
<h3 id="为什么在Spring中使用Mybatis，不用加-Repository-Component之类的注解，就可以随用随注入（如：-Autowired）"><a href="#为什么在Spring中使用Mybatis，不用加-Repository-Component之类的注解，就可以随用随注入（如：-Autowired）" class="headerlink" title="为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?"></a>为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?</h3><p>这个问题，就放到之后的文章讲解吧，那么就敬请期待下一篇：Mybatis与Spring的爱情故事（从源码层面解析，Mybatis是如何利用Spring扩展点，实现与Spring整合的。）</p>
<p>最后，贴张图，概括一下这个过程。图是借来的，仅供学习讨论，侵删。</p>
<blockquote>
<p>创建会话工厂SqlSessionFactory</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/1.png" alt="flow/1.png"></p>
<blockquote>
<p>创建会话SqlSession</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/2.png" alt="flow/2.png"></p>
<blockquote>
<p>创建代理对象</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/3.png" alt="flow/3.png"></p>
<blockquote>
<p>调用代理对象，执行SQL流程</p>
</blockquote>
<p><img src="/2022/02/20/源码级探究Mybatis原理-以查询为例/flow/4.png" alt="flow/4.png"></p>
<p>那么，不见不散。</p>
<p><hr><br>版权声明：<br><br>原创不易，洗文可耻。除非注明，本博文章均为原创，转载请以链接形式标明本文地址。<br></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java/">Java</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/" data-title="源码级探究Mybatis原理-以查询为例 | 朝·闻·道" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2022/02/22/调优利器-火焰图使用图鉴/" title="调优利器-火焰图使用图鉴">
  <strong>上一篇：</strong><br/>
  <span>
  调优利器-火焰图使用图鉴</span>
</a>
</div>


<div class="next">
<a href="/2022/01/29/Spring扩展点1-研磨ImportBeanDefinitionRegistrar/"  title="Spring扩展点1-研磨ImportBeanDefinitionRegistrar">
 <strong>下一篇：</strong><br/> 
 <span>Spring扩展点1-研磨ImportBeanDefinitionRegistrar
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2022/02/20/源码级探究Mybatis原理-以查询为例/" data-title="源码级探究Mybatis原理-以查询为例" data-url="http://wuwenliang.net/2022/02/20/源码级探究Mybatis原理-以查询为例/"></div>
</section>




</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、先看一个demo"><span class="toc-number">1.</span> <span class="toc-text">一、先看一个demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、一图总览全局"><span class="toc-number">2.</span> <span class="toc-text">二、一图总览全局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载并解析配置文件"><span class="toc-number">2.1.</span> <span class="toc-text">加载并解析配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取SqlSession对象作为与数据库交互的接口"><span class="toc-number">2.2.</span> <span class="toc-text">获取SqlSession对象作为与数据库交互的接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过SqlSessionFactory获取SqlSession会话"><span class="toc-number">2.3.</span> <span class="toc-text">通过SqlSessionFactory获取SqlSession会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过Executor对象封装数据库操作，执行SQL操作"><span class="toc-number">2.4.</span> <span class="toc-text">通过Executor对象封装数据库操作，执行SQL操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、走进源码，一探究竟"><span class="toc-number">3.</span> <span class="toc-text">三、走进源码，一探究竟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-SqlSessionFactory的创建"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 SqlSessionFactory的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-SqlSession的创建"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 SqlSession的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理Mapper对象，执行SQL"><span class="toc-number">3.3.</span> <span class="toc-text">代理Mapper对象，执行SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapperProxy具体是如何创建的Mapper代理？"><span class="toc-number">3.4.</span> <span class="toc-text">MapperProxy具体是如何创建的Mapper代理？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis执行sql语句的真正开端："><span class="toc-number">4.</span> <span class="toc-text">Mybatis执行sql语句的真正开端：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#看到jdbc了，胜利的曙光。"><span class="toc-number">4.1.</span> <span class="toc-text">看到jdbc了，胜利的曙光。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通过Statement去执行sql"><span class="toc-number">4.1.1.</span> <span class="toc-text">通过Statement去执行sql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通过resultSetHandler处理结果集"><span class="toc-number">4.1.2.</span> <span class="toc-text">通过resultSetHandler处理结果集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？"><span class="toc-number">5.1.</span> <span class="toc-text">我只是写了个Mapper接口，再配合xml或者注解，把SQL一写，就可以执行数据库操作，这是为何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？"><span class="toc-number">5.2.</span> <span class="toc-text">都说Mybatis是对JDBC的封装，可是我却看不到JDBC相关的接口和对象，它们到哪里去了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在Spring中使用Mybatis，不用加-Repository-Component之类的注解，就可以随用随注入（如：-Autowired）"><span class="toc-number">5.3.</span> <span class="toc-text">为什么在Spring中使用Mybatis，不用加@Repository/@Component之类的注解，就可以随用随注入（如：@Autowired）?</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/CouchDB/" title="CouchDB">CouchDB<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/DDD/" title="DDD">DDD<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/ELK-Stack/" title="ELK-Stack">ELK-Stack<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/HTTPS/" title="HTTPS">HTTPS<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/JDK-concurrent/" title="JDK-concurrent">JDK-concurrent<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/JDK源码解析/" title="JDK源码解析">JDK源码解析<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>37</sup></a></li>
		  
		
		  
			<li><a href="/categories/KindEditor/" title="KindEditor">KindEditor<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/SSO/" title="SSO">SSO<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/SpringCloud/" title="SpringCloud">SpringCloud<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Spring扩展点/" title="Spring扩展点">Spring扩展点<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/TCC-Transaction源码解析/" title="TCC-Transaction源码解析">TCC-Transaction源码解析<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tomcat/" title="Tomcat">Tomcat<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/auth/" title="auth">auth<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/docker/" title="docker">docker<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/kubernates/" title="kubernates">kubernates<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/maven/" title="maven">maven<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/mybatis/" title="mybatis">mybatis<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/mysql/" title="mysql">mysql<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/nginx/" title="nginx">nginx<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/nginx-负载均衡/" title="nginx, 负载均衡">nginx, 负载均衡<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/spring-boot/" title="spring-boot">spring-boot<sup>38</sup></a></li>
		  
		
		  
			<li><a href="/categories/springboot/" title="springboot">springboot<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/web/" title="web">web<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/与你同行/" title="与你同行">与你同行<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/专题-分布式/" title="专题-分布式">专题-分布式<sup>19</sup></a></li>
		  
		
		  
			<li><a href="/categories/从零学Netty/" title="从零学Netty">从零学Netty<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/代理模式-工作总结-入职感受/" title="代理模式,工作总结,入职感受">代理模式,工作总结,入职感受<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/分布式-Dubbo/" title="分布式 Dubbo">分布式 Dubbo<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/单例模式/" title="单例模式">单例模式<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/实战分布式/" title="实战分布式">实战分布式<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/年度总结/" title="年度总结">年度总结<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据库/" title="数据库">数据库<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/架构/" title="架构">架构<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/汇总盘点推荐/" title="汇总盘点推荐">汇总盘点推荐<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/电话面试/" title="电话面试">电话面试<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/研磨Kafka/" title="研磨Kafka">研磨Kafka<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/自己写分布式组件系列/" title="自己写分布式组件系列">自己写分布式组件系列<sup>17</sup></a></li>
		  
		
		  
			<li><a href="/categories/跟我学RocketMQ/" title="跟我学RocketMQ">跟我学RocketMQ<sup>25</sup></a></li>
		  
		
		  
			<li><a href="/categories/跟我学zookeeper/" title="跟我学zookeeper">跟我学zookeeper<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/金融系统/" title="金融系统">金融系统<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/随笔/" title="随笔">随笔<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/音视频/" title="音视频">音视频<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/CouchDB/" style="font-size: 10px;">CouchDB</a> <a href="/tags/DDD/" style="font-size: 14.55px;">DDD</a> <a href="/tags/Dubbo/" style="font-size: 12.73px;">Dubbo</a> <a href="/tags/ELK-Stack/" style="font-size: 15.45px;">ELK-Stack</a> <a href="/tags/HTTPS/" style="font-size: 10px;">HTTPS</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/JDK-concurrent/" style="font-size: 12.73px;">JDK-concurrent</a> <a href="/tags/JDK源码解析/" style="font-size: 12.73px;">JDK源码解析</a> <a href="/tags/Java/" style="font-size: 19.09px;">Java</a> <a href="/tags/KindEditor/" style="font-size: 10px;">KindEditor</a> <a href="/tags/Linux/" style="font-size: 10.91px;">Linux</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSO-单点登录/" style="font-size: 10px;">SSO,单点登录</a> <a href="/tags/Sharding-JDBC/" style="font-size: 12.73px;">Sharding-JDBC</a> <a href="/tags/SpringCloud/" style="font-size: 10px;">SpringCloud</a> <a href="/tags/Spring扩展点/" style="font-size: 10px;">Spring扩展点</a> <a href="/tags/TCC-Transaction源码解析/" style="font-size: 10.91px;">TCC-Transaction源码解析</a> <a href="/tags/Tomcat/" style="font-size: 10.91px;">Tomcat</a> <a href="/tags/auth/" style="font-size: 10.91px;">auth</a> <a href="/tags/docker/" style="font-size: 11.82px;">docker</a> <a href="/tags/hexo/" style="font-size: 10.91px;">hexo</a> <a href="/tags/kubernates/" style="font-size: 10px;">kubernates</a> <a href="/tags/maven/" style="font-size: 11.82px;">maven</a> <a href="/tags/mybatis/" style="font-size: 10.91px;">mybatis</a> <a href="/tags/mysql/" style="font-size: 13.64px;">mysql</a> <a href="/tags/nginx/" style="font-size: 10.91px;">nginx</a> <a href="/tags/spring-boot/" style="font-size: 20px;">spring-boot</a> <a href="/tags/springboot/" style="font-size: 10px;">springboot</a> <a href="/tags/web/" style="font-size: 12.73px;">web</a> <a href="/tags/与你同行/" style="font-size: 10px;">与你同行</a> <a href="/tags/专题-分布式/" style="font-size: 17.27px;">专题-分布式</a> <a href="/tags/从零学Netty/" style="font-size: 10.91px;">从零学Netty</a> <a href="/tags/代理模式-工作总结-入职感受/" style="font-size: 10px;">代理模式,工作总结,入职感受</a> <a href="/tags/分布式-Dubbo/" style="font-size: 12.73px;">分布式 Dubbo</a> <a href="/tags/单例模式-懒加载/" style="font-size: 10px;">单例模式, 懒加载</a> <a href="/tags/实战分布式/" style="font-size: 11.82px;">实战分布式</a> <a href="/tags/年度总结/" style="font-size: 14.55px;">年度总结</a> <a href="/tags/我们的爱情/" style="font-size: 10px;">我们的爱情</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/汇总盘点推荐/" style="font-size: 10px;">汇总盘点推荐</a> <a href="/tags/爬虫-WebMagic/" style="font-size: 10px;">爬虫,WebMagic</a> <a href="/tags/电话面试/" style="font-size: 10px;">电话面试</a> <a href="/tags/研磨Kafka/" style="font-size: 14.55px;">研磨Kafka</a> <a href="/tags/秒杀/" style="font-size: 10px;">秒杀</a> <a href="/tags/自己写分布式组件系列/" style="font-size: 16.36px;">自己写分布式组件系列</a> <a href="/tags/跟我学RocketMQ/" style="font-size: 18.18px;">跟我学RocketMQ</a> <a href="/tags/跟我学zookeeper/" style="font-size: 10px;">跟我学zookeeper</a> <a href="/tags/金融系统/" style="font-size: 10px;">金融系统</a> <a href="/tags/随笔/" style="font-size: 15.45px;">随笔</a> <a href="/tags/音视频/" style="font-size: 10px;">音视频</a>
    </div>
  </div>


  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="TaXueWWL" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/spring-boot/" title="spring-boot">spring-boot<sup>38</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>37</sup></a></li>
			
		
			
				<li><a href="/tags/跟我学RocketMQ/" title="跟我学RocketMQ">跟我学RocketMQ<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/专题-分布式/" title="专题-分布式">专题-分布式<sup>19</sup></a></li>
			
		
			
				<li><a href="/tags/自己写分布式组件系列/" title="自己写分布式组件系列">自己写分布式组件系列<sup>17</sup></a></li>
			
		
			
				<li><a href="/tags/ELK-Stack/" title="ELK-Stack">ELK-Stack<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/随笔/" title="随笔">随笔<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/DDD/" title="DDD">DDD<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/年度总结/" title="年度总结">年度总结<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/研磨Kafka/" title="研磨Kafka">研磨Kafka<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Dubbo/" title="Dubbo">Dubbo<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/web/" title="web">web<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/JDK源码解析/" title="JDK源码解析">JDK源码解析<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/JDK-concurrent/" title="JDK-concurrent">JDK-concurrent<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/分布式-Dubbo/" title="分布式 Dubbo">分布式 Dubbo<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/maven/" title="maven">maven<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/实战分布式/" title="实战分布式">实战分布式<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="undefined" target="_blank" title="rss">RSS 订阅</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p>  <br/>
			惟精惟一，允执厥中 朝闻道，夕死可矣</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/TaXueWWL" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/TaXueWWL" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:wuwenliangsn@gmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2022 
		
		<a href="/about" target="_blank" title="SnoWalker">SnoWalker</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"snowalker"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

<a href="https://github.com/TaXueWWL" target="_blank"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a>